<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>CPP Primer 知识点笔记 | 笑枕晚风の小站</title><meta name="keywords" content="C++"><meta name="author" content="SEUGarfield"><meta name="copyright" content="SEUGarfield"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="CPP Primer 知识点笔记 第1章 开始 最简单的main函数： 123int main() &amp;#123;    return 0;&amp;#125; C++包含两种注释，注释界定符&#x2F;**&#x2F;通常用于多行注释，而双斜杠&#x2F;&#x2F;通常用于单行或半行注释。 123456789101112131415#include &lt;iostream&gt;&#x2F;** Simple main function:* Read">
<meta property="og:type" content="article">
<meta property="og:title" content="CPP Primer 知识点笔记">
<meta property="og:url" content="https://blog.zgzheng.top/posts/45995/index.html">
<meta property="og:site_name" content="笑枕晚风の小站">
<meta property="og:description" content="CPP Primer 知识点笔记 第1章 开始 最简单的main函数： 123int main() &amp;#123;    return 0;&amp;#125; C++包含两种注释，注释界定符&#x2F;**&#x2F;通常用于多行注释，而双斜杠&#x2F;&#x2F;通常用于单行或半行注释。 123456789101112131415#include &lt;iostream&gt;&#x2F;** Simple main function:* Read">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031713662.jpg">
<meta property="article:published_time" content="2021-11-01T06:20:46.000Z">
<meta property="article:modified_time" content="2022-04-14T15:20:36.145Z">
<meta property="article:author" content="SEUGarfield">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031713662.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202201121022530.png"><link rel="canonical" href="https://blog.zgzheng.top/posts/45995/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="jHeEqmxcY5gJhgQXHPVzNF9LSawljE99iQNENuIPBp4"/><meta name="baidu-site-verification" content="code-PCT1t1AN4f"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?fd347c67a4aa89bb0cfbfa45cf3b7a98";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-2FF9T1FD5L"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2FF9T1FD5L');
</script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "9ds0zhvaq8");</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CPP Primer 知识点笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-14 23:20:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="笑枕晚风の小站" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202110251550056.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">93</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/steamgames/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031713662.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">笑枕晚风の小站</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/steamgames/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CPP Primer 知识点笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-01T06:20:46.000Z" title="发表于 2021-11-01 14:20:46">2021-11-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-14T15:20:36.145Z" title="更新于 2022-04-14 23:20:36">2022-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">85.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>313分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CPP Primer 知识点笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>CPP Primer 知识点笔记</h1>
<h2 id="第1章-开始">第1章 开始</h2>
<p>最简单的<code>main</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++包含两种注释，注释界定符<code>/**/</code>通常用于多行注释，而双斜杠<code>//</code>通常用于单行或半行注释。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Simple main function:</span></span><br><span class="line"><span class="comment">* Read two numbers and write their sum</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, val = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// keep executing the while as long as val is less than or equal to 10</span></span><br><span class="line">    <span class="keyword">while</span> (val &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">        sum += val;  <span class="comment">// assigns sum + val to sum</span></span><br><span class="line">        ++val;       <span class="comment">// add 1 to val</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum of 1 to 10 inclusive is &quot;</span>&lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="熟悉编译器">熟悉编译器</h3>
<p><strong>g++</strong>：</p>
<ul>
<li>编译：<code>g++ --std=c++11 ch01.cpp -o main</code></li>
<li>运行：<code>./prog1</code></li>
<li>查看运行状态：<code>echo $?</code></li>
<li>编译多个文件:<code>g++ ch2.cpp Sales_item.cc -o main</code></li>
</ul>
<p>输入 <code>g++ --help</code>，查看编译器选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Usage: g++ [options] file...</span><br><span class="line">Options:</span><br><span class="line">  -pass-exit-codes         Exit with highest error code from a phase</span><br><span class="line">  --<span class="built_in">help</span>                   Display this information</span><br><span class="line">  --target-help            Display target specific <span class="built_in">command</span> line options</span><br><span class="line">  --<span class="built_in">help</span>=&#123;common|optimizers|params|target|warnings|[^]&#123;joined|separate|undocumented&#125;&#125;[,...]</span><br><span class="line">                           Display specific types of <span class="built_in">command</span> line options</span><br><span class="line">  (Use <span class="string">&#x27;-v --help&#x27;</span> to display <span class="built_in">command</span> line options of sub-processes)</span><br><span class="line">  --version                Display compiler version information</span><br><span class="line">  -dumpspecs               Display all of the built <span class="keyword">in</span> spec strings</span><br><span class="line">  -dumpversion             Display the version of the compiler</span><br><span class="line">  -dumpmachine             Display the compiler<span class="string">&#x27;s target processor</span></span><br><span class="line"><span class="string">  -print-search-dirs       Display the directories in the compiler&#x27;</span>s search path</span><br><span class="line">  -print-libgcc-file-name  Display the name of the compiler<span class="string">&#x27;s companion library</span></span><br><span class="line"><span class="string">  -print-file-name=&lt;lib&gt;   Display the full path to library &lt;lib&gt;</span></span><br><span class="line"><span class="string">  -print-prog-name=&lt;prog&gt;  Display the full path to compiler component &lt;prog&gt;</span></span><br><span class="line"><span class="string">  -print-multiarch         Display the target&#x27;</span>s normalized GNU triplet, used as</span><br><span class="line">                           a component <span class="keyword">in</span> the library path</span><br><span class="line">  -print-multi-directory   Display the root directory <span class="keyword">for</span> versions of libgcc</span><br><span class="line">  -print-multi-lib         Display the mapping between <span class="built_in">command</span> line options and</span><br><span class="line">                           multiple library search directories</span><br><span class="line">  -print-multi-os-directory Display the relative path to OS libraries</span><br><span class="line">  -print-sysroot           Display the target libraries directory</span><br><span class="line">  -print-sysroot-headers-suffix Display the sysroot suffix used to find headers</span><br><span class="line">  -Wa,&lt;options&gt;            Pass comma-separated &lt;options&gt; on to the assembler</span><br><span class="line">  -Wp,&lt;options&gt;            Pass comma-separated &lt;options&gt; on to the preprocessor</span><br><span class="line">  -Wl,&lt;options&gt;            Pass comma-separated &lt;options&gt; on to the linker</span><br><span class="line">  -Xassembler &lt;arg&gt;        Pass &lt;arg&gt; on to the assembler</span><br><span class="line">  -Xpreprocessor &lt;arg&gt;     Pass &lt;arg&gt; on to the preprocessor</span><br><span class="line">  -Xlinker &lt;arg&gt;           Pass &lt;arg&gt; on to the linker</span><br><span class="line">  -save-temps              Do not delete intermediate files</span><br><span class="line">  -save-temps=&lt;arg&gt;        Do not delete intermediate files</span><br><span class="line">  -no-canonical-prefixes   Do not canonicalize paths when building relative</span><br><span class="line">                           prefixes to other gcc components</span><br><span class="line">  -pipe                    Use pipes rather than intermediate files</span><br><span class="line">  -time                    Time the execution of each subprocess</span><br><span class="line">  -specs=&lt;file&gt;            Override built-in specs with the contents of &lt;file&gt;</span><br><span class="line">  -std=&lt;standard&gt;          Assume that the input sources are <span class="keyword">for</span> &lt;standard&gt;</span><br><span class="line">  --sysroot=&lt;directory&gt;    Use &lt;directory&gt; as the root directory <span class="keyword">for</span> headers</span><br><span class="line">                           and libraries</span><br><span class="line">  -B &lt;directory&gt;           Add &lt;directory&gt; to the compiler<span class="string">&#x27;s search paths</span></span><br><span class="line"><span class="string">  -v                       Display the programs invoked by the compiler</span></span><br><span class="line"><span class="string">  -###                     Like -v but options quoted and commands not executed</span></span><br><span class="line"><span class="string">  -E                       Preprocess only; do not compile, assemble or link</span></span><br><span class="line"><span class="string">  -S                       Compile only; do not assemble or link</span></span><br><span class="line"><span class="string">  -c                       Compile and assemble, but do not link</span></span><br><span class="line"><span class="string">  -o &lt;file&gt;                Place the output into &lt;file&gt;</span></span><br><span class="line"><span class="string">  -pie                     Create a position independent executable</span></span><br><span class="line"><span class="string">  -shared                  Create a shared library</span></span><br><span class="line"><span class="string">  -x &lt;language&gt;            Specify the language of the following input files</span></span><br><span class="line"><span class="string">                           Permissible languages include: c c++ assembler none</span></span><br><span class="line"><span class="string">                           &#x27;</span>none<span class="string">&#x27; means revert to the default behavior of</span></span><br><span class="line"><span class="string">                           guessing the language based on the file&#x27;</span>s extension</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入 <code>g++ -v --help</code>可以看到更完整的指令。<br>
例如还有些常用的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-h FILENAME, -soname FILENAME: Set internal name of shared library</span><br><span class="line">-I PROGRAM, --dynamic-linker PROGRAM: Set PROGRAM as the dynamic linker to use</span><br><span class="line">-l LIBNAME, --library LIBNAME: Search <span class="keyword">for</span> library LIBNAME</span><br><span class="line">-L DIRECTORY, --library-path DIRECTORY: Add DIRECTORY to library search path</span><br></pre></td></tr></table></figure>
<p><strong>获得程序状态</strong>:</p>
<ul>
<li>windows: <code>echo %ERRORLEVEL%</code></li>
<li>UNIX: <code>echo $?</code></li>
</ul>
<h3 id="IO">IO</h3>
<ul>
<li><code>#include &lt;iostream&gt;</code></li>
<li><code>std::cout &lt;&lt; &quot;hello&quot;</code></li>
<li><code>std::cin &gt;&gt; v1</code></li>
</ul>
<p>记住<code>&gt;&gt;</code>和<code>&lt;&lt;</code>返回的结果都是左操作数，也就是输入流和输出流本身。</p>
<p><strong>endl</strong>：这是一个被称为<strong>操纵符</strong>（manipulator）的特殊值，效果是结束当前行，并将设备关联的缓冲区（buffer）中的内容刷到设备中。</p>
<p>UNIX和Mac下键盘输入文件结束符：<code>ctrl+d</code>，Windows下：<code>ctrl+z</code></p>
<p><strong>头文件</strong>：类的类型一般存储在头文件中，标准库的头文件使用<code>&lt;&gt;</code>，非标准库的头文件使用<code>&quot;&quot;</code>。申明写在<code>.h</code>文件，定义实现写在<code>.cpp</code>文件。</p>
<p><strong>避免多次包含同一头文件</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALESITEM_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALESITEM_H</span></span><br><span class="line"><span class="comment">// Definition of Sales_itemclass and related functions goes here</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>成员函数（类方法）</strong>：使用<code>.</code>调用。</p>
<p><strong>命名空间（namespace）</strong>：使用作用域运算符<code>::</code>调用。</p>
<h3 id="注释">注释</h3>
<ul>
<li>单行注释： <code>//</code></li>
<li>多行注释： <code>/**/</code>。编译器将<code>/*</code>和<code>*/</code>之间的内容都作为注释内容忽略。注意不能嵌套。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALESITEM_H</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 多行注释格式</span></span><br><span class="line"><span class="comment"> * 每一行加一个*</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="while语句">while语句</h3>
<p>循环执行，（直到条件（condition）为假。</p>
<h3 id="for语句">for语句</h3>
<p>循环头由三部分组成：</p>
<ul>
<li>一个初始化语句（init-statement）</li>
<li>一个循环条件（condition）</li>
<li>一个表达式（expression）</li>
</ul>
<h3 id="使用文件重定向">使用文件重定向</h3>
<p><code>./main &lt;infile &gt;outfile</code></p>
<hr>
<h2 id="第2章-变量和基本类型-简">第2章 变量和基本类型(简)</h2>
<h3 id="基本内置类型">基本内置类型</h3>
<p><strong>基本算数类型</strong>：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>最小尺寸</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bool</code></td>
<td>布尔类型</td>
<td>8bits</td>
</tr>
<tr>
<td><code>char</code></td>
<td>字符</td>
<td>8bits</td>
</tr>
<tr>
<td><code>wchar_t</code></td>
<td>宽字符</td>
<td>16bits</td>
</tr>
<tr>
<td><code>char16_t</code></td>
<td>Unicode字符</td>
<td>16bits</td>
</tr>
<tr>
<td><code>char32_t</code></td>
<td>Unicode字符</td>
<td>32bits</td>
</tr>
<tr>
<td><code>short</code></td>
<td>短整型</td>
<td>16bits</td>
</tr>
<tr>
<td><code>int</code></td>
<td>整型</td>
<td>16bits (在32位机器中是32bits)</td>
</tr>
<tr>
<td><code>long</code></td>
<td>长整型</td>
<td>32bits</td>
</tr>
<tr>
<td><code>long long</code></td>
<td>长整型</td>
<td>64bits （是在C++11中新定义的）</td>
</tr>
<tr>
<td><code>float</code></td>
<td>单精度浮点数</td>
<td>6位有效数字</td>
</tr>
<tr>
<td><code>double</code></td>
<td>双精度浮点数</td>
<td>10位有效数字</td>
</tr>
<tr>
<td><code>long double</code></td>
<td>扩展精度浮点数</td>
<td>10位有效数字</td>
</tr>
</tbody>
</table>
<h3 id="如何选择类型">如何选择类型</h3>
<ul>
<li>1.当明确知晓数值不可能是负数时，选用无符号类型；</li>
<li>2.使用<code>int</code>执行整数运算。一般<code>long</code>的大小和<code>int</code>一样，而<code>short</code>常常显得太小。除非超过了<code>int</code>的范围，选择<code>long long</code>。</li>
<li>3.算术表达式中不要使用<code>char</code>或<code>bool</code>。</li>
<li>4.浮点运算选用<code>double</code>。</li>
</ul>
<h3 id="类型转换">类型转换</h3>
<ul>
<li>非布尔型赋给布尔型，初始值为0则结果为false，否则为true。</li>
<li>布尔型赋给非布尔型，初始值为false结果为0，初始值为true结果为1。</li>
</ul>
<h3 id="字面值常量">字面值常量</h3>
<ul>
<li>
<p>一个形如<code>42</code>的值被称作<strong>字面值常量</strong>（literal）。</p>
<ul>
<li>
<p>整型和浮点型字面值。</p>
</li>
<li>
<p>字符和字符串字面值。</p>
<ul>
<li>
<p>使用空格连接，继承自C。</p>
</li>
<li>
<p>字符字面值：单引号， <code>'a'</code></p>
</li>
<li>
<p>字符串字面值：双引号， <code>&quot;Hello World&quot;&quot;</code></p>
</li>
<li>
<p>分多行书写字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std:cout&lt;&lt;&quot;wow, a really, really long string&quot;</span><br><span class="line">          &quot;literal that spans two lines&quot; &lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>转义序列。<code>\n</code>、<code>\t</code>等。</p>
</li>
<li>
<p>布尔字面值。<code>true</code>，<code>false</code>。</p>
</li>
<li>
<p>指针字面值。<code>nullptr</code></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>字符串型实际上时常量字符构成的数组，结尾处以<code>'\0'</code>结束，所以字符串类型实际上长度比内容多1。</p>
</blockquote>
<h3 id="变量">变量</h3>
<p><strong>变量</strong>提供一个<strong>具名</strong>的、可供程序操作的存储空间。   <code>C++</code>中<strong>变量</strong>和<strong>对象</strong>一般可以互换使用。</p>
<h4 id="变量定义（define）">变量定义（define）</h4>
<ul>
<li><strong>定义形式</strong>：类型说明符（type specifier） + 一个或多个变量名组成的列表。如<code>int sum = 0, value, units_sold = 0;</code></li>
<li><strong>初始化</strong>（initialize）：对象在创建时获得了一个特定的值。
<ul>
<li><strong>初始化不是赋值！</strong>：</li>
<li>初始化 = 创建变量 + 赋予初始值</li>
<li>赋值 = 擦除对象的当前值 + 用新值代替</li>
<li><strong>列表初始化</strong>：使用花括号<code>&#123;&#125;</code>，如<code>int units_sold&#123;0&#125;;</code></li>
<li>默认初始化：定义时没有指定初始值会被默认初始化；<strong>在函数体内部的内置类型变量将不会被初始化</strong>。</li>
<li>建议初始化每一个内置类型的变量。</li>
</ul>
</li>
</ul>
<h4 id="变量的声明（declaration）-vs-定义（define）">变量的<strong>声明</strong>（declaration） vs <strong>定义</strong>（define）</h4>
<ul>
<li>为了支持分离式编译，<code>C++</code>将声明和定义区分开。<strong>声明</strong>使得名字为程序所知。<strong>定义</strong>负责创建与名字关联的实体。</li>
<li><strong>extern</strong>：只是说明变量定义在其他地方。</li>
<li>只声明而不定义： 在变量名前添加关键字 <code>extern</code>，如<code>extern int i;</code>。但如果包含了初始值，就变成了定义：<code>extern double pi = 3.14;</code></li>
<li>变量只能被定义一次，但是可以多次声明。定义只出现在一个文件中，其他文件使用该变量时需要对其声明。</li>
<li>名字的<strong>作用域</strong>（namescope）<code>&#123;&#125;</code>
<ul>
<li><strong>第一次使用变量时再定义它</strong>。</li>
<li>嵌套的作用域
<ul>
<li>同时存在全局和局部变量时，已定义局部变量的作用域中可用<code>::reused</code>显式访问全局变量reused。</li>
<li><strong>但是用到全局变量时，尽量不适用重名的局部变量。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>变量命名规范</p>
<ol>
<li>需体现实际意义</li>
<li>变量名用小写字母</li>
<li>自定义类名用大写字母开头：Sales_item</li>
<li>标识符由多个单词组成，中间须有明确区分：student_loan或studentLoan，不要用studentloan。</li>
</ol>
<h3 id="左值和右值">左值和右值</h3>
<ul>
<li><strong>左值</strong>（l-value）<strong>可以</strong>出现在赋值语句的左边或者右边，比如变量；</li>
<li><strong>右值</strong>（r-value）<strong>只能</strong>出现在赋值语句的右边，比如常量。</li>
</ul>
<h3 id="复合类型">复合类型</h3>
<h4 id="引用">引用</h4>
<blockquote>
<p>一般说的引用是指的左值引用</p>
</blockquote>
<ul>
<li><strong>引用</strong>：引用是一个对象的别名，引用类型引用（refer to）另外一种类型。如<code>int &amp;refVal = val;</code>。</li>
<li>引用必须初始化。</li>
<li>引用和它的初始值是<strong>绑定bind</strong>在一起的，而<strong>不是拷贝</strong>。一旦定义就不能更改绑定为其他的对象</li>
</ul>
<h4 id="指针">指针</h4>
<blockquote>
<p>int *p;      //<strong>指向int型对象</strong>的指针</p>
</blockquote>
<ul>
<li>
<p>是一种 <code>&quot;指向（point to）&quot;</code>另外一种类型的复合类型。</p>
</li>
<li>
<p><strong>定义</strong>指针类型： <code>int *ip1;</code>，<strong>从右向左读有助于阅读</strong>，<code>ip1</code>是指向<code>int</code>类型的指针。</p>
</li>
<li>
<p>指针存放某个对象的<strong>地址</strong>。</p>
</li>
<li>
<p>获取对象的地址： <code>int i=42; int *p = &amp;i;</code>。 <code>&amp;</code>是<strong>取地址符</strong>。</p>
</li>
<li>
<p>指针的类型与所指向的对象类型必须一致（均为同一类型int、double等）</p>
</li>
<li>
<p>指针的值的四种状态：</p>
<ul>
<li>
<p>1.指向一个对象；</p>
</li>
<li>
<p>2.指向紧邻对象的下一个位置；</p>
</li>
<li>
<p>3.空指针；</p>
</li>
<li>
<p>4.无效指针。</p>
</li>
<li>
<blockquote>
<p><strong>对无效指针的操作均会引发错误，第二种和第三种虽为有效的，但理论上是不被允许的</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>指针访问对象： <code>cout &lt;&lt; *p;</code>输出p指针所指对象的数据， <code>*</code>是<strong>解引用符</strong>。</p>
</li>
<li>
<p>空指针不指向任何对象。使用<code>int *p=nullptr;</code>来使用空指针。</p>
</li>
<li>
<blockquote>
<p>指针和引用的区别：引用本身并非一个对象，引用定义后就不能绑定到其他的对象了；指针并没有此限制，相当于变量一样使用。</p>
</blockquote>
</li>
<li>
<blockquote>
<p>赋值语句永远改变的是<strong>左侧</strong>的对象。</p>
</blockquote>
</li>
<li>
<p><code>void*</code>指针可以存放<strong>任意</strong>对象的地址。因无类型，仅操作内存空间，对所存对象无法访问。</p>
</li>
<li>
<p>其他指针类型必须要与所指对象<strong>严格匹配</strong>。</p>
</li>
<li>
<p>两个指针相减的类型是<code>ptrdiff_t</code>。</p>
</li>
<li>
<p>建议：初始化所有指针。</p>
</li>
<li>
<p><code>int* p1, p2;//*是对p1的修饰，所以p2还是int型</code></p>
</li>
</ul>
<h3 id="const限定符">const限定符</h3>
<ul>
<li>动机：希望定义一些不能被改变值的变量。</li>
</ul>
<h4 id="初始化和const">初始化和const</h4>
<ul>
<li>const对象<strong>必须初始化</strong>，且<strong>不能被改变</strong>。</li>
<li>const变量默认不能被其他文件访问，非要访问，必须在指定const定义之前加extern。要想在多个文件中使用const变量共享，定义和声明都加const关键字即可。</li>
</ul>
<h4 id="const的引用">const的引用</h4>
<ul>
<li><strong>reference to const</strong>（对常量的引用）：指向const对象的引用，如 <code>const int ival=1; const int &amp;refVal = ival;</code>，可以读取但不能修改<code>refVal</code>。</li>
<li><strong>临时量</strong>（temporary）对象：当编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象。</li>
<li>对临时量的引用是非法行为。</li>
</ul>
<h4 id="指针和const">指针和const</h4>
<ul>
<li><strong>pointer to const</strong>（指向常量的指针）：不能用于改变其所指对象的值, 如 <code>const double pi = 3.14; const double *cptr = &amp;pi;</code>。</li>
<li><strong>const pointer</strong>：指针本身是常量，也就是说指针固定指向该对象，（存放在指针中的地址不变，地址所对应的那个对象值可以修改）如 <code>int i = 0; int *const ptr = &amp;i;</code></li>
</ul>
<h4 id="顶层const">顶层const</h4>
<ul>
<li><code>顶层const</code>：指针本身是个常量。</li>
<li><code>底层const</code>：指针指向的对象是个常量。拷贝时严格要求相同的底层const资格。</li>
</ul>
<h4 id="constexpr和常量表达式（▲可选）"><code>constexpr</code>和常量表达式（▲可选）</h4>
<ul>
<li>常量表达式：指值不会改变，且在编译过程中就能得到计算结果的表达式。</li>
<li><code>C++11</code>新标准规定，允许将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量的表达式。</li>
</ul>
<h3 id="处理类型">处理类型</h3>
<h4 id="类型别名">类型别名</h4>
<ul>
<li>传统别名：使用<strong>typedef</strong>来定义类型的同义词。 <code>typedef double wages;</code></li>
<li>新标准别名：别名声明（alias declaration）： <code>using SI = Sales_item;</code>（C++11）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于复合类型（指针等）不能代回原式来进行理解</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;  <span class="comment">// pstring是char*的别名</span></span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">// 指向char的常量指针</span></span><br><span class="line"><span class="comment">// 如改写为const char *cstr = 0;不正确，为指向const char的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助理解（可代回后加括号）</span></span><br><span class="line"><span class="comment">// const pstring cstr = 0;代回后const (char *) cstr = 0;</span></span><br><span class="line"><span class="comment">// const char *cstr = 0;即为(const char *) cstr = 0;</span></span><br></pre></td></tr></table></figure>
<h4 id="auto类型说明符-c-11">auto类型说明符 c++11</h4>
<ul>
<li><strong>auto</strong>类型说明符：让编译器<strong>自动推断类型</strong>。</li>
<li>一条声明语句只能有一个数据类型，所以一个auto声明多个变量时只能相同的变量类型(包括复杂类型&amp;和*)。<code>auto sz = 0, pi =3.14//错误</code></li>
<li><code>int i = 0, &amp;r = i; auto a = r;</code> 推断<code>a</code>的类型是<code>int</code>。</li>
<li>会忽略<code>顶层const</code>。</li>
<li><code>const int ci = 1; const auto f = ci;</code>推断类型是<code>int</code>，如果希望是顶层const需要自己加<code>const</code></li>
</ul>
<h4 id="decltype类型指示符">decltype类型指示符</h4>
<ul>
<li>从表达式的类型推断出要定义的变量的类型。</li>
<li><strong>decltype</strong>：选择并返回操作数的<strong>数据类型</strong>。</li>
<li><code>decltype(f()) sum = x;</code> 推断<code>sum</code>的类型是函数<code>f</code>的返回类型。</li>
<li>不会忽略<code>顶层const</code>。</li>
<li>如果对变量加括号，编译器会将其认为是一个表达式，如int i–&gt;(i),则decltype((i))得到结果为int&amp;引用。</li>
<li>赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果 i 是 int，则表达式 i=x 的类型是 int&amp;。</li>
<li><code>C++11</code></li>
</ul>
<h3 id="自定义数据结构">自定义数据结构</h3>
<h4 id="struct">struct</h4>
<blockquote>
<p>尽量不要把类定义和对象定义放在一起。如<code>struct Student&#123;&#125; xiaoming,xiaofang;</code></p>
</blockquote>
<ul>
<li>类可以以关键字<code>struct</code>开始，紧跟类名和类体。</li>
<li>类数据成员：类体定义类的成员。</li>
<li><code>C++11</code>：可以为类数据成员提供一个<strong>类内初始值</strong>（in-class initializer）。</li>
</ul>
<h4 id="编写自己的头文件">编写自己的头文件</h4>
<ul>
<li>头文件通常包含哪些只能被定义一次的实体：类、<code>const</code>和<code>constexpr</code>变量。</li>
</ul>
<p>预处理器概述：</p>
<ul>
<li><strong>预处理器</strong>（preprocessor）：确保头文件多次包含仍能安全工作。</li>
<li>当预处理器看到<code>#include</code>标记时，会用指定的头文件内容代替<code>#include</code></li>
<li><strong>头文件保护符</strong>（header guard）：头文件保护符依赖于预处理变量的状态：已定义和未定义。
<ul>
<li><code>#ifdef</code>已定义时为真</li>
<li><code>#ifndef</code>未定义时为真</li>
<li>头文件保护符的名称需要唯一，且保持全部大写。养成良好习惯，不论是否该头文件被包含，要加保护符。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H  <span class="comment">//SALES_DATA_H未定义时为真</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H</span></span><br><span class="line">strct Sale_data&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="第2章-变量和基本类型">第2章 变量和基本类型</h2>
<h3 id="基本内置类型（Primitive-Built-in-Types）">基本内置类型（Primitive Built-in Types）</h3>
<h4 id="算数类型（Arithmetic-Types）">算数类型（Arithmetic Types）</h4>
<p>算数类型分为两类：整型（integral type）、浮点型（floating-point type）。</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031424213.png" alt="2-1" style="zoom: 67%;" />
<p><code>bool</code>类型的取值是<code>true</code>或<code>false</code>。</p>
<p>一个<code>char</code>的大小和一个机器字节一样，确保可以存放机器基本字符集中任意字符对应的数字值。<code>wchar_t</code>确保可以存放机器最大扩展字符集中的任意一个字符。</p>
<p>在整型类型大小方面，C++规定<code>short</code> ≤ <code>int</code> ≤ <code>long</code> ≤ <code>long long</code>（<code>long long</code>是C++11定义的类型）。</p>
<p>浮点型可表示单精度（single-precision）、双精度（double-precision）和扩展精度（extended-precision）值，分别对应<code>float</code>、<code>double</code>和<code>long double</code>类型。</p>
<p>除去布尔型和扩展字符型，其他整型可以分为带符号（signed）和无符号（unsigned）两种。带符号类型可以表示正数、负数和0，无符号类型只能表示大于等于0的数值。类型<code>int</code>、<code>short</code>、<code>long</code>和<code>long long</code>都是带符号的，在类型名前面添加<code>unsigned</code>可以得到对应的无符号类型，如<code>unsigned int</code>。</p>
<p>字符型分为<code>char</code>、<code>signed char</code>和<code>unsigned char</code>三种，但是表现形式只有带符号和无符号两种。类型<code>char</code>和<code>signed char</code>并不一样， <code>char</code>的具体形式由编译器（compiler）决定。</p>
<p>如何选择算数类型：</p>
<ul>
<li>
<p>当明确知晓数值不可能为负时，应该使用无符号类型。</p>
</li>
<li>
<p>使用<code>int</code>执行整数运算，如果数值超过了<code>int</code>的表示范围，应该使用<code>long long</code>类型。</p>
</li>
<li>
<p>在算数表达式中不要使用<code>char</code>和<code>bool</code>类型。如果需要使用一个不大的整数，应该明确指定它的类型是<code>signed char</code>还是<code>unsigned char</code>。</p>
</li>
<li>
<p>执行浮点数运算时建议使用<code>double</code>类型。</p>
</li>
</ul>
<h4 id="类型转换（Type-Conversions）">类型转换（Type Conversions）</h4>
<p>进行类型转换时，类型所能表示的值的范围决定了转换的过程。</p>
<ul>
<li>把非布尔类型的算术值赋给布尔类型时，初始值为0则结果为<code>false</code>，否则结果为<code>true</code>。</li>
<li>把布尔值赋给非布尔类型时，初始值为<code>false</code>则结果为0，初始值为<code>true</code>则结果为1。</li>
<li>把浮点数赋给整数类型时，进行近似处理，结果值仅保留浮点数中的整数部分。</li>
<li>把整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。</li>
<li>赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数（8比特大小的<code>unsigned char</code>能表示的数值总数是256）取模后的余数。</li>
<li>赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。</li>
</ul>
<p>避免无法预知和依赖于实现环境的行为。</p>
<p>无符号数不会小于0这一事实关系到循环的写法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WRONG: u can never be less than 0; the condition will always succeed</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> u = <span class="number">10</span>; u &gt;= <span class="number">0</span>; --u)</span><br><span class="line">    std::cout &lt;&lt; u &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>当<code>u</code>等于0时，<code>--u</code>的结果将会是4294967295。一种解决办法是用<code>while</code>语句来代替<code>for</code>语句，前者可以在输出变量前先减去1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> u = <span class="number">11</span>;    <span class="comment">// start the loop one past the first element we want to print</span></span><br><span class="line"><span class="keyword">while</span> (u &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    --u;    <span class="comment">// decrement first, so that the last iteration will print 0</span></span><br><span class="line">    std::cout &lt;&lt; u &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要混用带符号类型和无符号类型。</p>
<h4 id="字面值常量（Literals）">字面值常量（Literals）</h4>
<p>以<code>0</code>开头的整数代表八进制（octal）数，以<code>0x</code>或<code>0X</code>开头的整数代表十六进制（hexadecimal）数。在C++14中，<code>0b</code>或<code>0B</code>开头的整数代表二进制（binary）数。</p>
<p>整型字面值具体的数据类型由它的值和符号决定。</p>
<p>C++14新增了单引号<code>'</code>形式的数字分隔符。数字分隔符不会影响数字的值，但可以通过分隔符将数字分组，使数值读写更容易。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照书写形式，每3位分为一组</span></span><br><span class="line">std::cout &lt;&lt; <span class="number">0B</span>1<span class="number">&#x27;101</span>;   <span class="comment">// 输出&quot;13&quot;</span></span><br><span class="line">std::cout &lt;&lt; <span class="number">1&#x27;100&#x27;000</span>; <span class="comment">// 输出&quot;1100000&quot;</span></span><br></pre></td></tr></table></figure>
<p>浮点型字面值默认是一个<code>double</code>。</p>
<p>由单引号括起来的一个字符称为<code>char</code>型字面值，双引号括起来的零个或多个字符称为字符串字面值。</p>
<p>字符串字面值的类型是由常量字符构成的数组（array）。编译器在每个字符串的结尾处添加一个空字符<code>'\0'</code>，因此字符串字面值的实际长度要比它的内容多一位。</p>
<p>转义序列：</p>
<table>
<thead>
<tr>
<th style="text-align:center">含义</th>
<th style="text-align:center">转义字符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">newline</td>
<td style="text-align:center"><code>\n</code></td>
</tr>
<tr>
<td style="text-align:center">horizontal tab</td>
<td style="text-align:center"><code>\t</code></td>
</tr>
<tr>
<td style="text-align:center">alert (bell)</td>
<td style="text-align:center"><code>\a</code></td>
</tr>
<tr>
<td style="text-align:center">vertical tab</td>
<td style="text-align:center"><code>\v</code></td>
</tr>
<tr>
<td style="text-align:center">backspace</td>
<td style="text-align:center"><code>\b</code></td>
</tr>
<tr>
<td style="text-align:center">double quote</td>
<td style="text-align:center"><code>\&quot;</code></td>
</tr>
<tr>
<td style="text-align:center">backslash</td>
<td style="text-align:center"><code>\\</code></td>
</tr>
<tr>
<td style="text-align:center">question mark</td>
<td style="text-align:center"><code>\?</code></td>
</tr>
<tr>
<td style="text-align:center">single quote</td>
<td style="text-align:center"><code>\'</code></td>
</tr>
<tr>
<td style="text-align:center">carriage return</td>
<td style="text-align:center"><code>\r</code></td>
</tr>
<tr>
<td style="text-align:center">formfeed</td>
<td style="text-align:center"><code>\f</code></td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;      <span class="comment">// prints a newline</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;\tHi!\n&quot;</span>; <span class="comment">// prints a tab followd by &quot;Hi!&quot; and a newline</span></span><br></pre></td></tr></table></figure>
<p>泛化转义序列的形式是<code>\x</code>后紧跟1个或多个十六进制数字，或者<code>\</code>后紧跟1个、2个或3个八进制数字，其中数字部分表示字符对应的数值。如果<code>\</code>后面跟着的八进制数字超过3个，则只有前3个数字与<code>\</code>构成转义序列。相反，<code>\x</code>要用到后面跟着的所有数字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hi \x4dO\115!\n&quot;</span>; <span class="comment">// prints Hi MOM! followed by a newline</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&#x27;\115&#x27;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    <span class="comment">// prints M followed by a newline</span></span><br></pre></td></tr></table></figure>
<p>添加特定的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。</p>
<p>![2-2](C:\Users\SEUGarfield\Desktop\Cpp-Primer-5th-Notes-CN-master\Chapter-2 Variables and Basic Types\Images\2-2.png)</p>
<p>使用一个长整型字面值时，最好使用大写字母<code>L</code>进行标记，小写字母<code>l</code>和数字<code>1</code>容易混淆。</p>
<h3 id="变量（Variables）">变量（Variables）</h3>
<h4 id="变量定义（Variable-Definitions）">变量定义（Variable Definitions）</h4>
<p>变量定义的基本形式：类型说明符（type specifier）后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。定义时可以为一个或多个变量赋初始值（初始化，initialization）。</p>
<p>初始化不等于赋值（assignment）。初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，再用一个新值来替代。</p>
<p>用花括号初始化变量称为列表初始化（list initialization）。当用于内置类型的变量时，如果使用了列表初始化并且初始值存在丢失信息的风险，则编译器会报错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld = <span class="number">3.1415926536</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;ld&#125;, b = &#123;ld&#125;;    <span class="comment">// error: narrowing conversion required</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(ld)</span>, d </span>= ld;      <span class="comment">// ok: but value will be truncated</span></span><br></pre></td></tr></table></figure>
<p>如果定义变量时未指定初值，则变量被默认初始化（default initialized）。</p>
<p>对于内置类型，定义于任何函数体之外的变量被初始化为0，函数体内部的变量将不被初始化（uninitialized）。</p>
<p>定义于函数体内的内置类型对象如果没有初始化，则其值未定义，使用该类值是一种错误的编程行为且很难调试。类的对象如果没有显式初始化，则其值由类确定。</p>
<p>建议初始化每一个内置类型的变量。</p>
<h4 id="变量声明和定义的关系（Variable-Declarations-and-Definitions）">变量声明和定义的关系（Variable Declarations and Definitions）</h4>
<p>声明（declaration）使得名字为程序所知。一个文件如果想使用其他地方定义的名字，则必须先包含对那个名字的声明。</p>
<p>定义（definition）负责创建与名字相关联的实体。</p>
<p>如果想声明一个变量而不定义它，就在变量名前添加关键字<code>extern</code>，并且不要显式地初始化变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">// declares but does not define i</span></span><br><span class="line"><span class="keyword">int</span> j;      <span class="comment">// declares and defines j</span></span><br></pre></td></tr></table></figure>
<p><code>extern</code>语句如果包含了初始值就不再是声明了，而变成了定义。</p>
<p>变量能且只能被定义一次，但是可以被声明多次。</p>
<p>如果要在多个文件中使用同一个变量，就必须将声明和定义分开。此时变量的定义必须出现且只能出现在一个文件中，其他使用该变量的文件必须对其进行声明，但绝对不能重复定义。</p>
<h4 id="标识符（Identifiers）">标识符（Identifiers）</h4>
<p>C++的标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。C++为标准库保留了一些名字。用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外，定义在函数体外的标识符不能以下划线开头。</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031424222.png" alt="2-3" style="zoom:67%;" />
<h4 id="名字的作用域（Scope-of-a-Name）">名字的作用域（Scope of a Name）</h4>
<p>定义在函数体之外的名字拥有全局作用域（global scope）。声明之后，该名字在整个程序范围内都可使用。</p>
<p>最好在第一次使用变量时再去定义它。这样做更容易找到变量的定义位置，并且也可以赋给它一个比较合理的初始值。</p>
<p>作用域中一旦声明了某个名字，在它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字，此时内层作用域中新定义的名字将屏蔽外层作用域的名字。</p>
<p>可以用作用域操作符<code>::</code>来覆盖默认的作用域规则。因为全局作用域本身并没有名字，所以当作用域操作符的左侧为空时，会向全局作用域发出请求获取作用域操作符右侧名字对应的变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// Program for illustration purposes only: It is bad style for a function</span></span><br><span class="line"><span class="comment">// to use a global variable and also define a local variable with the same name</span></span><br><span class="line"><span class="keyword">int</span> reused = <span class="number">42</span>;    <span class="comment">// reused has global scope</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> unique = <span class="number">0</span>; <span class="comment">// unique has block scope</span></span><br><span class="line">    <span class="comment">// output #1: uses global reused; prints 42 0</span></span><br><span class="line">    std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">int</span> reused = <span class="number">0</span>; <span class="comment">// new, local object named reused hides global reused</span></span><br><span class="line">    <span class="comment">// output #2: uses local reused; prints 0 0</span></span><br><span class="line">    std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// output #3: explicitly requests the global reused; prints 42 0</span></span><br><span class="line">    std::cout &lt;&lt; ::reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数有可能用到某个全局变量，则不宜再定义一个同名的局部变量。</p>
<h3 id="复合类型（Compound-Type）">复合类型（Compound Type）</h3>
<h4 id="引用（References）">引用（References）</h4>
<p>引用为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将声明符写成<code>&amp;d</code>的形式来定义引用类型，其中<code>d</code>是变量名称。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival; <span class="comment">// refVal refers to (is another name for) ival</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal2;       <span class="comment">// error: a reference must be initialized</span></span><br></pre></td></tr></table></figure>
<p>定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，将无法再令引用重新绑定到另一个对象，因此引用必须初始化。</p>
<p>引用不是对象，它只是为一个已经存在的对象所起的另外一个名字。</p>
<p>声明语句中引用的类型实际上被用于指定它所绑定的对象类型。大部分情况下，引用的类型要和与之绑定的对象严格匹配。</p>
<p>引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起。</p>
<h4 id="指针（Pointer）">指针（Pointer）</h4>
<p>与引用类似，指针也实现了对其他对象的间接访问。</p>
<ul>
<li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在生命周期内它可以先后指向不同的对象。</li>
<li>指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</li>
</ul>
<p>通过将声明符写成<code>*d</code>的形式来定义指针类型，其中<code>d</code>是变量名称。如果在一条语句中定义了多个指针变量，则每个量前都必须有符号<code>*</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip1, *ip2;     <span class="comment">// both ip1 and ip2 are pointers to int</span></span><br><span class="line"><span class="keyword">double</span> dp, *dp2;    <span class="comment">// dp2 is a pointer to double; dp is a double</span></span><br></pre></td></tr></table></figure>
<p>指针存放某个对象的地址，要想获取对象的地址，需要使用取地址符<code>&amp;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ival; <span class="comment">// p holds the address of ival; p is a pointer to ival</span></span><br></pre></td></tr></table></figure>
<p>因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p>
<p>声明语句中指针的类型实际上被用于指定它所指向的对象类型。大部分情况下，指针的类型要和它指向的对象严格匹配。</p>
<p>指针的值（即地址）应属于下列状态之一：</p>
<ul>
<li>指向一个对象。</li>
<li>指向紧邻对象所占空间的下一个位置。</li>
<li>空指针，即指针没有指向任何对象。</li>
<li>无效指针，即上述情况之外的其他值。</li>
</ul>
<p>试图拷贝或以其他方式访问无效指针的值都会引发错误。</p>
<p>如果指针指向一个对象，可以使用解引用（dereference）符<code>*</code>来访问该对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ival; <span class="comment">// p holds the address of ival; p is a pointer to ival</span></span><br><span class="line">cout &lt;&lt; *p;     <span class="comment">// * yields the object to which p points; prints 42</span></span><br></pre></td></tr></table></figure>
<p>给解引用的结果赋值就是给指针所指向的对象赋值。</p>
<p>解引用操作仅适用于那些确实指向了某个对象的有效指针。</p>
<p>空指针（null pointer）不指向任何对象，在试图使用一个指针前代码可以先检查它是否为空。得到空指针最直接的办法是用字面值<code>nullptr</code>来初始化指针。</p>
<p>旧版本程序通常使用<code>NULL</code>（预处理变量，定义于头文件<code>cstdlib</code>中，值为0）给指针赋值，但在C++11中，最好使用<code>nullptr</code>初始化空指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;  <span class="comment">// equivalent to int *p1 = 0;</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;        <span class="comment">// directly initializes p2 from the literal constant 0</span></span><br><span class="line"><span class="comment">// must #include cstdlib</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>;     <span class="comment">// equivalent to int *p3 = 0;</span></span><br></pre></td></tr></table></figure>
<p>建议初始化所有指针。</p>
<p><code>void*</code>是一种特殊的指针类型，可以存放任意对象的地址，但不能直接操作<code>void*</code>指针所指的对象。</p>
<h4 id="理解复合类型的声明（Understanding-Compound-Type-Declarations）">理解复合类型的声明（Understanding Compound Type Declarations）</h4>
<p>指向指针的指针（Pointers to Pointers）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;ival;    <span class="comment">// pi points to an int</span></span><br><span class="line"><span class="keyword">int</span> **ppi = &amp;pi;    <span class="comment">// ppi points to a pointer to an int</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031424223.png" alt="2-4"></p>
<p>指向指针的引用（References to Pointers）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;         <span class="comment">// p is a pointer to int</span></span><br><span class="line"><span class="keyword">int</span> *&amp;r = p;    <span class="comment">// r is a reference to the pointer p</span></span><br><span class="line">r = &amp;i;         <span class="comment">// r refers to a pointer; assigning &amp;i to r makes p point to i</span></span><br><span class="line">*r = <span class="number">0</span>;         <span class="comment">// dereferencing r yields i, the object to which p points; changes i to 0</span></span><br></pre></td></tr></table></figure>
<p>面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清它的真实含义。</p>
<h3 id="const限定符（Const-Qualifier）">const限定符（Const Qualifier）</h3>
<p>在变量类型前添加关键字<code>const</code>可以创建值不能被改变的对象。<code>const</code>变量必须被初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="number">512</span>;    <span class="comment">// input buffer size</span></span><br><span class="line">bufSize = <span class="number">512</span>;      <span class="comment">// error: attempt to write to const object</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>const</code>对象被设定成仅在文件内有效。当多个文件中出现了同名的<code>const</code>变量时，其实等同于在不同文件中分别定义了独立的变量。</p>
<p>如果想在多个文件间共享<code>const</code>对象：</p>
<ul>
<li>
<p>若<code>const</code>对象的值在编译时已经确定，则应该定义在头文件中。其他源文件包含该头文件时，不会产生重复定义错误。</p>
</li>
<li>
<p>若<code>const</code>对象的值直到运行时才能确定，则应该在头文件中声明，在源文件中定义。此时<code>const</code>变量的声明和定义前都应该添加<code>extern</code>关键字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_1.cc defines and initializes a const that is accessible to other files</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="built_in">fcn</span>();</span><br><span class="line"><span class="comment">// file_1.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize;   <span class="comment">// same bufSize as defined in file_1.cc</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="const的引用（References-to-const）">const的引用（References to const）</h4>
<p>把引用绑定在<code>const</code>对象上即为对常量的引用（reference to const）。对常量的引用不能被用作修改它所绑定的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci;     <span class="comment">// ok: both reference and underlying object are const</span></span><br><span class="line">r1 = <span class="number">42</span>;        <span class="comment">// error: r1 is a reference to const</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci;   <span class="comment">// error: non const reference to a const object</span></span><br></pre></td></tr></table></figure>
<p>大部分情况下，引用的类型要和与之绑定的对象严格匹配。但是有两个例外：</p>
<ul>
<li>
<p>初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;      <span class="comment">// we can bind a const int&amp; to a plain int object</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;     <span class="comment">// ok: r1 is a reference to const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1 * <span class="number">2</span>;     <span class="comment">// ok: r3 is a reference to const</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r * <span class="number">2</span>;        <span class="comment">// error: r4 is a plain, non const reference</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>允许为一个常量引用绑定非常量的对象、字面值或者一般表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="指针和const（Pointers-and-const）">指针和const（Pointers and const）</h4>
<p>指向常量的指针（pointer to const）不能用于修改其所指向的对象。常量对象的地址只能使用指向常量的指针来存放，但是指向常量的指针可以指向一个非常量对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;     <span class="comment">// pi is const; its value may not be changed</span></span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi;          <span class="comment">// error: ptr is a plain pointer</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;   <span class="comment">// ok: cptr may point to a double that is const</span></span><br><span class="line">*cptr = <span class="number">42</span>;         <span class="comment">// error: cannot assign to *cptr</span></span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>; <span class="comment">// dval is a double; its value can be changed</span></span><br><span class="line">cptr = &amp;dval;       <span class="comment">// ok: but can&#x27;t change dval through cptr</span></span><br></pre></td></tr></table></figure>
<p>定义语句中把<code>*</code>放在<code>const</code>之前用来说明指针本身是一个常量，常量指针（const pointer）必须初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb;   <span class="comment">// curErr will always point to errNumb</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi;  <span class="comment">// pip is a const pointer to a const object</span></span><br></pre></td></tr></table></figure>
<p>指针本身是常量并不代表不能通过指针修改其所指向的对象的值，能否这样做完全依赖于其指向对象的类型。</p>
<h4 id="顶层const（Top-Level-const）">顶层const（Top-Level const）</h4>
<p>顶层<code>const</code>表示指针本身是个常量，底层<code>const</code>（low-level const）表示指针所指的对象是一个常量。指针类型既可以是顶层<code>const</code>也可以是底层<code>const</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;     <span class="comment">// we can&#x27;t change the value of p1; const is top-level</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;      <span class="comment">// we cannot change ci; const is top-level</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;    <span class="comment">// we can change p2; const is low-level</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2; <span class="comment">// right-most const is top-level, left-most is not</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = ci;      <span class="comment">// const in reference types is always low-level</span></span><br></pre></td></tr></table></figure>
<p>当执行拷贝操作时，常量是顶层<code>const</code>还是底层<code>const</code>区别明显：</p>
<ul>
<li>
<p>顶层<code>const</code>没有影响。拷贝操作不会改变被拷贝对象的值，因此拷入和拷出的对象是否是常量无关紧要。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ci;     <span class="comment">// ok: copying the value of ci; top-level const in ci is ignored</span></span><br><span class="line">p2 = p3;    <span class="comment">// ok: pointed-to type matches; top-level const in p3 is ignored</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>拷入和拷出的对象必须具有相同的底层<code>const</code>资格。或者两个对象的数据类型可以相互转换。一般来说，非常量可以转换成常量，反之则不行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = p3;    <span class="comment">// error: p3 has a low-level const but p doesn&#x27;t</span></span><br><span class="line">p2 = p3;        <span class="comment">// ok: p2 has the same low-level const qualification as p3</span></span><br><span class="line">p2 = &amp;i;        <span class="comment">// ok: we can convert int* to const int*</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = ci;    <span class="comment">// error: can&#x27;t bind an ordinary int&amp; to a const int object</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;  <span class="comment">// ok: can bind const int&amp; to plain int</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="constexpr和常量表达式（constexpr-and-Constant-Expressions）">constexpr和常量表达式（constexpr and Constant Expressions）</h4>
<p>常量表达式（constant expressions）指值不会改变并且在编译过程就能得到计算结果的表达式。</p>
<p>一个对象是否为常量表达式由它的数据类型和初始值共同决定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_files = <span class="number">20</span>;           <span class="comment">// max_files is a constant expression</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> limit = max_files + <span class="number">1</span>;    <span class="comment">// limit is a constant expression</span></span><br><span class="line"><span class="keyword">int</span> staff_size = <span class="number">27</span>;        <span class="comment">// staff_size is not a constant expression</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = <span class="built_in">get_size</span>();  <span class="comment">// sz is not a constant expression</span></span><br></pre></td></tr></table></figure>
<p>C++11允许将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>;          <span class="comment">// 20 is a constant expression</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> limit = mf + <span class="number">1</span>;   <span class="comment">// mf + 1 is a constant expression</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = <span class="built_in">size</span>();      <span class="comment">// ok only if size is a constexpr function</span></span><br></pre></td></tr></table></figure>
<p>指针和引用都能定义成<code>constexpr</code>，但是初始值受到严格限制。<code>constexpr</code>指针的初始值必须是0、<code>nullptr</code>或者是存储在某个固定地址中的对象。</p>
<p>函数体内定义的普通变量一般并非存放在固定地址中，因此<code>constexpr</code>指针不能指向这样的变量。相反，函数体外定义的变量地址固定不变，可以用来初始化<code>constexpr</code>指针。</p>
<p>在<code>constexpr</code>声明中如果定义了一个指针，限定符<code>constexpr</code>仅对指针本身有效，与指针所指的对象无关。<code>constexpr</code>把它所定义的对象置为了顶层<code>const</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;     <span class="comment">// p是指向int的const指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *cp = &amp;i;   <span class="comment">// cp是指向const int的const指针</span></span><br></pre></td></tr></table></figure>
<p><code>const</code>和<code>constexpr</code>限定的值都是常量。但<code>constexpr</code>对象的值必须在编译期间确定，而<code>const</code>对象的值可以延迟到运行期间确定。</p>
<p>建议使用<code>constexpr</code>修饰表示数组大小的对象，因为数组的大小必须在编译期间确定且不能改变。</p>
<h3 id="处理类型（Dealing-with-Types）">处理类型（Dealing with Types）</h3>
<h4 id="类型别名（Type-Aliases）">类型别名（Type Aliases）</h4>
<p>类型别名是某种类型的同义词，传统方法是使用关键字<code>typedef</code>定义类型别名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;   <span class="comment">// wages is a synonym for double</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">// base is a synonym for double, p for double*</span></span><br></pre></td></tr></table></figure>
<p>C++11使用关键字<code>using</code>进行别名声明（alias declaration），作用是把等号左侧的名字规定成等号右侧类型的别名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">// SI is a synonym for Sales_item</span></span><br></pre></td></tr></table></figure>
<h4 id="auto类型说明符（The-auto-Type-Specifier）">auto类型说明符（The auto Type Specifier）</h4>
<p>C++11新增<code>auto</code>类型说明符，能让编译器自动分析表达式所属的类型。<code>auto</code>定义的变量必须有初始值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the type of item is deduced from the type of the result of adding val1 and val2</span></span><br><span class="line"><span class="keyword">auto</span> item = val1 + val2;    <span class="comment">// item initialized to the result of val1 + val2</span></span><br></pre></td></tr></table></figure>
<p>编译器推断出来的<code>auto</code>类型有时和初始值的类型并不完全一样。</p>
<ul>
<li>
<p>当引用被用作初始值时，编译器以引用对象的类型作为<code>auto</code>的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r;     <span class="comment">// a is an int (r is an alias for i, which has type int)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>auto</code>一般会忽略顶层<code>const</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;    <span class="comment">// b is an int (top-level const in ci is dropped)</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;    <span class="comment">// c is an int (cr is an alias for ci whose const is top-level)</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;    <span class="comment">// d is an int*(&amp; of an int object is int*)</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;   <span class="comment">// e is const int*(&amp; of a const object is low-level const)</span></span><br></pre></td></tr></table></figure>
<p>如果希望推断出的<code>auto</code>类型是一个顶层<code>const</code>，需要显式指定<code>const auto</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f = ci;  <span class="comment">// deduced type of ci is int; f has type const int</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>设置类型为<code>auto</code>的引用时，原来的初始化规则仍然适用，初始值中的顶层常量属性仍然保留。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;g = ci;   <span class="comment">// g is a const int&amp; that is bound to ci</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h = <span class="number">42</span>;   <span class="comment">// error: we can&#x27;t bind a plain reference to a literal</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">42</span>;     <span class="comment">// ok: we can bind a const reference to a literal</span></span><br></pre></td></tr></table></figure>
<h4 id="decltype类型指示符（The-decltype-Type-Specifier）">decltype类型指示符（The decltype Type Specifier）</h4>
<p>C++11新增<code>decltype</code>类型指示符，作用是选择并返回操作数的数据类型，此过程中编译器不实际计算表达式的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x;  <span class="comment">// sum has whatever type f returns</span></span><br></pre></td></tr></table></figure>
<p><code>decltype</code>处理顶层<code>const</code>和引用的方式与<code>auto</code>有些不同，如果<code>decltype</code>使用的表达式是一个变量，则<code>decltype</code>返回该变量的类型（包括顶层<code>const</code>和引用）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;     <span class="comment">// x has type const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;     <span class="comment">// y has type const int&amp; and is bound to x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;     <span class="comment">// error: z is a reference and must be initialized</span></span><br></pre></td></tr></table></figure>
<p>如果<code>decltype</code>使用的表达式不是一个变量，则<code>decltype</code>返回表达式结果对应的类型。如果表达式的内容是解引用操作，则<code>decltype</code>将得到引用类型。如果<code>decltype</code>使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则<code>decltype</code>会得到引用类型，因为变量是一种可以作为赋值语句左值的特殊表达式。</p>
<p><code>decltype((var))</code>的结果永远是引用，而<code>decltype(var)</code>的结果只有当<code>var</code>本身是一个引用时才会是引用。</p>
<h3 id="自定义数据结构（Defining-Our-Own-Data-Structures）">自定义数据结构（Defining Our Own Data Structures）</h3>
<p>C++11规定可以为类的数据成员（data member）提供一个类内初始值（in-class initializer）。创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化。</p>
<p>类内初始值不能使用圆括号。</p>
<p>类定义的最后应该加上分号。</p>
<p>头文件（header file）通常包含那些只能被定义一次的实体，如类、<code>const</code>和<code>constexpr</code>变量。</p>
<p>头文件一旦改变，相关的源文件必须重新编译以获取更新之后的声明。</p>
<p>头文件保护符（header guard）依赖于预处理变量（preprocessor variable）。预处理变量有两种状态：已定义和未定义。<code>#define</code>指令把一个名字设定为预处理变量。<code>#ifdef</code>指令当且仅当变量已定义时为真，<code>#ifndef</code>指令当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到<code>#endif</code>指令为止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在高级版本的IDE环境中，可以直接使用<code>#pragma once</code>命令来防止头文件的重复包含。</p>
<p>预处理变量无视C++语言中关于作用域的规则。</p>
<p>整个程序中的预处理变量，包括头文件保护符必须唯一。预处理变量的名字一般均为大写。</p>
<p>头文件即使目前还没有被包含在任何其他头文件中，也应该设置保护符。</p>
<hr>
<h2 id="第3章-字符串、向量和数组-简">第3章 字符串、向量和数组(简)</h2>
<h3 id="using声明">using声明</h3>
<ul>
<li>使用某个命名空间：例如 <code>using std::cin</code>表示使用命名空间<code>std</code>中的名字<code>cin</code>。</li>
<li>头文件中不应该包含<code>using</code>声明。这样使用了该头文件的源码也会使用这个声明，会带来风险。</li>
</ul>
<h3 id="string">string</h3>
<ul>
<li>标准库类型<code>string</code>表示可变长的字符序列。</li>
<li><code>#include &lt;string&gt;</code>，然后 <code>using std::string;</code></li>
<li><strong>string对象</strong>：注意，不同于字符串字面值。</li>
</ul>
<h4 id="定义和初始化string对象">定义和初始化string对象</h4>
<p>初始化<code>string</code>对象的方式：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>string s1</code></td>
<td>默认初始化，<code>s1</code>是个空字符串</td>
</tr>
<tr>
<td><code>string s2(s1)</code></td>
<td><code>s2</code>是<code>s1</code>的副本</td>
</tr>
<tr>
<td><code>string s2 = s1</code></td>
<td>等价于<code>s2(s1)</code>，<code>s2</code>是<code>s1</code>的副本</td>
</tr>
<tr>
<td><code>string s3(&quot;value&quot;)</code></td>
<td><code>s3</code>是字面值“value”的副本，除了字面值最后的那个空字符外</td>
</tr>
<tr>
<td><code>string s3 = &quot;value&quot;</code></td>
<td>等价于<code>s3(&quot;value&quot;)</code>，<code>s3</code>是字面值&quot;value&quot;的副本</td>
</tr>
<tr>
<td><code>string s4(n, 'c')</code></td>
<td>把<code>s4</code>初始化为由连续<code>n</code>个字符<code>c</code>组成的串</td>
</tr>
</tbody>
</table>
<ul>
<li>拷贝初始化（copy initialization）：使用等号<code>=</code>将一个已有的对象拷贝到正在创建的对象。</li>
<li>直接初始化（direct initialization）：通过括号给对象赋值。</li>
</ul>
<h4 id="string对象上的操作">string对象上的操作</h4>
<p><code>string</code>的操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>os &lt;&lt; s</code></td>
<td>将<code>s</code>写到输出流<code>os</code>当中，返回<code>os</code></td>
</tr>
<tr>
<td><code>is &gt;&gt; s</code></td>
<td>从<code>is</code>中读取字符串赋给<code>s</code>，字符串以空白分割，返回<code>is</code></td>
</tr>
<tr>
<td><code>getline(is, s)</code></td>
<td>从<code>is</code>中读取一行赋给<code>s</code>，返回<code>is</code></td>
</tr>
<tr>
<td><code>s.empty()</code></td>
<td><code>s</code>为空返回<code>true</code>，否则返回<code>false</code></td>
</tr>
<tr>
<td><code>s.size()</code></td>
<td>返回<code>s</code>中字符的个数</td>
</tr>
<tr>
<td><code>s[n]</code></td>
<td>返回<code>s</code>中第<code>n</code>个字符的引用，位置<code>n</code>从0计起</td>
</tr>
<tr>
<td><code>s1+s2</code></td>
<td>返回<code>s1</code>和<code>s2</code>连接后的结果</td>
</tr>
<tr>
<td><code>s1=s2</code></td>
<td>用<code>s2</code>的副本代替<code>s1</code>中原来的字符</td>
</tr>
<tr>
<td><code>s1==s2</code></td>
<td>如果<code>s1</code>和<code>s2</code>中所含的字符完全一样，则它们相等；<code>string</code>对象的相等性判断对字母的大小写敏感</td>
</tr>
<tr>
<td><code>s1!=s2</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></td>
<td>利用字符在字典中的顺序进行比较，且对字母的大小写敏感（对第一个不相同的位置进行比较）</td>
</tr>
</tbody>
</table>
<ul>
<li>string io：
<ul>
<li>执行读操作<code>&gt;&gt;</code>：忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止。</li>
<li><code>getline</code>：读取一整行，<strong>包括空白符</strong>。</li>
</ul>
</li>
<li><code>s.size()</code>返回的时<code>string::size_type</code>类型，记住是一个<strong>无符号</strong>类型的值，不要和<code>int</code>混用</li>
<li><code>s1+s2</code>使用时，保证至少一侧是string类型。<code>string s1 = &quot;hello&quot; + &quot;world&quot; // 错误，两侧均为字符串字面值</code></li>
<li><strong>字符串字面值和string是不同的类型。</strong></li>
</ul>
<h4 id="处理string对象中的字符">处理string对象中的字符</h4>
<ul>
<li>
<p><strong>ctype.h vs. cctype</strong>：C++修改了c的标准库，名称为去掉<code>.h</code>，前面加<code>c</code>。</p>
<blockquote>
<p>如c++版本为<code>cctype</code>，c版本为<code>ctype.h</code></p>
</blockquote>
<ul>
<li><strong>尽量使用c++版本的头文件</strong>，即<code>cctype</code></li>
</ul>
</li>
</ul>
<p><code>cctype</code>头文件中定义了一组标准函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isalnum(c)</code></td>
<td>当<code>c</code>是字母或数字时为真</td>
</tr>
<tr>
<td><code>isalpha(c)</code></td>
<td>当<code>c</code>是字母时为真</td>
</tr>
<tr>
<td><code>iscntrl(c)</code></td>
<td>当<code>c</code>是控制字符时为真</td>
</tr>
<tr>
<td><code>isdigit(c)</code></td>
<td>当<code>c</code>是数字时为真</td>
</tr>
<tr>
<td><code>isgraph(c)</code></td>
<td>当<code>c</code>不是空格但可以打印时为真</td>
</tr>
<tr>
<td><code>islower(c)</code></td>
<td>当<code>c</code>是小写字母时为真</td>
</tr>
<tr>
<td><code>isprint(c)</code></td>
<td>当<code>c</code>是可打印字符时为真</td>
</tr>
<tr>
<td><code>ispunct(c)</code></td>
<td>当<code>c</code>是标点符号时为真</td>
</tr>
<tr>
<td><code>isspace(c)</code></td>
<td>当<code>c</code>是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符）</td>
</tr>
<tr>
<td><code>isupper(c)</code></td>
<td>当<code>c</code>是大写字母时为真</td>
</tr>
<tr>
<td><code>isxdigit(c)</code></td>
<td>当<code>c</code>是十六进制数字时为真</td>
</tr>
<tr>
<td><code>tolower(c)</code></td>
<td>当<code>c</code>是大写字母，输出对应的小写字母；否则原样输出<code>c</code></td>
</tr>
<tr>
<td><code>toupper(c)</code></td>
<td>当<code>c</code>是小写字母，输出对应的大写字母；否则原样输出<code>c</code></td>
</tr>
</tbody>
</table>
<ul>
<li>遍历字符串：使用<strong>范围for</strong>（range for）语句： <code>for (auto c: str)</code>，或者 <code>for (auto &amp;c: str)</code>使用引用直接改变字符串中的字符。 （C++11）</li>
<li><code>str[x]</code>,[]输入参数为<code>string::size_type</code>类型，给出<code>int</code>整型也会自动转化为该类型</li>
</ul>
<h3 id="vector">vector</h3>
<ul>
<li>vector是一个<strong>容器</strong>，也是一个类模板；</li>
<li><code>#include &lt;vector&gt;</code> 然后 <code>using std::vector;</code></li>
<li>容器：包含其他对象。</li>
<li>类模板：本身不是类，但可以<strong>实例化instantiation</strong>出一个类。 <code>vector</code>是一个模板， <code>vector&lt;int&gt;</code>是一个类型。</li>
<li>通过将类型放在类模板名称后面的<strong>尖括号</strong>中来指定<strong>类型</strong>，如<code>vector&lt;int&gt; ivec</code>。</li>
</ul>
<h4 id="定义和初始化vector对象">定义和初始化vector对象</h4>
<p>初始化<code>vector</code>对象的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vector&lt;T&gt; v1</code></td>
<td><code>v1</code>是一个空<code>vector</code>，它潜在的元素是<code>T</code>类型的，执行默认初始化</td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v2(v1)</code></td>
<td><code>v2</code>中包含有<code>v1</code>所有元素的副本</td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v2 = v1</code></td>
<td>等价于<code>v2(v1)</code>，<code>v2</code>中包含<code>v1</code>所有元素的副本</td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v3(n, val)</code></td>
<td><code>v3</code>包含了n个重复的元素，每个元素的值都是<code>val</code></td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v4(n)</code></td>
<td><code>v4</code>包含了n个重复地执行了值初始化的对象</td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v5&#123;a, b, c...&#125;</code></td>
<td><code>v5</code>包含了初始值个数的元素，每个元素被赋予相应的初始值</td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v5=&#123;a, b, c...&#125;</code></td>
<td>等价于<code>v5&#123;a, b, c...&#125;</code></td>
</tr>
</tbody>
</table>
<ul>
<li>列表初始化： <code>vector&lt;string&gt; v&#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;;</code> （C++11）</li>
</ul>
<h4 id="向vector对象中添加元素">向vector对象中添加元素</h4>
<ul>
<li><code>v.push_back(e)</code> 在尾部增加元素。</li>
</ul>
<h4 id="其他vector操作">其他vector操作</h4>
<p><code>vector</code>支持的操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>v.emtpy()</code></td>
<td>如果<code>v</code>不含有任何元素，返回真；否则返回假</td>
</tr>
<tr>
<td><code>v.size()</code></td>
<td>返回<code>v</code>中元素的个数</td>
</tr>
<tr>
<td><code>v.push_back(t)</code></td>
<td>向<code>v</code>的尾端添加一个值为<code>t</code>的元素</td>
</tr>
<tr>
<td><code>v[n]</code></td>
<td>返回<code>v</code>中第<code>n</code>个位置上元素的<strong>引用</strong></td>
</tr>
<tr>
<td><code>v1 = v2</code></td>
<td>用<code>v2</code>中的元素拷贝替换<code>v1</code>中的元素</td>
</tr>
<tr>
<td><code>v1 = &#123;a,b,c...&#125;</code></td>
<td>用列表中元素的拷贝替换<code>v1</code>中的元素</td>
</tr>
<tr>
<td><code>v1 == v2</code></td>
<td><code>v1</code>和<code>v2</code>相等当且仅当它们的元素数量相同且对应位置的元素值都相同</td>
</tr>
<tr>
<td><code>v1 != v2</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>, <code>&gt;=</code></td>
<td>以字典顺序进行比较</td>
</tr>
</tbody>
</table>
<ul>
<li>范围<code>for</code>语句内不应该改变其遍历序列的大小。</li>
<li><code>vector</code>对象（以及<code>string</code>对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素。</li>
</ul>
<h3 id="迭代器iterator">迭代器iterator</h3>
<ul>
<li>所有标准库容器都可以使用迭代器。</li>
<li>类似于指针类型，迭代器也提供了对对象的间接访问。</li>
</ul>
<h4 id="使用迭代器">使用迭代器</h4>
<ul>
<li><code>vector&lt;int&gt;::iterator iter</code>。</li>
<li><code>auto b = v.begin();</code>返回指向第一个元素的迭代器。</li>
<li><code>auto e = v.end();</code>返回指向最后一个元素的下一个（哨兵，尾后,one past the end）的迭代器（off the end）。</li>
<li>如果容器为空， <code>begin()</code>和 <code>end()</code>返回的是同一个迭代器，都是尾后迭代器。</li>
<li>使用解引用符<code>*</code>访问迭代器指向的元素。</li>
<li>养成使用迭代器和<code>!=</code>的习惯（泛型编程）。</li>
<li><strong>容器</strong>：可以包含其他对象；但所有的对象必须类型相同。</li>
<li><strong>迭代器（iterator）</strong>：每种标准容器都有自己的迭代器。<code>C++</code>倾向于用迭代器而不是下标遍历元素。</li>
<li><strong>const_iterator</strong>：只能读取容器内元素不能改变。</li>
<li><strong>箭头运算符</strong>： 解引用 + 成员访问，<code>it-&gt;mem</code>等价于 <code>(*it).mem</code></li>
<li><strong>谨记</strong>：但凡是使用了<strong>迭代器</strong>的循环体，都<strong>不要</strong>向迭代器所属的容器<strong>添加元素</strong>。</li>
</ul>
<p>标准容器迭代器的运算符:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*iter</code></td>
<td>返回迭代器<code>iter</code>所指向的<strong>元素的引用</strong></td>
</tr>
<tr>
<td><code>iter-&gt;mem</code></td>
<td>等价于<code>(*iter).mem</code></td>
</tr>
<tr>
<td><code>++iter</code></td>
<td>令<code>iter</code>指示容器中的下一个元素</td>
</tr>
<tr>
<td><code>--iter</code></td>
<td>令<code>iter</code>指示容器中的上一个元素</td>
</tr>
<tr>
<td><code>iter1 == iter2</code></td>
<td>判断两个迭代器是否相等</td>
</tr>
</tbody>
</table>
<h4 id="迭代器运算">迭代器运算</h4>
<p><code>vector</code>和<code>string</code>迭代器支持的运算：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>iter + n</code></td>
<td>迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。</td>
</tr>
<tr>
<td><code>iter - n</code></td>
<td>迭代器减去一个证书仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。</td>
</tr>
<tr>
<td><code>iter1 += n</code></td>
<td>迭代器加法的复合赋值语句，将<code>iter1</code>加n的结果赋给<code>iter1</code></td>
</tr>
<tr>
<td><code>iter1 -= n</code></td>
<td>迭代器减法的复合赋值语句，将<code>iter2</code>减n的加过赋给<code>iter1</code></td>
</tr>
<tr>
<td><code>iter1 - iter2</code></td>
<td>两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。</td>
</tr>
<tr>
<td><code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code></td>
<td>迭代器的关系运算符，如果某迭代器</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>difference_type</strong>：保证足够大以存储任何两个迭代器对象间的距离，可正可负。</li>
</ul>
<h3 id="数组">数组</h3>
<ul>
<li>相当于vector的低级版，<strong>长度固定</strong>。</li>
</ul>
<h4 id="定义和初始化内置数组">定义和初始化内置数组</h4>
<ul>
<li>初始化：<code>char input_buffer[buffer_size];</code>，长度必须是const表达式，或者不写，让编译器自己推断。</li>
<li>数组不允许直接赋值给另一个数组。</li>
</ul>
<h4 id="访问数组元素">访问数组元素</h4>
<ul>
<li>数组下标的类型：<code>size_t</code> 。</li>
<li>字符数组的特殊性：结尾处有一个空字符，如 <code>char a[] = &quot;hello&quot;;</code> 。</li>
<li>用数组初始化 <code>vector</code>： <code>int a[] = &#123;1,2,3,4,5&#125;; vector&lt;int&gt; v(begin(a), end(a));</code> 。</li>
</ul>
<h4 id="数组和指针">数组和指针</h4>
<ul>
<li>使用数组时，编译器一般会把它转换成指针。</li>
<li>标准库类型限定使用的下标必须是无符号类型，而内置的下标可以处理负值。</li>
<li><strong>指针访问数组</strong>：在表达式中使用数组名时，名字会自动转换成指向数组的第一个元素的指针。</li>
</ul>
<h3 id="C风格字符串">C风格字符串</h3>
<ul>
<li>从C继承来的字符串。</li>
<li>用空字符结束（<code>\0</code>）。</li>
<li>对大多数应用来说，使用标准库 <code>string</code> 比使用C风格字符串更安全、更高效。</li>
<li>获取 <code>string</code> 中的 <code>cstring</code> ： <code>const char *str = s.c_str();</code> 。</li>
</ul>
<p>C标准库String函数，定义在<code>&lt;cstring&gt;</code> 中：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>strlen(p)</code></td>
<td>返回<code>p</code>的长度，空字符不计算在内</td>
</tr>
<tr>
<td><code>strcmp(p1, p2)</code></td>
<td>比较<code>p1</code>和<code>p2</code>的相等性。如果<code>p1==p2</code>，返回0；如果<code>p1&gt;p2</code>，返回一个正值；如果<code>p1&lt;p2</code>，返回一个负值。</td>
</tr>
<tr>
<td><code>strcat(p1, p2)</code></td>
<td>将<code>p2</code>附加到<code>p1</code>之后，返回<code>p1</code></td>
</tr>
<tr>
<td><code>strcpy(p1, p2)</code></td>
<td>将<code>p2</code>拷贝给<code>p1</code>，返回<code>p1</code></td>
</tr>
</tbody>
</table>
<p><strong>尽量使用vector和迭代器，少用数组</strong></p>
<h3 id="多维数组">多维数组</h3>
<ul>
<li><strong>多维数组的初始化</strong>： <code>int ia[3][4] = &#123;&#123;0,1,2,3&#125;,...&#125;` 。

  

- 使用范围for语句时，除了最内层的循环外，其他所有循环的控制变量都应该是**引用**类型。

### 指针vs引用

- 引用总是指向某个对象，定义引用时没有初始化是错的。
- 给引用赋值，修改的是该引用所关联的对象的值，而不是让引用和另一个对象相关联。

### 指向指针的指针

- 定义： `int **ppi = &pi;`
- 解引用：`**ppi`

### 动态数组

- 使用 `new`和 `delete`表达和c中`malloc`和`free`类似的功能，即在堆（自由存储区）中分配存储空间。
- 定义： `int *pia = new int[10];` 10可以被一个变量替代。
- 释放： `delete [] pia;`，注意不要忘记`[]`。

-------

## 第3章 字符串、向量和数组

### 命名空间的using声明（Namespace using Declarations）

使用`using`声明后就无须再通过专门的前缀去获取所需的名字了。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout;</span><br></pre></td></tr></table></figure>

程序中使用的每个名字都需要用独立的`using`声明引入。

头文件中通常不应该包含`using`声明。

### 标准库类型string（Library string Type）

标准库类型`string`表示可变长的字符序列，定义在头文件`string`中。

#### 定义和初始化string对象（Defining and Initializing strings）

初始化`string`的方式：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031454273.png" alt="3-1" style="zoom: 67%;" />

如果使用等号初始化一个变量，实际上执行的是拷贝初始化（copy initialization），编译器把等号右侧的初始值拷贝到新创建的对象中去。如果不使用等号，则执行的是直接初始化（direct initialization）。

#### string对象上的操作（Operations on strings）

`string`的操作：

<img src="C:\Users\SEUGarfield\Desktop\Cpp-Primer-5th-Notes-CN-master\Chapter-3 Strings, Vectors, and Arrays\Images\3-2.png" alt="3-2" style="zoom:67%;" />

在执行读取操作时，`string`对象会自动忽略开头的空白（空格符、换行符、制表符等）并从第一个真正的字符开始读取，直到遇见下一处空白为止。

使用`getline`函数可以读取一整行字符。**该函数只要遇到换行符就结束读取并返回结果，如果输入的开始就是一个换行符，则得到空`string`。触发`getline`函数返回的那个换行符实际上被丢弃掉了，得到的`string`对象中并不包含该换行符。**

`size`函数返回`string`对象的长度，返回值是`string::size_type`类型，这是一种无符号类型。要使用`size_type`，必须先指定它是由哪种类型定义的。

如果一个表达式中已经有了`size`函数就不要再使用`int`了，这样可以避免混用`int`和`unsigned int`可能带来的问题。

当把`string`对象和字符字面值及字符串字面值混合在一条语句中使用时，必须确保每个加法运算符两侧的运算对象中至少有一个是`string`。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s4 = s1 + <span class="string">&quot;, &quot;</span>;          <span class="comment">// ok: adding a string and a literal</span></span><br><span class="line">string s5 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;, &quot;</span>;     <span class="comment">// error: no string operand</span></span><br><span class="line">string s6 = s1 + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;world&quot;</span>;    <span class="comment">// ok: each + has a string operand</span></span><br></pre></td></tr></table></figure>

为了与C兼容，C++语言中的字符串字面值并不是标准库`string`的对象。

#### 处理string对象中的字符（Dealing with the Characters in a string）

头文件`cctype`中的字符操作函数：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031454280.png" alt="3-3" style="zoom:67%;" />

建议使用C++版本的C标准库头文件。C语言中名称为`name.h`的头文件，在C++中则被命名为`cname`。

C++11提供了范围`for`（range for）语句，可以遍历给定序列中的每个元素并执行某种操作。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

`expression`部分是一个对象，用于表示一个序列。`declaration`部分负责定义一个变量，该变量被用于访问序列中的基础元素。每次迭代，`declaration`部分的变量都会被初始化为`expression`部分的下一个元素值。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;some string&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// print the characters in str one character to a line</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : str)      <span class="comment">// for every char in str</span></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;  <span class="comment">// print the current character followed by a newline</span></span><br></pre></td></tr></table></figure>

如果想在范围`for`语句中改变`string`对象中字符的值，必须把循环变量定义成引用类型。

下标运算符接收的输入参数是`string::size_type`类型的值，表示要访问字符的位置，返回值是该位置上字符的引用。

下标数值从0记起，范围是0至`size - 1`。使用超出范围的下标将引发不可预知的后果。

C++标准并不要求标准库检测下标是否合法。编程时可以把下标的类型定义为相应的`size_type`，这是一种无符号数，可以确保下标不会小于0，此时代码只需要保证下标小于`size`的值就可以了。另一种确保下标合法的有效手段就是使用范围`for`语句。

### 标准库类型vector（Library vector Type）

标准库类型`vector`表示对象的集合，也叫做容器（container），定义在头文件`vector`中。`vector`中所有对象的类型都相同，每个对象都有一个索引与之对应并用于访问该对象。

`vector`是模板（template）而非类型，由`vector`生成的类型必须包含`vector`中元素的类型，如`vector<int>`。

因为引用不是对象，所以不存在包含引用的`vector`。

在早期的C++标准中，如果`vector`的元素还是`vector`，定义时必须在外层`vector`对象的右尖括号和其元素类型之间添加一个空格，如`vector<vector<int> >`。但是在C++11标准中，可以直接写成`vector<vector<int>>`，不需要添加空格。

#### 定义和初始化vector对象（Defining and Initializing vectors）

初始化`vector`对象的方法：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031454281.png" alt="3-4" style="zoom:67%;" />

初始化`vector`对象时如果使用圆括号，可以说提供的值是用来构造（construct）`vector`对象的；如果使用的是花括号，则是在列表初始化（list initialize）该`vector`对象。

可以只提供`vector`对象容纳的元素数量而省略初始值，此时会创建一个值初始化（value-initialized）的元素初值，并把它赋给容器中的所有元素。这个初值由`vector`对象中的元素类型决定。

#### 向vector对象中添加元素（Adding Elements to a vector）

`push_back`函数可以把一个值添加到`vector`的尾端。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2;         <span class="comment">// empty vector</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">100</span>; ++i)</span><br><span class="line">    v2.<span class="built_in">push_back</span>(i);    <span class="comment">// append sequential integers to v2</span></span><br><span class="line"><span class="comment">// at end of loop v2 has 100 elements, values 0 . . . 99</span></span><br></pre></td></tr></table></figure>

范围`for`语句体内不应该改变其所遍历序列的大小。

#### 其他vector操作（Other vector Operations）

`vector`支持的操作：

![3-5](https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031454284.png)

`size`函数返回`vector`对象中元素的个数，返回值是由`vector`定义的`size_type`类型。`vector`对象的类型包含其中元素的类型。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;::size_type  <span class="comment">// ok</span></span><br><span class="line">vector::size_type       <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

`vector`和`string`对象的下标运算符只能用来访问已经存在的元素，而不能用来添加元素。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; ivec;   <span class="comment">// empty vector</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(ivec.<span class="built_in">size</span>()) ix = <span class="number">0</span>; ix != <span class="number">10</span>; ++ix)</span><br><span class="line">&#123;</span><br><span class="line">    ivec[ix] = ix;  <span class="comment">// disaster: ivec has no elements</span></span><br><span class="line">    ivec.<span class="built_in">push_back</span>(ix); <span class="comment">// ok: adds a new element with value ix</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 迭代器介绍（Introducing Iterators）

迭代器的作用和下标类似，但是更加通用。所有标准库容器都可以使用迭代器，但是其中只有少数几种同时支持下标运算符。

#### 使用迭代器（Using Iterators）

定义了迭代器的类型都拥有`begin`和`end`两个成员函数。`begin`函数返回指向第一个元素的迭代器，`end`函数返回指向容器“尾元素的下一位置（one past the end）”的迭代器，通常被称作尾后迭代器（off-the-end iterator）或者简称为尾迭代器（end iterator）。尾后迭代器仅是个标记，表示程序已经处理完了容器中的所有元素。迭代器一般为`iterator`类型。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b denotes the first element and e denotes one past the last element in ivec</span></span><br><span class="line"><span class="keyword">auto</span> b = ivec.<span class="built_in">begin</span>(), e = ivec.<span class="built_in">end</span>();    <span class="comment">// b and e have the same type</span></span><br></pre></td></tr></table></figure>

如果容器为空，则`begin`和`end`返回的是同一个迭代器，都是尾后迭代器。

标准容器迭代器的运算符：

![3-6](C:\Users\SEUGarfield\Desktop\Cpp-Primer-5th-Notes-CN-master\Chapter-3 Strings, Vectors, and Arrays\Images\3-6.png)

因为`end`返回的迭代器并不实际指向某个元素，所以不能对其进行递增或者解引用的操作。

在`for`或者其他循环语句的判断条件中，最好使用`!=`而不是`<`。所有标准库容器的迭代器都定义了`==`和`!=`，但是只有其中少数同时定义了`<`运算符。

如果`vector`或`string`对象是常量，则只能使用`const_iterator`迭代器，该迭代器只能读元素，不能写元素。

`begin`和`end`返回的迭代器具体类型由对象是否是常量决定，如果对象是常量，则返回`const_iterator`；如果对象不是常量，则返回`iterator`。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.<span class="built_in">begin</span>();   <span class="comment">// it1 has type vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.<span class="built_in">begin</span>();  <span class="comment">// it2 has type vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure>

C++11新增了`cbegin`和`cend`函数，不论`vector`或`string`对象是否为常量，都返回`const_iterator`迭代器。

任何可能改变容器对象容量的操作，都会使该对象的迭代器失效。

#### 迭代器运算（Iterator Arithmetic）

`vector`和`string`迭代器支持的操作：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031454482.png" alt="3-7" style="zoom:67%;" />

`difference_type`类型用来表示两个迭代器间的距离，这是一种带符号整数类型。

### 数组（Arrays）

数组类似`vector`，但数组的大小确定不变，不能随意向数组中添加元素。

如果不清楚元素的确切个数，应该使用`vector`。

#### 定义和初始化内置数组（Defining and Initializing Built-in Arrays）

数组是一种复合类型，声明形式为`a[d]`，其中`a`是数组名称，`d`是数组维度（dimension）。维度必须是一个常量表达式。

默认情况下，数组的元素被默认初始化。

定义数组的时候必须指定数组的类型，不允许用`auto`关键字由初始值列表推断类型。

如果定义数组时提供了元素的初始化列表，则允许省略数组维度，编译器会根据初始值的数量计算维度。但如果显式指明了维度，那么初始值的数量不能超过指定的大小。如果维度比初始值的数量大，则用提供的值初始化数组中靠前的元素，剩下的元素被默认初始化。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ia1[sz] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;  <span class="comment">// array of three ints with values 0, 1, 2</span></span><br><span class="line"><span class="keyword">int</span> a2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;   <span class="comment">// an array of dimension 3</span></span><br><span class="line"><span class="keyword">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;  <span class="comment">// equivalent to a3[] = &#123;0, 1, 2, 0, 0&#125;</span></span><br><span class="line">string a4[<span class="number">3</span>] = &#123;<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;bye&quot;</span>&#125;;   <span class="comment">// same as a4[] = &#123;&quot;hi&quot;, &quot;bye&quot;, &quot;&quot;&#125;</span></span><br><span class="line"><span class="keyword">int</span> a5[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;    <span class="comment">// error: too many initializers</span></span><br></pre></td></tr></table></figure>

可以用字符串字面值初始化字符数组，但字符串字面值结尾处的空字符也会一起被拷贝到字符数组中。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>&#125;;        <span class="comment">// list initialization, no null</span></span><br><span class="line"><span class="keyword">char</span> a2[] = &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;  <span class="comment">// list initialization, explicit null</span></span><br><span class="line"><span class="keyword">char</span> a3[] = <span class="string">&quot;C++&quot;</span>;      <span class="comment">// null terminator added automatically</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">6</span>] = <span class="string">&quot;Daniel&quot;</span>;    <span class="comment">// error: no space for the null!</span></span><br></pre></td></tr></table></figure>

不能用一个数组初始化或直接赋值给另一个数组。

从数组的名字开始由内向外阅读有助于理解复杂数组声明的含义。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];              <span class="comment">// ptrs is an array of ten pointers to int</span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>] = <span class="comment">/* ? */</span>;    <span class="comment">// error: no arrays of references</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*Parray)[<span class="number">10</span>] = &amp;arr;   <span class="comment">// Parray points to an array of ten ints</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (&amp;arrRef)[<span class="number">10</span>] = arr;    <span class="comment">// arrRef refers to an array of ten ints</span></span><br></pre></td></tr></table></figure>

#### 访问数组元素（Accessing the Elements of an Array）

数组下标通常被定义成`size_t`类型，这是一种机器相关的无符号类型，可以表示内存中任意对象的大小。`size_t`定义在头文件`cstddef`中。

大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。

#### 指针和数组（Pointers and Arrays）

在大多数表达式中，使用数组类型的对象其实是在使用一个指向该数组首元素的指针。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string nums[] = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;;    <span class="comment">// array of strings</span></span><br><span class="line">string *p = &amp;nums[<span class="number">0</span>];   <span class="comment">// p points to the first element in nums</span></span><br><span class="line">string *p2 = nums;      <span class="comment">// equivalent to p2 = &amp;nums[0]</span></span><br></pre></td></tr></table></figure>

一维数组寻址公式：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031454488.png" alt="3-8" style="zoom:67%;" />

当使用数组作为一个`auto`变量的初始值时，推断得到的类型是指针而非数组。但`decltype`关键字不会发生这种转换，直接返回数组类型。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;   <span class="comment">// ia is an array of ten ints</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;   <span class="comment">// ia2 is an int* that points to the first element in ia</span></span><br><span class="line">ia2 = <span class="number">42</span>;       <span class="comment">// error: ia2 is a pointer, and we can&#x27;t assign an int to a pointer</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(&amp;ia[<span class="number">0</span>])</span></span>;   <span class="comment">// now it&#x27;s clear that ia2 has type int*</span></span><br><span class="line"><span class="comment">// ia3 is an array of ten ints</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">ia3 = p;    <span class="comment">// error: can&#x27;t assign an int* to an array</span></span><br><span class="line">ia3[<span class="number">4</span>] = i;     <span class="comment">// ok: assigns the value of i to an element in ia3</span></span><br></pre></td></tr></table></figure>

C++11在头文件`iterator`中定义了两个名为`begin`和`end`的函数，功能与容器中的两个同名成员函数类似，参数是一个数组。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;   <span class="comment">// ia is an array of ten ints</span></span><br><span class="line"><span class="keyword">int</span> *beg = <span class="built_in">begin</span>(ia);   <span class="comment">// pointer to the first element in ia</span></span><br><span class="line"><span class="keyword">int</span> *last = <span class="built_in">end</span>(ia);    <span class="comment">// pointer one past the last element in ia</span></span><br></pre></td></tr></table></figure>

两个指针相减的结果类型是`ptrdiff_t`，这是一种定义在头文件`cstddef`中的带符号类型。

标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。

#### C风格字符串（C-Style Character Strings）

C风格字符串是将字符串存放在字符数组中，并以空字符结束（null terminated）。这不是一种类型，而是一种为了表达和使用字符串而形成的书写方法。

C++标准支持C风格字符串，但是最好不要在C++程序中使用它们。对大多数程序来说，使用标准库`string`要比使用C风格字符串更加安全和高效。

C风格字符串的函数：

<img src="C:\Users\SEUGarfield\Desktop\Cpp-Primer-5th-Notes-CN-master\Chapter-3 Strings, Vectors, and Arrays\Images\3-9.png" alt="3-9" style="zoom:67%;" />

C风格字符串函数不负责验证其参数的正确性，传入此类函数的指针必须指向以空字符作为结尾的数组。

#### 与旧代码的接口（Interfacing to Older Code）

任何出现字符串字面值的地方都可以用以空字符结束的字符数组来代替：

- 允许使用以空字符结束的字符数组来初始化`string`对象或为`string`对象赋值。
- 在`string`对象的加法运算中，允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）。
- 在`string`对象的复合赋值运算中，允许使用以空字符结束的字符数组作为右侧运算对象。

不能用`string`对象直接初始化指向字符的指针。为了实现该功能，`string`提供了一个名为`c_str`的成员函数，返回`const char*`类型的指针，指向一个以空字符结束的字符数组，数组的数据和`string`对象一样。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;    <span class="comment">// s holds Hello World</span></span><br><span class="line"><span class="keyword">char</span> *str = s;  <span class="comment">// error: can&#x27;t initialize a char* from a string</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = s.<span class="built_in">c_str</span>();    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

针对`string`对象的后续操作有可能会让`c_str`函数之前返回的数组失去作用，如果程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。

可以使用数组来初始化`vector`对象，但是需要指明要拷贝区域的首元素地址和尾后地址。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int_arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// ivec has six elements; each is a copy of the corresponding element in int_arr</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(int_arr), end(int_arr))</span></span>;</span><br></pre></td></tr></table></figure>

在新版本的C++程序中应该尽量使用`vector`、`string`和迭代器，避免使用内置数组、C风格字符串和指针。

### 多维数组（Multidimensional Arrays）

C++中的多维数组其实就是数组的数组。当一个数组的元素仍然是数组时，通常需要用两个维度定义它：一个维度表示数组本身的大小，另一个维度表示其元素（也是数组）的大小。通常把二维数组的第一个维度称作行，第二个维度称作列。

多维数组初始化的几种方式：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] =</span><br><span class="line">&#123;   <span class="comment">// three elements; each element is an array of size 4</span></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,   <span class="comment">// initializers for the row indexed by 0</span></span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,   <span class="comment">// initializers for the row indexed by 1</span></span><br><span class="line">    &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;  <span class="comment">// initializers for the row indexed by 2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// equivalent initialization without the optional nested braces for each row</span></span><br><span class="line"><span class="keyword">int</span> ib[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line"><span class="comment">// explicitly initialize only element 0 in each row</span></span><br><span class="line"><span class="keyword">int</span> ic[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123; <span class="number">0</span> &#125;, &#123; <span class="number">4</span> &#125;, &#123; <span class="number">8</span> &#125;&#125;;</span><br><span class="line"><span class="comment">// explicitly initialize row 0; the remaining elements are value initialized</span></span><br><span class="line"><span class="keyword">int</span> id[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>

可以使用下标访问多维数组的元素，数组的每个维度对应一个下标运算符。如果表达式中下标运算符的数量和数组维度一样多，则表达式的结果是给定类型的元素。如果下标运算符数量比数组维度小，则表达式的结果是给定索引处的一个内层数组。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assigns the first element of arr to the last element in the last row of ia</span></span><br><span class="line">ia[<span class="number">2</span>][<span class="number">3</span>] = arr[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>];  <span class="comment">// binds row to the second four-element array in ia</span></span><br></pre></td></tr></table></figure>

多维数组寻址公式：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031454566.png" alt="3-10" style="zoom:67%;" />

使用范围`for`语句处理多维数组时，为了避免数组被自动转换成指针，语句中的外层循环控制变量必须声明成引用类型。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;row : ia)  <span class="comment">// for every element in the outer array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row)    <span class="comment">// for every element in the inner array</span></span><br><span class="line">        cout &lt;&lt; col &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

如果`row`不是引用类型，编译器初始化`row`时会自动将数组形式的元素转换成指向该数组内首元素的指针，这样得到的`row`就是`int*`类型，而之后的内层循环则试图在一个`int*`内遍历，程序将无法通过编译。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> row : ia)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row)</span><br></pre></td></tr></table></figure>

使用范围`for`语句处理多维数组时，除了最内层的循环，其他所有外层循环的控制变量都应该定义成引用类型。

因为多维数组实际上是数组的数组，所以由多维数组名称转换得到的指针指向第一个内层数组。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];       <span class="comment">// array of size 3; each element is an array of ints of size 4</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">4</span>] = ia;   <span class="comment">// p points to an array of four ints</span></span><br><span class="line">p = &amp;ia[<span class="number">2</span>];         <span class="comment">// p now points to the last element in ia</span></span><br></pre></td></tr></table></figure>

声明指向数组类型的指针时，必须带有圆括号。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip[<span class="number">4</span>];     <span class="comment">// array of pointers to int</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*ip)[<span class="number">4</span>];   <span class="comment">// pointer to an array of four ints</span></span><br></pre></td></tr></table></figure>

使用`auto`和`decltype`能省略复杂的指针定义。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print the value of each element in ia, with each inner array on its own line</span></span><br><span class="line"><span class="comment">// p points to an array of four ints</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = ia; p != ia + <span class="number">3</span>; ++p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// q points to the first element of an array of four ints; that is, q points to an int</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> q = *p; q != *p + <span class="number">4</span>; ++q)</span><br><span class="line">        cout &lt;&lt; *q &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

---------

## 第4章 表达式（简）

### 表达式基础

- **运算对象转换**：小整数类型会被提升为较大的整数类型
- **重载运算符**：当运算符作用在类类型的运算对象时，用户可以自行定义其含义。
- **左值和右值**：
  - C中原意：左值**可以**在表达式左边，右值不能。
  - `C++`：当一个对象被用作**右值**的时候，用的是对象的**值**（内容）；
  - 被用做**左值**时，用的是对象的**身份**（在内存中的位置）。
- **求值顺序**：`int i = f1() + f2()`
  - 先计算`f1() + f2()`,再计算`int i = f1() + f2()`。但是f1和f2的计算**先后不确定**
  - 但是，如果f1、f2都对同一对象进行了修改，因为顺序不确定，所以会编译出错，显示未定义

### 算术运算符

- **溢出**：当计算的结果超出该类型所能表示的范围时就会产生溢出。

- **bool类型不应该参与计算**

  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">bool</span> b2=-b;   <span class="comment">//仍然为true</span></span><br><span class="line"><span class="comment">//b为true，提升为对应int=1，-b=-1</span></span><br><span class="line"><span class="comment">//b2=-1≠0，所以b2仍未true</span></span><br></pre></td></tr></table></figure>

- 取余运算 m%n ，结果符号与 m 相同

### 逻辑运算符

- **短路求值**：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。**先左再右**
- 小技巧，声明为引用类型可以避免对元素的拷贝，如下，如string特别大时可以节省大量时间。

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; text;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s: text)&#123;</span><br><span class="line">  cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 赋值运算符

- 赋值运算的**返回结果时它的左侧运算对象**，且是一个左值。类型也就是左侧对象的类型。
- 如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。
- 赋值运算符满足**右结合律**，这点和其他二元运算符不一样。 `ival = jval = 0;`等价于`ival = (jval = 0);`
- 赋值运算优先级比较低，使用其当条件时应该加括号。
- 复合赋值运算符，**复合运算符只求值一次**，普通运算符求值两次。（对性能有一点点点点影响）
  任意复合运算符op等价于`a = a op b;`

### 递增递减运算符

* 前置版本`j = ++i`，先加一后赋值
* 后置版本`j = i++`，先赋值后加一

**优先使用前置**版本，后置多一步储存原始值。（除非需要变化前的值）

#### 混用解引用和递增运算符

`*iter++`等价于`*(iter++)`，递增优先级较高

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = vi.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (iter!=vi.<span class="built_in">end</span>()&amp;&amp;*iter&gt;=<span class="number">0</span>)</span><br><span class="line">	cout&lt;&lt;*iter++&lt;&lt;endl;	<span class="comment">// 输出当前值，指针向前移1</span></span><br></pre></td></tr></table></figure>

> **简洁是一种美德**，追求简洁能降低程序出错可能性

### 成员访问运算符

`ptr->mem`等价于`(*ptr).mem`

注意`.`运算符优先级大于`*`，所以记得加括号

### 条件运算符

- 条件运算符（`?:`）允许我们把简单的`if-else`逻辑嵌入到单个表达式中去，按照如下形式：`cond? expr1: expr2`

- 可以嵌套使用，**右结合律**，从右向左顺序组合

  - ```c++
    finalgrade = (grade > 90) ? "high pass"
        : (grade < 60) ? "fail" : "pass";
    //等价于
    finalgrade = (grade > 90) ? "high pass"
        : （(grade < 60) ? "fail" : "pass"）;
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 输出表达式使用条件运算符记得加括号，条件运算符优先级太低。</span><br><span class="line"></span><br><span class="line">### 位运算符</span><br><span class="line"></span><br><span class="line">用于检查和设置二进制位的功能。</span><br><span class="line"></span><br><span class="line">- 位运算符是作用于**整数类型**的运算对象。</span><br><span class="line">- 二进制位向左移（`&lt;&lt;`）或者向右移（`&gt;&gt;`），移出边界外的位就被舍弃掉了。</span><br><span class="line">- 位取反（`~`）（逐位求反）、与（`&amp;`）、或（`|`）、异或（`^`）</span><br><span class="line"></span><br><span class="line">有符号数负值可能移位后变号，所以强烈建议**位运算符仅用于无符号数**。</span><br><span class="line"></span><br><span class="line">应用：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">unsigned long quiz1 = 0;    // 每一位代表一个学生是否通过考试</span><br><span class="line">1UL &lt;&lt; 12;  // 代表第12个学生通过</span><br><span class="line">quiz1 |= (1UL &lt;&lt; 12);   // 将第12个学生置为已通过</span><br><span class="line">quiz1 &amp;= ~(1UL &lt;&lt; 12);  // 将第12个学生修改为未通过</span><br><span class="line">bool stu12 = quiz1 &amp; (1UL &lt;&lt; 12);   // 判断第12个学生是否通过</span><br></pre></td></tr></table></figure>

> 位运算符使用较少，但是重载cout、cin大家都用过

位运算符满足左结合律，优先级介于中间，使用时尽量加括号。

### sizeof运算符

- 返回一条表达式或一个类型名字所占的**字节数**。
- 返回的类型是 `size_t`的常量表达式。
- `sizeof`并不实际计算其运算对象的值。
- 两种形式：
  1. `sizeof (type)`，给出类型名
  2. `sizeof expr`，给出表达式
- 可用sizeof返回数组的大小

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// sizeof(ia)返回整个数组所占空间的大小</span></span><br><span class="line"><span class="comment">// sizeof(ia)/sizeof(*ia)返回数组的大小</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz = <span class="built_in"><span class="keyword">sizeof</span></span>(ia)/<span class="built_in"><span class="keyword">sizeof</span></span>(*ia);</span><br><span class="line"><span class="keyword">int</span> arr[sz];</span><br></pre></td></tr></table></figure>

### 逗号运算符

从左向右依次求值。

左侧求值结果丢弃，逗号运算符**结果是右侧表达式**的值。

### 类型转换

#### 隐式类型转换

> 设计为尽可能避免损失精度，即转换为更精细类型。

- 比 `int`类型小的整数值先提升为较大的整数类型。
- 条件中，非布尔转换成布尔。
- 初始化中，初始值转换成变量的类型。
- 算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型。
- 函数调用时也会有转换。

##### 算术转换

###### 整型提升

* 常见的char、bool、short能存在int就会转换成int，否则提升为`unsigned int`
* `wchar_t,char16_t,char32_t`提升为整型中`int,long,long long ……`最小的，且能容纳原类型所有可能值的类型。

##### 其他转换

> p143

#### 显式类型转换（尽量避免）

- **static_cast**：任何明确定义的类型转换，只要不包含底层const，都可以使用。 `double slope = static_cast<double>(j);`

- **dynamic_cast**：支持运行时类型识别。

- **const_cast**：只能改变运算对象的底层const，一般可用于去除const性质。 `const char *pc; char *p = const_cast<char*>(pc)`

  > 只有其可以改变常量属性

- **reinterpret_cast**：通常为运算对象的位模式提供低层次上的重新解释。

##### 旧式强制类型转换

`type expr`

### 运算符优先级表

> p147



-------

## 第4章 表达式

### 基础（Fundamentals）

表达式（expression）由一个或多个运算对象（operand）组成，对表达式求值将得到一个结果（result）。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。

#### 基础概念（Basic Concepts）

C++定义了一元运算符（unary operator）和二元运算符（binary operator）。除此之外，还有一个作用于三个运算对象的三元运算符。函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。

表达式求值过程中，小整数类型（如`bool`、`char`、`short`等）通常会被提升（promoted）为较大的整数类型，主要是`int`。

C++定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自定义其含义，这被称作运算符重载（overloaded operator）。

C++的表达式分为右值（rvalue）和左值（lvalue）。当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值时，用的是对象的地址。需要右值的地方可以用左值代替，反之则不行。

- 赋值运算符需要一个非常量左值作为其左侧运算对象，返回结果也是一个左值。
- 取地址符作用于左值运算对象，返回指向该运算对象的指针，该指针是一个右值。
- 内置解引用运算符、下标运算符、迭代器解引用运算符、`string`和`vector`的下标运算符都返回左值。
- 内置类型和迭代器的递增递减运算符作用于左值运算对象。前置版本返回左值，后置版本返回右值。

如果`decltype`作用于一个求值结果是左值的表达式，会得到引用类型。

#### 优先级与结合律（Precedence and Associativity）

复合表达式（compound expression）指含有两个或多个运算符的表达式。优先级与结合律决定了运算对象的组合方式。

括号无视优先级与结合律，表达式中括号括起来的部分被当成一个单元来求值，然后再与其他部分一起按照优先级组合。

#### 求值顺序（Order of Evaluation）

对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++i &lt;&lt; endl;    <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

处理复合表达式时建议遵循以下两点：

- 不确定求值顺序时，使用括号来强制让表达式的组合关系符合程序逻辑的要求。
- 如果表达式改变了某个运算对象的值，则在表达式的其他位置不要再使用这个运算对象。

当改变运算对象的子表达式本身就是另一个子表达式的运算对象时，第二条规则无效。如`*++iter`，递增运算符改变了`iter`的值，而改变后的`iter`又是解引用运算符的运算对象。类似情况下，求值的顺序不会成为问题。

### 算术运算符（Arithmetic Operators）

算术运算符（左结合律）：

![4-1](https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031520777.png)

在除法运算中，C++语言的早期版本允许结果为负数的商向上或向下取整，C++11新标准则规定商一律向0取整（即直接去除小数部分）。

### 逻辑和关系运算符（Logical and Relational Operators）

关系运算符作用于算术类型和指针类型，逻辑运算符作用于任意能转换成布尔值的类型。逻辑运算符和关系运算符的返回值都是布尔类型。

![4-2](https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031520475.png)

逻辑与（logical AND）运算符`&&`和逻辑或（logical OR）运算符`||`都是先计算左侧运算对象的值再计算右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会去计算右侧运算对象的值。这种策略称为短路求值（short-circuit evaluation）。

- 对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。
- 对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。

进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值`true`和`false`作为运算对象。

### 赋值运算符（Assignment Operators）

赋值运算符`=`的左侧运算对象必须是一个可修改的左值。

C++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vi;     <span class="comment">// initially empty</span></span><br><span class="line">vi = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;     <span class="comment">// vi now has ten elements, values 0 through 9</span></span><br></pre></td></tr></table></figure>

赋值运算符满足右结合律。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival, jval;</span><br><span class="line">ival = jval = <span class="number">0</span>;    <span class="comment">// ok: each assigned 0</span></span><br></pre></td></tr></table></figure>

因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。

不要混淆相等运算符`==`和赋值运算符`=`。

复合赋值运算符包括`+=`、`-=`、`*=`、`/=`、`%=`、`<<=`、`>>=`、`&=`、`^=`和`|=`。任意一种复合运算都完全等价于*a = a op b*。

### 递增和递减运算符（Increment and Decrement Operators）

递增和递减运算符是为对象加1或减1的简洁书写形式。很多不支持算术运算的迭代器可以使用递增和递减运算符。

递增和递减运算符分为前置版本和后置版本：

- 前置版本首先将运算对象加1（或减1），然后将改变后的对象作为求值结果。
- 后置版本也会将运算对象加1（或减1），但求值结果是运算对象改变前的值的副本。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">j = ++i;    <span class="comment">// j = 1, i = 1: prefix yields the incremented value</span></span><br><span class="line">j = i++;    <span class="comment">// j = 1, i = 2: postfix yields the unincremented value</span></span><br></pre></td></tr></table></figure>

除非必须，否则不应该使用递增或递减运算符的后置版本。后置版本需要将原始值存储下来以便于返回修改前的内容，如果我们不需要这个值，那么后置版本的操作就是一种浪费。

在某些语句中混用解引用和递增运算符可以使程序更简洁。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; *iter++ &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

### 成员访问运算符（The Member Access Operators）

点运算符`.`和箭头运算符`->`都可以用来访问成员，表达式`ptr->mem`等价于`(*ptr).mem`。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;a string&quot;</span>, *p = &amp;s1;</span><br><span class="line"><span class="keyword">auto</span> n = s1.<span class="built_in">size</span>();  <span class="comment">// run the size member of the string s1</span></span><br><span class="line">n = (*p).<span class="built_in">size</span>();    <span class="comment">// run size on the object to which p points</span></span><br><span class="line">n = p-&gt;<span class="built_in">size</span>();      <span class="comment">// equivalent to (*p).size()</span></span><br></pre></td></tr></table></figure>

### 条件运算符（The Conditional Operator）

条件运算符的使用形式如下：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond ? expr1 : expr2;</span><br></pre></td></tr></table></figure>

其中`cond`是判断条件的表达式，如果`cond`为真则对`expr1`求值并返回该值，否则对`expr2`求值并返回该值。

只有当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果才是左值，否则运算的结果就是右值。

条件运算符可以嵌套，但是考虑到代码的可读性，运算的嵌套层数最好不要超过两到三层。

条件运算符的优先级非常低，因此当一个长表达式中嵌套了条件运算子表达式时，通常需要在它两端加上括号。

### 位运算符（The Bitwise Operators）

位运算符（左结合律）：

![4-3](https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031521527.png)

在位运算中符号位如何处理并没有明确的规定，所以建议仅将位运算符用于无符号类型的处理。

左移运算符`<<`在运算对象右侧插入值为0的二进制位。右移运算符`>>`的行为依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在其左侧插入值为0的二进制位；如果是带符号类型，在其左侧插入符号位的副本或者值为0的二进制位，如何选择视具体环境而定。

### sizeof运算符（The sizeof Operator）

`sizeof`运算符返回一个表达式或一个类型名字所占的字节数，返回值是`size_t`类型。

在`sizeof`的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用。

`sizeof`运算符的结果部分依赖于其作用的类型：

- 对`char`或者类型为`char`的表达式执行`sizeof`运算，返回值为1。
- 对引用类型执行`sizeof`运算得到被引用对象所占空间的大小。
- 对指针执行`sizeof`运算得到指针本身所占空间的大小。
- 对解引用指针执行`sizeof`运算得到指针指向的对象所占空间的大小，指针不需要有效。
- 对数组执行`sizeof`运算得到整个数组所占空间的大小。
- 对`string`或`vector`对象执行`sizeof`运算只返回该类型固定部分的大小，不会计算对象中元素所占空间的大小。

### 逗号运算符（Comma Operator）

逗号运算符`,`含有两个运算对象，按照从左向右的顺序依次求值，最后返回右侧表达式的值。逗号运算符经常用在`for`循环中。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;::size_type cnt = ivec.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// assign values from size... 1 to the elements in ivec</span></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::size_type ix = <span class="number">0</span>; ix != ivec.<span class="built_in">size</span>(); ++ix, --cnt)</span><br><span class="line">    ivec[ix] = cnt;</span><br></pre></td></tr></table></figure>

### 类型转换（Type Conversions）

无须程序员介入，会自动执行的类型转换叫做隐式转换（implicit conversions）。

#### 算术转换（Integral Promotions）

把一种算术类型转换成另一种算术类型叫做算术转换。

整型提升（integral promotions）负责把小整数类型转换成较大的整数类型。

#### 其他隐式类型转换（Other Implicit Conversions）

在大多数表达式中，数组名字自动转换成指向数组首元素的指针。

常量整数值0或字面值`nullptr`能转换成任意指针类型；指向任意非常量的指针能转换成`void*`；指向任意对象的指针能转换成`const void*`。

任意一种算术类型或指针类型都能转换成布尔类型。如果指针或算术类型的值为0，转换结果是`false`，否则是`true`。

指向非常量类型的指针能转换成指向相应的常量类型的指针。

#### 显式转换（Explicit Conversions）

显式类型转换也叫做强制类型转换（cast）。虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。建议尽量避免强制类型转换。

命名的强制类型转换（named cast）形式如下：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast-name&lt;type&gt;(expression);</span><br></pre></td></tr></table></figure>

其中`type`是转换的目标类型，`expression`是要转换的值。如果`type`是引用类型，则转换结果是左值。`cast-name`是`static_cast`、`dynamic_cast`、`const_cast`和`reinterpret_cast`中的一种，用来指定转换的方式。

- `dynamic_cast`支持运行时类型识别。
- 任何具有明确定义的类型转换，只要不包含底层`const`，都能使用`static_cast`。
- `const_cast`只能改变运算对象的底层`const`，不能改变表达式的类型。同时也只有`const_cast`能改变表达式的常量属性。`const_cast`常常用于函数重载。
- `reinterpret_cast`通常为运算对象的位模式提供底层上的重新解释。

早期版本的C++语言中，显式类型转换包含两种形式：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> (expression);    <span class="comment">// function-style cast notation</span></span><br><span class="line">(type) expression;    <span class="comment">// C-language-style cast notation</span></span><br></pre></td></tr></table></figure>

----------

## 第5章 语句(简)

### 简单语句

- **表达式语句**：一个表达式末尾加上分号，就变成了表达式语句。
- **空语句**：只有一个单独的分号。
- **复合语句（块）**：用花括号 `&#123;&#125;`包裹起来的语句和声明的序列。一个块就是一个作用域。

### 条件语句

- **悬垂else**（dangling else）：用来描述在嵌套的`if else`语句中，如果`if`比`else`多时如何处理的问题。C++使用的方法是`else`匹配最近没有配对的`if`。

### 迭代语句

- **while**：当不确定到底要迭代多少次时，使用 `while`循环比较合适，比如读取输入的内容。
- **for**： `for`语句可以省略掉 `init-statement`， `condition`和 `expression`的任何一个；**甚至全部**。
- **范围for**： `for (declaration: expression) statement`

### 跳转语句

- **break**：`break`语句负责终止离它最近的`while`、`do while`、`for`或者`switch`语句，并从这些语句之后的第一条语句开始继续执行。
- **continue**：终止最近的循环中的当前迭代并立即开始下一次迭代。只能在`while`、`do while`、`for`循环的内部。

### try语句块和异常处理

- **throw表达式**：异常检测部分使用 `throw`表达式来表示它遇到了无法处理的问题。我们说 `throw`引发 `raise`了异常。
- **try语句块**：以 `try`关键词开始，以一个或多个 `catch`字句结束。 `try`语句块中的代码抛出的异常通常会被某个 `catch`捕获并处理。 `catch`子句也被称为**异常处理代码**。
- **异常类**：用于在 `throw`表达式和相关的 `catch`子句之间传递异常的具体信息。

---------

## 第5章 语句

### 简单语句（Simple Statements）

如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，则应该使用空语句（null statement）。空语句中只含有一个单独的分号`;`。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read until we hit end-of-file or find an input equal to sought</span></span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; s &amp;&amp; s != sought)</span><br><span class="line">    ;   <span class="comment">// null statement</span></span><br></pre></td></tr></table></figure>

使用空语句时应该加上注释，从而令读这段代码的人知道该语句是有意省略的。

多余的空语句并非总是无害的。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// disaster: extra semicolon: loop body is this null statement</span></span><br><span class="line"><span class="keyword">while</span> (iter != svec.<span class="built_in">end</span>()) ;    <span class="comment">// the while body is the empty statement</span></span><br><span class="line">    ++iter;     <span class="comment">// increment is not part of the loop</span></span><br></pre></td></tr></table></figure>

复合语句（compound statement）是指用花括号括起来的（可能为空）语句和声明的序列。复合语句也叫做块（block），一个块就是一个作用域。在块中引入的名字只能在块内部以及嵌套在块中的子块里访问。通常，名字在有限的区域内可见，该区域从名字定义处开始，到名字所在（最内层）块的结尾处为止。

语句块不以分号作为结束。

空块的作用等价于空语句。

### 语句作用域（Statement Scope）

可以在`if`、`switch`、`while`和`for`语句的控制结构内定义变量，这些变量只在相应语句的内部可见，一旦语句结束，变量也就超出了其作用范围。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">int</span> i = <span class="built_in">get_num</span>())   <span class="comment">// i is created and initialized on each iteration</span></span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">i = <span class="number">0</span>;  <span class="comment">// error: i is not accessible outside the loop</span></span><br></pre></td></tr></table></figure>

### 条件语句（Conditional Statements）

#### if语句（The if Statement）

`if`语句的形式：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

`if-else`语句的形式：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    statement2</span><br></pre></td></tr></table></figure>

其中`condition`是判断条件，可以是一个表达式或者初始化了的变量声明。`condition`必须用圆括号括起来。

- 如果`condition`为真，则执行`statement`。执行完成后，程序继续执行`if`语句后面的其他语句。
- 如果`condition`为假，则跳过`statement`。对于简单`if`语句来说，程序直接执行`if`语句后面的其他语句；对于`if-else`语句来说，程序先执行`statement2`，再执行`if`语句后面的其他语句。

`if`语句可以嵌套，其中`else`与离它最近的尚未匹配的`if`相匹配。

#### switch语句（The switch Statement）

`switch`语句的形式：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031522809.png" alt="5-1" style="zoom: 80%;" />

`switch`语句先对括号里的表达式求值，值转换成整数类型后再与每个`case`标签（case label）的值进行比较。如果表达式的值和某个`case`标签匹配，程序从该标签之后的第一条语句开始执行，直到到达`switch`的结尾或者遇到`break`语句为止。`case`标签必须是整型常量表达式。

通常情况下每个`case`分支后都有`break`语句。如果确实不应该出现`break`语句，最好写一段注释说明程序的逻辑。

尽管`switch`语句没有强制要求在最后一个`case`标签后写上`break`，但为了安全起见，最好添加`break`。这样即使以后增加了新的`case`分支，也不用再在前面补充`break`语句了。

`switch`语句中可以添加一个`default`标签（default label），如果没有任何一个`case`标签能匹配上`switch`表达式的值，程序将执行`default`标签后的语句。

即使不准备在`default`标签下做任何操作，程序中也应该定义一个`default`标签。其目的在于告诉他人我们已经考虑到了默认情况，只是目前不需要实际操作。

不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。如果需要为`switch`的某个`case`分支定义并初始化一个变量，则应该把变量定义在块内。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ok: declaration statement within a statement block</span></span><br><span class="line">    string file_name = <span class="built_in">get_file_name</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 迭代语句（Iterative Statements）

迭代语句通常称为循环，它重复执行操作直到满足某个条件才停止。`while`和`for`语句在执行循环体之前检查条件，`do-while`语句先执行循环体再检查条件。

#### while语句（The while Statement）

`while`语句的形式：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

只要`condition`的求值结果为`true`，就一直执行`statement`（通常是一个块）。`condition`不能为空，如果`condition`第一次求值就是`false`，`statement`一次都不会执行。

定义在`while`条件部分或者循环体内的变量每次迭代都经历从创建到销毁的过程。

在不确定迭代次数，或者想在循环结束后访问循环控制变量时，使用`while`比较合适。

#### 传统的for语句（Traditional for Statement）

`for`语句的形式：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initializer; condition; expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

一般情况下，`initializer`负责初始化一个值，这个值会随着循环的进行而改变。`condition`作为循环控制的条件，只要`condition`的求值结果为`true`，就执行一次`statement`。执行后再由`expression`负责修改`initializer`初始化的变量，这个变量就是`condition`检查的对象。如果`condition`第一次求值就是`false`，`statement`一次都不会执行。`initializer`中也可以定义多个对象，但是只能有一条声明语句，因此所有变量的基础类型必须相同。

`for`语句头中定义的对象只在`for`循环体内可见。

#### 范围for语句（Range for Statement）

范围`for`语句的形式：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

其中`expression`表示一个序列，拥有能返回迭代器的`begin`和`end`成员。`declaration`定义一个变量，序列中的每个元素都应该能转换成该变量的类型（可以使用`auto`）。如果需要对序列中的元素执行写操作，循环变量必须声明成引用类型。每次迭代都会重新定义循环控制变量，并将其初始化为序列中的下一个值，之后才会执行`statement`。

#### do-while语句（The do-while Statement）

`do-while`语句的形式：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">    statement</span></span><br><span class="line"><span class="function"><span class="title">while</span> <span class="params">(condition)</span></span>;</span><br></pre></td></tr></table></figure>

计算`condition`的值之前会先执行一次`statement`，`condition`不能为空。如果`condition`的值为`false`，循环终止，否则重复执行`statement`。

因为`do-while`语句先执行语句或块，再判断条件，所以不允许在条件部分定义变量。

### 跳转语句（Jump Statements）

跳转语句中断当前的执行过程。

#### break语句（The break Statement）

`break`语句只能出现在迭代语句或者`switch`语句的内部，负责终止离它最近的`while`、`do-while`、`for`或者`switch`语句，并从这些语句之后的第一条语句开始执行。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">string buf;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; buf &amp;&amp; !buf.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(buf[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="comment">// process up to the first blank</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = buf.<span class="built_in">begin</span>()+<span class="number">1</span>; it != buf.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (*it == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// #1, leaves the for loop</span></span><br><span class="line">                <span class="comment">// . . .</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// break #1 transfers control here</span></span><br><span class="line">            <span class="comment">// remaining &#x27;-&#x27; processing:</span></span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// #2, leaves the switch statement</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="comment">// . . .</span></span><br><span class="line">    &#125; <span class="comment">// end switch</span></span><br><span class="line"><span class="comment">// end of switch: break #2 transfers control here</span></span><br><span class="line">&#125; <span class="comment">// end while</span></span><br></pre></td></tr></table></figure>

#### continue语句（The continue Statement）

`continue`语句只能出现在迭代语句的内部，负责终止离它最近的循环的当前一次迭代并立即开始下一次迭代。和`break`语句不同的是，只有当`switch`语句嵌套在迭代语句内部时，才能在`switch`中使用`continue`。

`continue`语句中断当前迭代后，具体操作视迭代语句类型而定：

- 对于`while`和`do-while`语句来说，继续判断条件的值。
- 对于传统的`for`语句来说，继续执行`for`语句头中的第三部分，之后判断条件的值。
- 对于范围`for`语句来说，是用序列中的下一个元素初始化循环变量。

#### goto语句（The goto Statement）

`goto`语句（labeled statement）是一种特殊的语句，在它之前有一个标识符和一个冒号。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end: <span class="keyword">return</span>; <span class="comment">// labeled statement; may be the target of a goto</span></span><br></pre></td></tr></table></figure>

标签标识符独立于变量和其他标识符的名字，它们之间不会相互干扰。

`goto`语句的形式：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br></pre></td></tr></table></figure>

`goto`语句使程序无条件跳转到标签为`label`的语句处执行，但两者必须位于同一个函数内，同时`goto`语句也不能将程序的控制权从变量的作用域之外转移到作用域之内。

建议不要在程序中使用`goto`语句，它使得程序既难理解又难修改。

### try语句块和异常处理（try Blocks and Exception Handling）

异常（exception）是指程序运行时的反常行为，这些行为超出了函数正常功能的范围。当程序的某一部分检测到一个它无法处理的问题时，需要使用异常处理（exception handling）。

异常处理机制包括`throw`表达式（throw expression）、`try`语句块（try block）和异常类（exception class）。

- 异常检测部分使用`throw`表达式表示它遇到了无法处理的问题（`throw`引发了异常）。
- 异常处理部分使用`try`语句块处理异常。`try`语句块以关键字`try`开始，并以一个或多个`catch`子句（catch clause）结束。`try`语句块中代码抛出的异常通常会被某个`catch`子句处理，`catch`子句也被称作异常处理代码（exception handler）。
- 异常类用于在`throw`表达式和相关的`catch`子句之间传递异常的具体信息。

#### throw表达式（A throw Expression）

`throw`表达式包含关键字`throw`和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。

#### try语句块（The try Block）

`try`语句块的通用形式：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    program-statements</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (exception-declaration)</span><br><span class="line">&#123;</span><br><span class="line">    handler-statements</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (exception-declaration)</span><br><span class="line">&#123;</span><br><span class="line">    handler-statements</span><br><span class="line">&#125; <span class="comment">// . . .</span></span><br></pre></td></tr></table></figure>

`try`语句块中的`program-statements`组成程序的正常逻辑，其内部声明的变量在块外无法访问，即使在`catch`子句中也不行。`catch`子句包含关键字`catch`、括号内一个对象的声明（异常声明，exception declaration）和一个块。当选中了某个`catch`子句处理异常后，执行与之对应的块。`catch`一旦完成，程序会跳过剩余的所有`catch`子句，继续执行后面的语句。

如果最终没能找到与异常相匹配的`catch`子句，程序会执行名为`terminate`的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。类似的，如果一段程序没有`try`语句块且发生了异常，系统也会调用`terminate`函数并终止当前程序的执行。

#### 标准异常（Standard Exceptions）

异常类分别定义在4个头文件中：

- 头文件`exception`定义了最通用的异常类`exception`。它只报告异常的发生，不提供任何额外信息。

- 头文件`stdexcept`定义了几种常用的异常类。

  <img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031522807.png" alt="5-2" style="zoom:67%;" />

- 头文件`new`定义了`bad_alloc`异常类。

- 头文件`type_info`定义了`bad_cast`异常类。

标准库异常类的继承体系：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031522812.png" alt="5-3" style="zoom:67%;" />

只能以默认初始化的方式初始化`exception`、`bad_alloc`和`bad_cast`对象，不允许为这些对象提供初始值。其他异常类的对象在初始化时必须提供一个`string`或一个C风格字符串，通常表示异常信息。`what`成员函数可以返回该字符串的`string`副本。

---------

## 第6章 函数(简)

### 函数基础

- **函数定义**：包括返回类型、函数名字和0个或者多个**形参**（parameter）组成的列表和函数体。
- **调用运算符**：调用运算符的形式是一对圆括号 `()`，作用于一个表达式，该表达式是函数或者指向函数的指针。
- 圆括号内是用逗号隔开的**实参**（argument）列表。
- 函数调用过程：
  - 1.主调函数（calling function）的执行被中断。
  - 2.被调函数（called function）开始执行。
- **形参和实参**：形参和实参的**个数**和**类型**必须匹配上。
- **返回类型**： `void`表示函数不返回任何值。函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或者函数的指针。
- **名字**：名字的作用于是程序文本的一部分，名字在其中可见。

#### 局部对象

- **生命周期**：对象的生命周期是程序执行过程中该对象存在的一段时间。
- **局部变量**（local variable）：形参和函数体内部定义的变量统称为局部变量。它对函数而言是局部的，对函数外部而言是**隐藏**的。
- **自动对象**：只存在于块执行期间的对象。当块的执行结束后，它的值就变成**未定义**的了。
- **局部静态对象**： `static`类型的局部变量，生命周期贯穿函数调用前后。

#### 函数声明

- **函数声明**：函数的声明和定义唯一的区别是声明无需函数体，用一个分号替代。函数声明主要用于描述函数的接口，也称**函数原型**。
- **在头文件中进行函数声明**：建议变量在头文件中声明；在源文件中定义。
- **分离编译**： `CC a.cc b.cc`直接编译生成可执行文件；`CC -c a.cc b.cc`编译生成对象代码`a.o b.o`； `CC a.o b.o`编译生成可执行文件。

### 参数传递

- 形参初始化的机理和变量初始化一样。
- **引用传递**（passed by reference）：又称传引用调用（called by reference），指**形参是引用类型**，引用形参是它对应的实参的别名。
- **值传递**（passed by value）：又称传值调用（called by value），指实参的值是通过**拷贝**传递给形参。

#### 传值参数

- 当初始化一个非引用类型的变量时，初始值被拷贝给变量。
- 函数对形参做的所有操作都不会影响实参。
- **指针形参**：常用在C中，`C++`建议使用引用类型的形参代替指针。

#### 传引用参数

- 通过使用引用形参，允许函数改变一个或多个实参的值。
- 引用形参直接关联到绑定的对象，而非对象的副本。
- 使用引用形参可以用于**返回额外的信息**。
- 经常用引用形参来避免不必要的复制。
- `void swap(int &v1, int &v2)`
- 如果无需改变引用形参的值，最好将其声明为常量引用。

#### const形参和实参

- 形参的顶层`const`被忽略。`void func(const int i);`调用时既可以传入`const int`也可以传入`int`。
- 我们可以使用非常量初始化一个底层`const`对象，但是反过来不行。
- 在函数中，不能改变实参的**局部副本**。
- 尽量使用常量引用。

#### 数组形参

- 当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。
- 要注意数组的实际长度，不能越界。

#### main处理命令行选项

- `int main(int argc, char *argv[])&#123;...&#125;`
- 第一个形参代表参数的个数；第二个形参是参数C风格字符串数组。

#### 可变形参

`initializer_list`提供的操作（`C++11`）：

| 操作                                 | 解释                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| `initializer_list<T> lst;`           | 默认初始化；`T`类型元素的空列表                              |
| `initializer_list<T> lst&#123;a,b,c...&#125;;` | `lst`的元素数量和初始值一样多；`lst`的元素是对应初始值的副本；列表中的元素是`const`。 |
| `lst2(lst)`                          | 拷贝或赋值一个`initializer_list`对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 |
| `lst2 = lst`                         | 同上                                                         |
| `lst.size()`                         | 列表中的元素数量                                             |
| `lst.begin()`                        | 返回指向`lst`中首元素的指针                                  |
| `lst.end()`                          | 返回指向`lst`中微元素下一位置的指针                          |

`initializer_list`使用demo：

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_msg</span><span class="params">(ErrCode e, initializer_list&lt;string&gt; il)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; e.msg &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> bed = il.<span class="built_in">begin</span>(); beg != il.<span class="built_in">end</span>(); ++ beg)</span><br><span class="line">        cout &lt;&lt; *beg &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">err_msg</span>(<span class="built_in">ErrCode</span>(<span class="number">0</span>), &#123;<span class="string">&quot;functionX&quot;</span>, <span class="string">&quot;okay&#125;);</span></span><br></pre></td></tr></table></figure>

- 所有实参类型相同，可以使用 `initializer_list`的标准库类型。
- 实参类型不同，可以使用`可变参数模板`。
- 省略形参符： `...`，便于`C++`访问某些C代码，这些C代码使用了 `varargs`的C标准功能。

### 返回类型和return语句

#### 无返回值函数

没有返回值的 `return`语句只能用在返回类型是 `void`的函数中，返回 `void`的函数不要求非得有 `return`语句。

#### 有返回值函数

- `return`语句的返回值的类型必须和函数的返回类型相同，或者能够**隐式地**转换成函数的返回类型。
- 值的返回：返回的值用于初始化调用点的一个**临时量**，该临时量就是函数调用的结果。
- **不要返回局部对象的引用或指针**。
- **引用返回左值**：函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值；其他返回类型得到右值。
- **列表初始化返回值**：函数可以返回花括号包围的值的列表。（`C++11`）
- **主函数main的返回值**：如果结尾没有`return`，编译器将隐式地插入一条返回0的`return`语句。返回0代表执行成功。

#### 返回数组指针

- `Type (*function (parameter_list))[dimension]`
- 使用类型别名： `typedef int arrT[10];` 或者 `using arrT = int[10;]`，然后 `arrT* func() &#123;...&#125;`
- 使用 `decltype`： `decltype(odd) *arrPtr(int i) &#123;...&#125;`
- **尾置返回类型**： 在形参列表后面以一个`->`开始：`auto func(int i) -> int(*)[10]`（`C++11`）

### 函数重载

- **重载**：如果同一作用域内几个函数名字相同但形参列表不同，我们称之为重载（overload）函数。
- `main`函数不能重载。
- **重载和const形参**：
  - 一个有顶层const的形参和没有它的函数无法区分。 `Record lookup(Phone* const)`和 `Record lookup(Phone*)`无法区分。
  - 相反，是否有某个底层const形参可以区分。 `Record lookup(Account*)`和 `Record lookup(const Account*)`可以区分。
- **重载和作用域**：若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名。

### 特殊用途语言特性

#### 默认实参

- `string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');`
- 一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值。

#### 内联（inline）函数

- 普通函数的缺点：调用函数比求解等价表达式要慢得多。
- `inline`函数可以避免函数调用的开销，可以让编译器在编译时**内联地展开**该函数。
- `inline`函数应该在头文件中定义。

#### constexpr函数

- 指能用于常量表达式的函数。
- `constexpr int new_sz() &#123;return 42;&#125;`
- 函数的返回类型及所有形参类型都要是字面值类型。
- `constexpr`函数应该在头文件中定义。

#### 调试帮助

- `assert`预处理宏（preprocessor macro）：`assert(expr);`

开关调试状态：

`CC -D NDEBUG main.c`可以定义这个变量`NDEBUG`。

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">        cerr &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 函数匹配

- 重载函数匹配的**三个步骤**：1.候选函数；2.可行函数；3.寻找最佳匹配。
- **候选函数**：选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。
- **可行函数**：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数（viable function）。
- **寻找最佳匹配**：基本思想：实参类型和形参类型越接近，它们匹配地越好。

### 函数指针

- **函数指针**：是指向函数的指针。
- `bool (*pf)(const string &, const string &);` 注：两端的括号不可少。
- **函数指针形参**：
  - 形参中使用函数定义或者函数指针定义效果一样。
  - 使用类型别名或者`decltype`。
- **返回指向函数的指针**：1.类型别名；2.尾置返回类型。

--------

## 第6章 函数

### 函数基础（Function Basics）

典型的函数定义包括返回类型（return type）、函数名字、由0个或多个形式参数（parameter，简称形参）组成的列表和函数体（function body）。函数执行的操作在函数体中指明。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// factorial of val is val * (val - 1) * (val - 2) . . . * ((val - (val - 1)) * 1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;    <span class="comment">// local variable to hold the result as we calculate it</span></span><br><span class="line">    <span class="keyword">while</span> (val &gt; <span class="number">1</span>)</span><br><span class="line">    ret *= val--;   <span class="comment">// assign ret * val to ret and decrement val</span></span><br><span class="line">    <span class="keyword">return</span> ret;     <span class="comment">// return the result</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

程序通过调用运算符（call operator）来执行函数。调用运算符的形式之一是一对圆括号`()`，作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号内是一个用逗号隔开的实际参数（argument，简称实参）列表，用来初始化函数形参。调用表达式的类型就是函数的返回类型。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="built_in">fact</span>(<span class="number">5</span>);    <span class="comment">// j equals 120, i.e., the result of fact(5)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5! is &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

函数调用完成两项工作：

- 用实参初始化对应的形参。
- 将控制权从主调函数转移给被调函数。此时，主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行。

`return`语句结束函数的执行过程，完成两项工作：

- 返回`return`语句中的值（可能没有值）。
- 将控制权从被调函数转移回主调函数，函数的返回值用于初始化调用表达式的结果。

实参是形参的初始值，两者的顺序和类型必须一一对应。

函数的形参列表可以为空，但是不能省略。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;      <span class="comment">// implicit void parameter list</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;  <span class="comment">// explicit void parameter list</span></span><br></pre></td></tr></table></figure>

形参列表中的形参通常用逗号隔开，每个形参都是含有一个声明符的声明，即使两个形参类型一样，也必须把两个类型声明都写出来。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> v1, v2)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;      <span class="comment">// error</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f4</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

函数的任意两个形参不能同名，函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。

形参的名字是可选的，但是无法使用未命名的形参。即使某个形参不被函数使用，也必须为它提供一个实参。

函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或函数的指针。

#### 局部对象（Local Objects）

形参和函数体内定义的变量统称为局部变量（local variable）。

局部静态对象（local static object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序结束才被销毁，对象所在的函数结束执行并不会对它产生影响。在变量类型前添加关键字`static`可以定义局部静态对象。

如果局部静态对象没有显式的初始值，它将执行值初始化。

#### 函数声明（Function Declarations）

和变量类似，函数只能定义一次，但可以声明多次。函数声明也叫做函数原型（function prototype）。

函数应该在头文件中声明，在源文件中定义。定义函数的源文件应该包含含有函数声明的头文件。

#### 分离式编译（Separate Compilation）

分离式编译允许我们把程序按照逻辑关系分割到几个文件中去，每个文件独立编译。这一过程通常会产生后缀名是`.obj`或`.o`的文件，该文件包含对象代码（object code）。之后编译器把对象文件链接（link）在一起形成可执行文件。

### 参数传递（Argument Passing）

形参初始化的机理与变量初始化一样。

形参的类型决定了形参和实参交互的方式：

- 当形参是引用类型时，它对应的实参被引用传递（passed by reference），函数被传引用调用（called by reference）。引用形参是它对应实参的别名。
- 当形参不是引用类型时，形参和实参是两个相互独立的对象，实参的值会被拷贝给形参（值传递，passed by value），函数被传值调用（called by value）。

#### 传值参数（Passing Arguments by Value）

如果形参不是引用类型，则函数对形参做的所有操作都不会影响实参。

使用指针类型的形参可以访问或修改函数外部的对象。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function that takes a pointer and sets the pointed-to value to zero</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *ip = <span class="number">0</span>;  <span class="comment">// changes the value of the object to which ip points</span></span><br><span class="line">    ip = <span class="number">0</span>;   <span class="comment">// changes only the local copy of ip; the argument is unchanged</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

如果想在函数体内访问或修改函数外部的对象，建议使用引用形参代替指针形参。

#### 传引用参数（Passing Arguments by Reference）

通过使用引用形参，函数可以改变实参的值。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function that takes a reference to an int and sets the given object to zero</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> &amp;i)</span>  <span class="comment">// i is just another name for the object passed to reset</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = <span class="number">0</span>;  <span class="comment">// changes the value of the object to which i refers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

使用引用形参可以避免拷贝操作，拷贝大的类类型对象或容器对象比较低效。另外有的类类型（如IO类型）根本就不支持拷贝操作，这时只能通过引用形参访问该类型的对象。

除了内置类型、函数对象和标准库迭代器外，其他类型的参数建议以引用方式传递。

如果函数无须改变引用形参的值，最好将其声明为常量引用。

一个函数只能返回一个值，但利用引用形参可以使函数返回额外信息。

#### const形参和实参（const Parameters and Arguments）

当形参有顶层`const`时，传递给它常量对象或非常量对象都是可以的。

可以使用非常量对象初始化一个底层`const`形参，但是反过来不行。

把函数不会改变的形参定义成普通引用会极大地限制函数所能接受的实参类型，同时也会给别人一种误导，即函数可以修改实参的值。

#### 数组形参（Array Parameters）

因为不能拷贝数组，所以无法以值传递的方式使用数组参数，但是可以把形参写成类似数组的形式。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// each function has a single parameter of type const int*</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;    <span class="comment">// shows the intent that the function takes an array</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;  <span class="comment">// dimension for documentation purposes (at best)</span></span><br></pre></td></tr></table></figure>

因为数组会被转换成指针，所以当我们传递给函数一个数组时，实际上传递的是指向数组首元素的指针。

因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外信息。

以数组作为形参的函数必须确保使用数组时不会越界。

如果函数不需要对数组元素执行写操作，应该把数组形参定义成指向常量的指针。

形参可以是数组的引用，但此时维度是形参类型的一部分，函数只能作用于指定大小的数组。

将多维数组传递给函数时，数组第二维（以及后面所有维度）的大小是数组类型的一部分，不能省略。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="keyword">int</span> &amp;arr[<span class="number">10</span>])     <span class="comment">// error: declares arr as an array of references</span></span><br><span class="line"><span class="built_in">f</span>(<span class="built_in"><span class="keyword">int</span></span> (&amp;arr)[<span class="number">10</span>])   <span class="comment">// ok: arr is a reference to an array of ten ints</span></span><br></pre></td></tr></table></figure>

#### main：处理命令行选项（main：Handling Command-Line Options）

可以在命令行中向`main`函数传递参数，形式如下：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>

第二个形参`argv`是一个数组，数组元素是指向C风格字符串的指针；第一个形参`argc`表示数组中字符串的数量。

当实参传递给`main`函数后，`argv`的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。

在*Visual Studio*中可以设置`main`函数调试参数：

![6-1](https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031531700.png)

#### 含有可变形参的函数（Functions with Varying Parameters）

C++11新标准提供了两种主要方法处理实参数量不定的函数。

- 如果实参类型相同，可以使用`initializer_list`标准库类型。

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_msg</span><span class="params">(initializer_list&lt;string&gt; il)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> beg = il.<span class="built_in">begin</span>(); beg != il.<span class="built_in">end</span>(); ++beg)</span><br><span class="line">    cout &lt;&lt; *beg &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

- 如果实参类型不同，可以定义可变参数模板。

C++还可以使用省略符形参传递可变数量的实参，但这种功能一般只用在与C函数交换的接口程序中。

`initializer_list`是一种标准库类型，定义在头文件`initializer_list`中，表示某种特定类型的值的数组。

`initializer_list`提供的操作：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031531705.png" alt="6-2" style="zoom:67%;" />

拷贝或赋值一个`initializer_list`对象不会拷贝列表中的元素。拷贝后，原始列表和副本共享元素。

`initializer_list`对象中的元素永远是常量值。

如果想向`initializer_list`形参传递一个值的序列，则必须把序列放在一对花括号内。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expected != actual)</span><br><span class="line">    <span class="built_in">error_msg</span>(<span class="built_in">ErrCode</span>(<span class="number">42</span>), &#123;<span class="string">&quot;functionX&quot;</span>, expected, actual&#125;);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">error_msg</span>(<span class="built_in">ErrCode</span>(<span class="number">0</span>), &#123;<span class="string">&quot;functionX&quot;</span>, <span class="string">&quot;okay&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>

因为`initializer_list`包含`begin`和`end`成员，所以可以使用范围`for`循环处理其中的元素。

省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为`varargs`的C标准库功能。通常，省略符形参不应该用于其他目的。

省略符形参应该仅仅用于C和C++通用的类型，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。

### 返回类型和return语句（Return Types and the return Statement）

`return`语句有两种形式，作用是终止当前正在执行的函数并返回到调用该函数的地方。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">return</span> expression;</span><br></pre></td></tr></table></figure>

#### 无返回值函数（Functions with No Return Value）

没有返回值的`return`语句只能用在返回类型是`void`的函数中。返回`void`的函数可以省略`return`语句，因为在这类函数的最后一条语句后面会隐式地执行`return`。

通常情况下，如果`void`函数想在其中间位置提前退出，可以使用`return`语句。

一个返回类型是`void`的函数也能使用`return`语句的第二种形式，不过此时`return`语句的`expression`必须是另一个返回`void`的函数。

强行令`void`函数返回其他类型的表达式将产生编译错误。

#### 有返回值函数（Functions That Return a Value）

`return`语句的第二种形式提供了函数的结果。只要函数的返回类型不是`void`，该函数内的每条`return`语句就必须返回一个值，并且返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型（`main`函数例外）。

在含有`return`语句的循环后面应该也有一条`return`语句，否则程序就是错误的，但很多编译器无法发现此错误。

函数返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。

如果函数返回引用类型，则该引用仅仅是它所引用对象的一个别名。

函数不应该返回局部对象的指针或引用，因为一旦函数完成，局部对象将被释放。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// disaster: this function returns a reference to a local object</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> string &amp;<span class="title">manip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string ret;</span><br><span class="line">    <span class="comment">// transform ret in some way</span></span><br><span class="line">    <span class="keyword">if</span> (!ret.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> ret;   <span class="comment">// WRONG: returning a reference to a local object!</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Empty&quot;</span>;   <span class="comment">// WRONG: &quot;Empty&quot; is a local temporary string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

如果函数返回指针、引用或类的对象，则可以使用函数调用的结果访问结果对象的成员。

调用一个返回引用的函数会得到左值，其他返回类型得到右值。

C++11规定，函数可以返回用花括号包围的值的列表。同其他返回类型一样，列表也用于初始化表示函数调用结果的临时量。如果列表为空，临时量执行值初始化；否则返回的值由函数的返回类型决定。

- 如果函数返回内置类型，则列表内最多包含一个值，且该值所占空间不应该大于目标类型的空间。

- 如果函数返回类类型，由类本身定义初始值如何使用。

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// . . .</span></span><br><span class="line">    <span class="comment">// expected and actual are strings</span></span><br><span class="line">    <span class="keyword">if</span> (expected.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;  <span class="comment">// return an empty vector</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (expected == actual)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;functionX&quot;</span>, <span class="string">&quot;okay&quot;</span>&#125;;  <span class="comment">// return list-initialized vector</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;functionX&quot;</span>, expected, actual&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

`main`函数可以没有`return`语句直接结束。如果控制流到达了`main`函数的结尾处并且没有`return`语句，编译器会隐式地插入一条返回0的`return`语句。

`main`函数的返回值可以看作是状态指示器。返回0表示执行成功，返回其他值表示执行失败，其中非0值的具体含义依机器而定。

为了使`main`函数的返回值与机器无关，头文件`cstdlib`定义了`EXIT_SUCCESS`和`EXIT_FAILURE`这两个预处理变量，分别表示执行成功和失败。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (some_failure)</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE; <span class="comment">// defined in cstdlib</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS; <span class="comment">// defined in cstdlib</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

建议使用预处理变量`EXIT_SUCCESS`和`EXIT_FAILURE`表示`main`函数的执行结果。

如果一个函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为递归函数（recursive function）。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculate val!, which is 1 * 2 * 3 . . . * val</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">factorial</span>(val<span class="number">-1</span>) * val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在递归函数中，一定有某条路径是不包含递归调用的，否则函数会一直递归下去，直到程序栈空间耗尽为止。

相对于循环迭代，递归的效率较低。但在某些情况下使用递归可以增加代码的可读性。循环迭代适合处理线性问题（如链表，每个节点有唯一前驱、唯一后继），而递归适合处理非线性问题（如树，每个节点的前驱、后继不唯一）。

`main`函数不能调用它自身。

#### 返回数组指针（Returning a Pointer to an Array）

因为数组不能被拷贝，所以函数不能返回数组，但可以返回数组的指针或引用。

返回数组指针的函数形式如下：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Type</span> (*<span class="built_in">function</span>(parameter_list))[dimension]</span><br></pre></td></tr></table></figure>

其中`Type`表示元素类型，`dimension`表示数组大小，`(*function(parameter_list))`两端的括号必须存在。

C++11允许使用尾置返回类型（trailing return type）简化复杂函数声明。尾置返回类型跟在形参列表后面，并以一个`->`符号开头。为了表示函数真正的返回类型在形参列表之后，需要在本应出现返回类型的地方添加`auto`关键字。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fcn takes an int argument and returns a pointer to an array of ten ints</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>;</span><br></pre></td></tr></table></figure>

任何函数的定义都能使用尾置返回类型，但是这种形式更适用于返回类型比较复杂的函数。

如果我们知道函数返回的指针将指向哪个数组，就可以使用`decltype`关键字声明返回类型。但`decltype`并不会把数组类型转换成指针类型，所以还要在函数声明中添加一个`*`符号。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> even[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">// returns a pointer to an array of five int elements</span></span><br><span class="line"><span class="keyword">decltype</span>(odd) *<span class="built_in">arrPtr</span>(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (i % <span class="number">2</span>) ? &amp;odd : &amp;even;  <span class="comment">// returns a pointer to the array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 函数重载（Overloaded Functions）

同一作用域内的几个名字相同但形参列表不同的函数叫做重载函数。

`main`函数不能重载。

不允许两个函数除了返回类型以外的其他所有要素都相同。

顶层`const`不影响传入函数的对象，一个拥有顶层`const`的形参无法和另一个没有顶层`const`的形参区分开来。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>;  <span class="comment">// redeclares Record lookup(Phone)</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone* <span class="keyword">const</span>)</span></span>; <span class="comment">// redeclares Record lookup(Phone*)</span></span><br></pre></td></tr></table></figure>

如果形参是某种类型的指针或引用，则通过区分其指向的对象是常量还是非常量可以实现函数重载，此时的`const`是底层的。当我们传递给重载函数一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functions taking const and nonconst references or pointers have different parameters</span></span><br><span class="line"><span class="comment">// declarations for four independent, overloaded functions</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;        <span class="comment">// function that takes a reference to Account</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;  <span class="comment">// new function that takes a const reference</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account*)</span></span>;        <span class="comment">// new function, takes a pointer to Account</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account*)</span></span>;  <span class="comment">// new function, takes a pointer to const</span></span><br></pre></td></tr></table></figure>

`const_cast`可以用于函数的重载。当函数的实参不是常量时，将得到普通引用。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return a reference to the shorter of two strings</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string &amp;<span class="title">shorterString</span><span class="params">(string &amp;s1, string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = <span class="built_in">shorterString</span>(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> string&amp;&gt;(s1),</span><br><span class="line">                    <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> string&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

函数匹配（function matching）也叫做重载确定（overload resolution），是指编译器将函数调用与一组重载函数中的某一个进行关联的过程。

调用重载函数时有三种可能的结果：

- 编译器找到一个与实参最佳匹配（best match）的函数，并生成调用该函数的代码。
- 编译器找不到任何一个函数与实参匹配，发出无匹配（no match）的错误信息。
- 有一个以上的函数与实参匹配，但每一个都不是明显的最佳选择，此时编译器发出二义性调用（ambiguous call）的错误信息。

#### 重载与作用域（Overloading and Scope）

在不同的作用域中无法重载函数名。一旦在当前作用域内找到了所需的名字，编译器就会忽略掉外层作用域中的同名实体。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>)</span></span>;     <span class="comment">// overloads the print function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooBar</span><span class="params">(<span class="keyword">int</span> ival)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> read = <span class="literal">false</span>;  <span class="comment">// new scope: hides the outer declaration of read</span></span><br><span class="line">    string s = <span class="built_in">read</span>();  <span class="comment">// error: read is a bool variable, not a function</span></span><br><span class="line">    <span class="comment">// bad practice: usually it&#x27;s a bad idea to declare functions at local scope</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span>;    <span class="comment">// new scope: hides previous instances of print</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Value: &quot;</span>);   <span class="comment">// error: print(const string &amp;) is hidden</span></span><br><span class="line">    <span class="built_in">print</span>(ival);    <span class="comment">// ok: print(int) is visible</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>);    <span class="comment">// ok: calls print(int); print(double) is hidden</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在C++中，名字查找发生在类型检查之前。

### 特殊用途语言特性（Features for Specialized Uses）

#### 默认实参（Default Arguments）

默认实参作为形参的初始值出现在形参列表中。可以为一个或多个形参定义默认值，不过一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string::size_type sz;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz ht = <span class="number">24</span>, sz wid = <span class="number">80</span>, <span class="keyword">char</span> backgrnd = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。

如果想使用默认实参，只要在调用函数的时候省略该实参即可。

虽然多次声明同一个函数是合法的，但是在给定的作用域中一个形参只能被赋予一次默认实参。函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// no default for the height or width parameters</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz, sz, <span class="keyword">char</span> = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz, sz, <span class="keyword">char</span> = <span class="string">&#x27;*&#x27;</span>)</span></span>;      <span class="comment">// error: redeclaration</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = <span class="number">24</span>, sz = <span class="number">80</span>, <span class="keyword">char</span>)</span></span>;  <span class="comment">// ok: adds default</span></span><br></pre></td></tr></table></figure>

默认实参只能出现在函数声明和定义其中一处。通常应该在函数声明中指定默认实参，并将声明放在合适的头文件中。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Error: 编译器向前查找函数声明</span></span><br><span class="line">    <span class="comment">//        fun调用形式与声明不符</span></span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n = <span class="number">0</span>)</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>

局部变量不能作为函数的默认实参。

用作默认实参的名字在函数声明所在的作用域内解析，但名字的求值过程发生在函数调用时。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the declarations of wd, def, and ht must appear outside a function</span></span><br><span class="line">sz wd = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">char</span> def = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = ht(), sz = wd, <span class="keyword">char</span> = def)</span></span>;</span><br><span class="line">string window = <span class="built_in">screen</span>();   <span class="comment">// calls screen(ht(), 80, &#x27; &#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    def = <span class="string">&#x27;*&#x27;</span>;      <span class="comment">// changes the value of a default argument</span></span><br><span class="line">    sz wd = <span class="number">100</span>;    <span class="comment">// hides the outer definition of wd but does not change the</span></span><br><span class="line">    <span class="keyword">default</span></span><br><span class="line">    window = <span class="built_in">screen</span>();  <span class="comment">// calls screen(ht(), 80, &#x27;*&#x27;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 内联函数和constexpr函数（Inline and constexpr Functions）

内联函数会在每个调用点上“内联地”展开，省去函数调用所需的一系列工作。定义内联函数时需要在函数的返回类型前添加关键字`inline`。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inline version: find the shorter of two strings</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> string &amp;<span class="title">horterString</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在函数声明和定义中都能使用关键字`inline`，但是建议只在函数定义时使用。

一般来说，内联机制适用于优化规模较小、流程直接、调用频繁的函数。内联函数中不允许有循环语句和`switch`语句，否则函数会被编译为普通函数。

`constexpr`函数是指能用于常量表达式的函数。`constexpr`函数的返回类型及所有形参的类型都得是字面值类型。另外C++11标准要求`constexpr`函数体中必须有且只有一条`return`语句，但是此限制在C++14标准中被删除。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> foo = <span class="built_in">new_sz</span>();   <span class="comment">// ok: foo is a constant expression</span></span><br></pre></td></tr></table></figure>

`constexpr`函数的返回值可以不是一个常量。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scale(arg) is a constant expression if arg is a constant expression</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new_sz</span>() * cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="built_in">scale</span>(<span class="number">2</span>)];  <span class="comment">// ok: scale(2) is a constant expression</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;          <span class="comment">// i is not a constant expression</span></span><br><span class="line"><span class="keyword">int</span> a2[<span class="built_in">scale</span>(i)];   <span class="comment">// error: scale(i) is not a constant expression</span></span><br></pre></td></tr></table></figure>

`constexpr`函数被隐式地指定为内联函数。

和其他函数不同，内联函数和`constexpr`函数可以在程序中多次定义。因为在编译过程中，编译器需要函数的定义来随时展开函数。对于某个给定的内联函数或`constexpr`函数，它的多个定义必须完全一致。因此内联函数和`constexpr`函数通常定义在头文件中。

#### 调试帮助（Aids for Debugging）

|  变量名称  |     内容     |
| :--------: | :----------: |
| `__func__` | 当前函数名称 |
| `__FILE__` | 当前文件名称 |
| `__LINE__` |   当前行号   |
| `__TIME__` | 文件编译时间 |
| `__DATE__` | 文件编译日期 |

### 函数匹配（Function Matching）

函数实参类型与形参类型越接近，它们匹配得越好。

重载函数集中的函数称为候选函数（candidate function）。

可行函数（viable function）的形参数量与函数调用所提供的实参数量相等，并且每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。

调用重载函数时应该尽量避免强制类型转换。

### 实参类型转换（Argument Type Conversions）

所有算术类型转换的级别都一样。

如果载函数的区别在于它们的引用或指针类型的形参是否含有底层`const`，则调用发生时编译器通过实参是否是常量来决定函数的版本。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;    <span class="comment">// function that takes a reference to Account</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;  <span class="comment">// new function that takes a const reference</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Account a;</span><br><span class="line">Account b;</span><br><span class="line"><span class="built_in">lookup</span>(a);  <span class="comment">// calls lookup(const Account&amp;)</span></span><br><span class="line"><span class="built_in">lookup</span>(b);  <span class="comment">// calls lookup(Account&amp;)</span></span><br></pre></td></tr></table></figure>

### 函数指针（Pointers to Functions）

要想声明一个可以指向某种函数的指针，只需要用指针替换函数名称即可。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compares lengths of two strings</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf points to a function returning bool that takes two const string references</span></span><br><span class="line"><span class="built_in"><span class="keyword">bool</span></span> (*pf)(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;); <span class="comment">// uninitialized</span></span><br></pre></td></tr></table></figure>

可以直接使用指向函数的指针来调用函数，无须提前解引用指针。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pf = lengthCompare; <span class="comment">// pf now points to the function named lengthCompare</span></span><br><span class="line">pf = &amp;lengthCompare; <span class="comment">// equivalent assignment: address-of operator is optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);       <span class="comment">// calls lengthCompare</span></span><br><span class="line"><span class="keyword">bool</span> b2 = (*pf)(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);    <span class="comment">// equivalent call</span></span><br><span class="line"><span class="keyword">bool</span> b3 = <span class="built_in">lengthCompare</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);    <span class="comment">// equivalent call</span></span><br></pre></td></tr></table></figure>

对于重载函数，编译器通过指针类型决定函数版本，指针类型必须与重载函数中的某一个精确匹配。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (*pf1)(<span class="keyword">unsigned</span> <span class="keyword">int</span>) = ff; <span class="comment">// pf1 points to ff(unsigned)</span></span><br></pre></td></tr></table></figure>

 可以把函数的形参定义成指向函数的指针。调用时允许直接把函数名当作实参使用，它会自动转换成指针。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// third parameter is a function type and is automatically treated as a pointer to function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2, <span class="keyword">bool</span> pf(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;))</span></span>;</span><br><span class="line"><span class="comment">// equivalent declaration: explicitly define the parameter as a pointer to function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2, <span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// automatically converts the function lengthCompare to a pointer to function</span></span><br><span class="line"><span class="built_in">useBigger</span>(s1, s2, lengthCompare);</span><br></pre></td></tr></table></figure>

关键字`decltype`作用于函数时，返回的是函数类型，而不是函数指针类型。

函数可以返回指向函数的指针。但返回类型不会像函数类型的形参一样自动地转换成指针，必须显式地将其指定为指针类型。

----------

## 第7章 类 （Class）（简）

### 定义抽象数据类型

- **类背后的基本思想**：**数据抽象**（data abstraction）和**封装**（encapsulation）。
- 数据抽象是一种依赖于**接口**（interface）和**实现**（implementation）分离的编程技术。

#### 类成员 （Member）

- 必须在类的内部声明，不能在其他地方增加成员。
- 成员可以是数据，函数，类型别名。

#### 类的成员函数

- 成员函数的**声明**必须在类的内部。
- 成员函数的**定义**既可以在类的内部也可以在外部。
- 使用点运算符 `.` 调用成员函数。
- 必须对任何`const`或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。
- `ConstRef::ConstRef(int ii): i(ii), ci(i), ri(ii) &#123; &#125;`
- 默认实参： `Sales_item(const std::string &book): isbn(book), units_sold(0), revenue(0.0) &#123; &#125;`
- `*this`：
  - 每个成员函数都有一个额外的，隐含的形参`this`。
  - `this`总是指向当前对象，因此`this`是一个常量指针。
  - 形参表后面的`const`，改变了隐含的`this`形参的类型，如 `bool same_isbn(const Sales_item &rhs) const`，这种函数称为“常量成员函数”（`this`指向的当前对象是常量）。
  - `return *this;`可以让成员函数连续调用。
  - 普通的非`const`成员函数：`this`是指向类类型的`const`指针（可以改变`this`所指向的值，不能改变`this`保存的地址）。
  - `const`成员函数：`this`是指向const类类型的`const`指针（既不能改变`this`所指向的值，也不能改变`this`保存的地址）。

#### 非成员函数

- 和类相关的非成员函数，定义和声明都应该在类的外部。

#### 类的构造函数

- 类通过一个或者几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**。
- 构造函数是特殊的成员函数。
- 构造函数放在类的`public`部分。
- 与类同名的成员函数。
- `Sales_item(): units_sold(0), revenue(0.0) &#123; &#125;`
- `=default`要求编译器合成默认的构造函数。(`C++11`)
- 初始化列表：冒号和花括号之间的代码： `Sales_item(): units_sold(0), revenue(0.0) &#123; &#125;`

### 访问控制与封装

- **访问说明符**（access specifiers）：
  - `public`：定义在 `public`后面的成员在整个程序内可以被访问； `public`成员定义类的接口。
  - `private`：定义在 `private`后面的成员可以被类的成员函数访问，但不能被使用该类的代码访问； `private`隐藏了类的实现细节。
- 使用 `class`或者 `struct`：都可以被用于定义一个类。唯一的却别在于访问权限。
  - 使用 `class`：在第一个访问说明符之前的成员是 `priavte`的。
  - 使用 `struct`：在第一个访问说明符之前的成员是 `public`的。

#### 友元

- 允许特定的**非成员函数**访问一个类的**私有成员**.
- 友元的声明以关键字 `friend`开始。 `friend Sales_data add(const Sales_data&, const Sales_data&);`表示非成员函数`add`可以访问类的非公有成员。
- 通常将友元声明成组地放在**类定义的开始或者结尾**。
- 类之间的友元：
  - 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。

#### 封装的益处

- 确保用户的代码不会无意间破坏封装对象的状态。
- 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。

### 类的其他特性

- 成员函数作为内联函数 `inline`：
  - 在类的内部，常有一些规模较小的函数适合于被声明成内联函数。
  - **定义**在类内部的函数是**自动内联**的。
  - 在类外部定义的成员函数，也可以在声明时显式地加上 `inline`。
- **可变数据成员** （mutable data member）：
  - `mutable size_t access_ctr;`
  - 永远不会是`const`，即使它是`const`对象的成员。
- **类类型**：
  - 每个类定义了唯一的类型。

### 类的作用域

- 每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由引用、对象、指针使用成员访问运算符来访问。
- 函数的**返回类型**通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。
- 如果成员使用了外层作用域中的某个名字，而该名字代表一种**类型**，则类不能在之后重新定义该名字。
- 类中的**类型名定义**都要放在一开始。

### 构造函数再探

- 构造函数初始值列表：
  - 类似`python`使用赋值的方式有时候不行，比如`const`或者引用类型的数据，只能初始化，不能赋值。（注意初始化和赋值的区别）
  - 最好让构造函数初始值的顺序和成员声明的顺序保持一致。
  - 如果一个构造函数为所有参数都提供了默认参数，那么它实际上也定义了默认的构造函数。

#### 委托构造函数 （delegating constructor, `C++11`）

- 委托构造函数将自己的职责委托给了其他构造函数。
- `Sale_data(): Sale_data("", 0, 0) &#123;&#125;`

#### 隐式的类型转换

- 如果构造函数**只接受一个实参**，则它实际上定义了转换为此类类型的**隐式转换机制**。这种构造函数又叫**转换构造函数**（converting constructor）。
- 编译器只会自动地执行`仅一步`类型转换。
- 抑制构造函数定义的隐式转换：
  - 将构造函数声明为`explicit`加以阻止。
  - `explicit`构造函数只能用于直接初始化，不能用于拷贝形式的初始化。

#### 聚合类 （aggregate class）

- 满足以下所有条件：
  - 所有成员都是`public`的。
  - 没有定义任何构造函数。
  - 没有类内初始值。
  - 没有基类，也没有`virtual`函数。
- 可以使用一个花括号括起来的成员初始值列表，初始值的顺序必须和声明的顺序一致。

#### 字面值常量类

- `constexpr`函数的参数和返回值必须是字面值。
- **字面值类型**：除了算术类型、引用和指针外，某些类也是字面值类型。
- 数据成员都是字面值类型的聚合类是字面值常量类。
- 如果不是聚合类，则必须满足下面所有条件：
  - 数据成员都必须是字面值类型。
  - 类必须至少含有一个`constexpr`构造函数。
  - 如果一个数据成员含有类内部初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的`constexpr`构造函数。
  - 类必须使用析构函数的默认定义，该成员负责销毁类的对象。

### 类的静态成员

- 非`static`数据成员存在于类类型的每个对象中。
- `static`数据成员独立于该类的任意对象而存在。
- 每个`static`数据成员是与类关联的对象，并不与该类的对象相关联。
- 声明：
  - 声明之前加上关键词`static`。
- 使用：
  - 使用**作用域运算符**`::`直接访问静态成员:`r = Account::rate();`
  - 也可以使用对象访问：`r = ac.rate();`
- 定义：
  - 在类外部定义时不用加`static`。
- 初始化：
  - 通常不在类的内部初始化，而是在定义时进行初始化，如 `double Account::interestRate = initRate();`
  - 如果一定要在类内部定义，则要求必须是字面值常量类型的`constexpr`。

---------

## 第7章 类

类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程及设计技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数体以及其他私有函数。

### 定义抽象数据类型（Defining Abstract Data Types）

#### 设计Sales_data类（Designing the Sales_data Class）

类的用户是程序员，而非应用程序的最终使用者。

#### 定义改进的Sales_data类（Defining the Revised Sales_data Class）

成员函数（member function）的声明必须在类的内部，定义则既可以在类的内部也可以在类的外部。定义在类内部的函数是隐式的内联函数。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// new members: operations on Sales_data objects</span></span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// data members</span></span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

成员函数通过一个名为`this`的隐式额外参数来访问调用它的对象。`this`参数是一个常量指针，被初始化为调用该函数的对象地址。在函数体内可以显式使用`this`指针。 

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">total.<span class="built_in">isbn</span>()</span><br><span class="line"><span class="comment">// pseudo-code illustration of how a call to a member function is translated</span></span><br><span class="line">Sales_data::<span class="built_in">isbn</span>(&amp;total)</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; &#125;</span><br><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br></pre></td></tr></table></figure>

默认情况下，`this`的类型是指向类类型非常量版本的常量指针。`this`也遵循初始化规则，所以默认不能把`this`绑定到一个常量对象上，即不能在常量对象上调用普通的成员函数。

C++允许在成员函数的参数列表后面添加关键字`const`，表示`this`是一个指向常量的指针。使用关键字`const`的成员函数被称作常量成员函数（const member function）。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pseudo-code illustration of how the implicit this pointer is used</span></span><br><span class="line"><span class="comment">// this code is illegal: we may not explicitly define the this pointer ourselves</span></span><br><span class="line"><span class="comment">// note that this is a pointer to const because isbn is a const member</span></span><br><span class="line"><span class="function">std::string <span class="title">Sales_data::isbn</span><span class="params">(<span class="keyword">const</span> Sales_data *<span class="keyword">const</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;isbn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

常量对象和指向常量对象的引用或指针都只能调用常量成员函数。

类本身就是一个作用域，成员函数的定义嵌套在类的作用域之内。编译器处理类时，会先编译成员声明，再编译成员函数体（如果有的话），因此成员函数可以随意使用类的其他成员而无须在意这些成员的出现顺序。

在类的外部定义成员函数时，成员函数的定义必须与它的声明相匹配。如果成员函数被声明为常量成员函数，那么它的定义也必须在参数列表后面指定`const`属性。同时，类外部定义的成员名字必须包含它所属的类名。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (units_sold)</span><br><span class="line">        <span class="keyword">return</span> revenue / units_sold;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

可以定义返回`this`对象的成员函数。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;   <span class="comment">// add the members of rhs into</span></span><br><span class="line">    revenue += rhs.revenue;     <span class="comment">// the members of &#x27;this&#x27; object</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;       <span class="comment">// return the object on which the function was called</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 定义类相关的非成员函数（Defining Nonmember Class-Related Functions）

类的作者通常会定义一些辅助函数，尽管这些函数从概念上来说属于类接口的组成部分，但实际上它们并不属于类本身。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input transactions contain ISBN, number of copies sold, and sales price</span></span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">        &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

如果非成员函数是类接口的组成部分，则这些函数的声明应该与类放在同一个头文件中。

一般来说，执行输出任务的函数应该尽量减少对格式的控制。

#### 构造函数（Constructors）

类通过一个或几个特殊的成员函数来控制其对象的初始化操作，这些函数被称作构造函数。只要类的对象被创建，就会执行构造函数。

构造函数的名字和类名相同，没有返回类型，且不能被声明为`const`函数。构造函数在`const`对象的构造过程中可以向其写值。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// constructors added</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="keyword">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="keyword">const</span> std::string &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p):</span><br><span class="line">        <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;);</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

类通过默认构造函数（default constructor）来控制默认初始化过程，默认构造函数无须任何实参。

如果类没有显式地定义构造函数，则编译器会为类隐式地定义一个默认构造函数，该构造函数也被称为合成的默认构造函数（synthesized default constructor）。对于大多数类来说，合成的默认构造函数初始化数据成员的规则如下：

- 如果存在类内初始值，则用它来初始化成员。
- 否则默认初始化该成员。

某些类不能依赖于合成的默认构造函数。

- 只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数。一旦类定义了其他构造函数，那么除非再显式地定义一个默认的构造函数，否则类将没有默认构造函数。
- 如果类包含内置类型或者复合类型的成员，则只有当这些成员全部存在类内初始值时，这个类才适合使用合成的默认构造函数。否则用户在创建类的对象时就可能得到未定义的值。
- 编译器不能为某些类合成默认构造函数。例如类中包含一个其他类类型的成员，且该类型没有默认构造函数，那么编译器将无法初始化该成员。

在C++11中，如果类需要默认的函数行为，可以通过在参数列表后面添加`=default`来要求编译器生成构造函数。其中`=default`既可以和函数声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果`=default`在类的内部，则默认构造函数是内联的。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

构造函数初始值列表（constructor initializer list）负责为新创建对象的一个或几个数据成员赋初始值。形式是每个成员名字后面紧跟括号括起来的（或者在花括号内的）成员初始值，不同成员的初始值通过逗号分隔。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(<span class="keyword">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) &#123; &#125;</span><br><span class="line"><span class="built_in">Sales_data</span>(<span class="keyword">const</span> std::string &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p):</span><br><span class="line">    <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123; &#125;</span><br></pre></td></tr></table></figure>

当某个数据成员被构造函数初始值列表忽略时，它会以与合成默认构造函数相同的方式隐式初始化。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// has the same behavior as the original constructor defined above</span></span><br><span class="line"><span class="built_in">Sales_data</span>(<span class="keyword">const</span> std::string &amp;s):</span><br><span class="line">    <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(<span class="number">0</span>), <span class="built_in">revenue</span>(<span class="number">0</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>

构造函数不应该轻易覆盖掉类内初始值，除非新值与原值不同。如果编译器不支持类内初始值，则所有构造函数都应该显式初始化每个内置类型的成员。 

#### 拷贝、赋值和析构（Copy、Assignment，and Destruction）

编译器能合成拷贝、赋值和析构函数，但是对于某些类来说合成的版本无法正常工作。特别是当类需要分配类对象之外的资源时，合成的版本通常会失效。

### 访问控制与封装（Access Control and Encapsulation）

使用访问说明符（access specifier）可以加强类的封装性：

- 定义在`public`说明符之后的成员在整个程序内都可以被访问。`public`成员定义类的接口。
- 定义在`private`说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问。`private`部分封装了类的实现细节。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// access specifier added</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="keyword">const</span> std::string &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p):</span><br><span class="line">    <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="keyword">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream&amp;);</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// access specifier added</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> units_sold ? revenue/units_sold : <span class="number">0</span>; &#125;   </span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

一个类可以包含零或多个访问说明符，每个访问说明符指定了接下来的成员的访问级别，其有效范围到出现下一个访问说明符或类的结尾处为止。

使用关键字`struct`定义类时，定义在第一个访问说明符之前的成员是`public`的；而使用关键字`class`时，这些成员是`private`的。二者唯一的区别就是默认访问权限不同。

#### 友元（Friends）

类可以允许其他类或函数访问它的非公有成员，方法是使用关键字`friend`将其他类或函数声明为它的友元。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// friend declarations for nonmember Sales_data operations added</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// other members and access specifiers as before</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="keyword">const</span> std::string &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p):</span><br><span class="line">    <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="keyword">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream&amp;);</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// declarations for nonmember parts of the Sales_data interface</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

友元声明只能出现在类定义的内部，具体位置不限。友元不是类的成员，也不受它所在区域访问级别的约束。

通常情况下，最好在类定义开始或结束前的位置集中声明友元。

封装的好处：

- 确保用户代码不会无意间破坏封装对象的状态。
- 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。

友元声明仅仅指定了访问权限，而并非一个通常意义上的函数声明。如果希望类的用户能调用某个友元函数，就必须在友元声明之外再专门对函数进行一次声明（部分编译器没有该限制）。

为了使友元对类的用户可见，通常会把友元的声明（类的外部）与类本身放在同一个头文件中。

### 类的其他特性（Additional Class Features）

#### 类成员再探（Class Members Revisited）

由类定义的类型名字和其他成员一样存在访问限制，可以是`public`或`private`中的一种。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// alternative way to declare a type member using a type alias</span></span><br><span class="line">    <span class="keyword">using</span> pos = std::string::size_type;</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

与普通成员不同，用来定义类型的成员必须先定义后使用。类型成员通常位于类起始处。

定义在类内部的成员函数是自动内联的。

如果需要显式声明内联成员函数，建议只在类外部定义的位置说明`inline`。

`inline`成员函数该与类定义在同一个头文件中。

使用关键字`mutable`可以声明可变数据成员（mutable data member）。可变数据成员永远不会是`const`的，即使它在`const`对象内。因此`const`成员函数可以修改可变成员的值。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">size_t</span> access_ctr;  <span class="comment">// may change even in a const object</span></span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Screen::some_member</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++access_ctr;   <span class="comment">// keep a count of the calls to any member function</span></span><br><span class="line">    <span class="comment">// whatever other work this member needs to do</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

提供类内初始值时，必须使用`=`或花括号形式。

#### 返回\*this的成员函数（Functions That Return \*this）

`const`成员函数如果以引用形式返回`*this`，则返回类型是常量引用。

通过区分成员函数是否为`const`的，可以对其进行重载。在常量对象上只能调用`const`版本的函数；在非常量对象上，尽管两个版本都能调用，但会选择非常量版本。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// display overloaded on whether the object is const or not</span></span><br><span class="line">    <span class="function">Screen &amp;<span class="title">display</span><span class="params">(std::ostream &amp;os)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="built_in">do_display</span>(os); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Screen &amp;<span class="title">display</span><span class="params">(std::ostream &amp;os)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="built_in">do_display</span>(os); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// function to do the work of displaying a Screen</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_display</span><span class="params">(std::ostream &amp;os)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; os &lt;&lt; contents; &#125;</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Screen <span class="title">myScreen</span><span class="params">(<span class="number">5</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Screen <span class="title">blank</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">myScreen.<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>).<span class="built_in">display</span>(cout);    <span class="comment">// calls non const version</span></span><br><span class="line">blank.<span class="built_in">display</span>(cout);    <span class="comment">// calls const version</span></span><br></pre></td></tr></table></figure>

#### 类类型（Class Types）

每个类定义了唯一的类型。即使两个类的成员列表完全一致，它们也是不同的类型。

可以仅仅声明一个类而暂时不定义它。这种声明被称作前向声明（forward declaration），用于引入类的名字。在类声明之后定义之前都是一个不完全类型（incomplete type）。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>;</span>   <span class="comment">// declaration of the Screen class</span></span><br></pre></td></tr></table></figure>

可以定义指向不完全类型的指针或引用，也可以声明（不能定义）以不完全类型作为参数或返回类型的函数。

只有当类全部完成后才算被定义，所以一个类的成员类型不能是该类本身。但是一旦类的名字出现，就可以被认为是声明过了，因此类可以包含指向它自身类型的引用或指针。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link_screen</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Screen window;</span><br><span class="line">    Link_screen *next;</span><br><span class="line">    Link_screen *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

#### 友元再探（Friendship Revisited）

除了普通函数，类还可以把其他类或其他类的成员函数声明为友元。友元类的成员函数可以访问此类包括非公有成员在内的所有成员。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// Window_mgr members can access the private parts of class Screen</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>;</span></span><br><span class="line">    <span class="comment">// ... rest of the Screen class</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

友元函数可以直接定义在类的内部，这种函数是隐式内联的。但是必须在类外部提供相应声明令函数可见。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="comment">/* friend function can be defined in the class body */</span> &#125;</span><br><span class="line">    <span class="built_in">X</span>() &#123; <span class="built_in">f</span>(); &#125;   <span class="comment">// error: no declaration for f</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>(); &#125;     <span class="comment">// error: f hasn&#x27;t been declared</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;   <span class="comment">// declares the function defined inside X</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::h</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>(); &#125;     <span class="comment">// ok: declaration for f is now in scope</span></span><br></pre></td></tr></table></figure>

友元关系不存在传递性。

把其他类的成员函数声明为友元时，必须明确指定该函数所属的类名。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// Window_mgr::clear must have been declared before class Screen</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">    <span class="comment">// ... rest of the Screen class</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

如果类想把一组重载函数声明为友元，需要对这组函数中的每一个分别声明。

### 类的作用域（Class Scope）

当成员函数定义在类外时，返回类型中使用的名字位于类的作用域之外，此时返回类型必须指明它是哪个类的成员。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// add a Screen to the window and returns its index</span></span><br><span class="line">    <span class="function">ScreenIndex <span class="title">addScreen</span><span class="params">(<span class="keyword">const</span> Screen&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return type is seen before we&#x27;re in the scope of Window_mgr</span></span><br><span class="line"><span class="function">Window_mgr::ScreenIndex <span class="title">Window_mgr::addScreen</span><span class="params">(<span class="keyword">const</span> Screen &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    screens.<span class="built_in">push_back</span>(s);</span><br><span class="line">    <span class="keyword">return</span> screens.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 名字查找与作用域（Name Lookup and Class Scope）

成员函数体直到整个类可见后才会被处理，因此它能使用类中定义的任何名字。

声明中使用的名字，包括返回类型或参数列表，都必须确保使用前可见。

如果类的成员使用了外层作用域的某个名字，而该名字表示一种类型，则类不能在之后重新定义该名字。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bal; &#125; <span class="comment">// uses Money from the outer scop</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> Money; <span class="comment">// error: cannot redefine Money</span></span><br><span class="line">    Money bal;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

类型名定义通常出现在类起始处，这样能确保所有使用该类型的成员都位于类型名定义之后。

成员函数中名字的解析顺序：

- 在成员函数内查找该名字的声明，只有在函数使用之前出现的声明才会被考虑。
- 如果在成员函数内没有找到，则会在类内继续查找，这时会考虑类的所有成员。
- 如果类内也没有找到，会在成员函数定义之前的作用域查找。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// it is generally a bad idea to use the same name for a parameter and a member</span></span><br><span class="line"><span class="keyword">int</span> height;   <span class="comment">// defines a name subsequently used inside Screen</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dummy_fcn</span><span class="params">(pos height)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cursor = width * height;  <span class="comment">// which height? the parameter</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

可以通过作用域运算符`::`或显式`this`指针来强制访问被隐藏的类成员。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad practice: names local to member functions shouldn&#x27;t hide member names</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cursor = width * <span class="keyword">this</span>-&gt;height;  <span class="comment">// member height</span></span><br><span class="line">    <span class="comment">// alternative way to indicate the member</span></span><br><span class="line">    cursor = width * Screen::height;  <span class="comment">// member height</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good practice: don&#x27;t use a member name for a parameter or other local variable</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos ht)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cursor = width * height;  <span class="comment">// member height</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 构造函数再探（Constructors Revisited）

#### 构造函数初始值列表（Constructor Initializer List）

如果没有在构造函数初始值列表中显式初始化成员，该成员会在构造函数体之前执行默认初始化。

如果成员是`const`、引用，或者是某种未定义默认构造函数的类类型，必须在初始值列表中将其初始化。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstRef</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConstRef</span>(<span class="keyword">int</span> ii);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ci;</span><br><span class="line">    <span class="keyword">int</span> &amp;ri;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok: explicitly initialize reference and const members</span></span><br><span class="line">ConstRef::<span class="built_in">ConstRef</span>(<span class="keyword">int</span> ii): <span class="built_in">i</span>(ii), <span class="built_in">ci</span>(ii), <span class="built_in">ri</span>(i) &#123; &#125;</span><br></pre></td></tr></table></figure>

最好令构造函数初始值的顺序与成员声明的顺序一致，并且尽量避免使用某些成员初始化其他成员。

如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。

#### 委托构造函数（Delegating Constructors）

C++11扩展了构造函数初始值功能，可以定义委托构造函数。委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// defines the default constructor as well as one that takes a string argument</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s = <span class="string">&quot;&quot;</span>): <span class="built_in">bookNo</span>(s) &#123; &#125;</span><br><span class="line">    <span class="comment">// remaining constructors unchanged</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s, <span class="keyword">unsigned</span> cnt, <span class="keyword">double</span> rev):</span><br><span class="line">        <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(cnt), <span class="built_in">revenue</span>(rev*cnt) &#123; &#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;is) &#123; <span class="built_in">read</span>(is, *<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="comment">// remaining members as before</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 默认构造函数的作用（The Role of the Default Constructor）

当对象被默认初始化或值初始化时会自动执行默认构造函数。

默认初始化的发生情况：

- 在块作用域内不使用初始值定义非静态变量或数组。
- 类本身含有类类型的成员且使用合成默认构造函数。
- 类类型的成员没有在构造函数初始值列表中显式初始化。

值初始化的发生情况：

- 数组初始化时提供的初始值数量少于数组大小。
- 不使用初始值定义局部静态变量。
- 通过`T()`形式（`T`为类型）的表达式显式地请求值初始化。

类必须包含一个默认构造函数。

如果想定义一个使用默认构造函数进行初始化的对象，应该去掉对象名后的空括号对。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">obj</span><span class="params">()</span></span>;   <span class="comment">// oops! declares a function, not an object</span></span><br><span class="line">Sales_data obj2;    <span class="comment">// ok: obj2 is an object, not a function</span></span><br></pre></td></tr></table></figure>

#### 隐式的类类型转换（Implicit Class-Type Conversions）

如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制。这种构造函数被称为转换构造函数（converting constructor）。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string null_book = <span class="string">&quot;9-999-99999-9&quot;</span>;</span><br><span class="line"><span class="comment">// constructs a temporary Sales_data object</span></span><br><span class="line"><span class="comment">// with units_sold and revenue equal to 0 and bookNo equal to null_book</span></span><br><span class="line">item.<span class="built_in">combine</span>(null_book);</span><br></pre></td></tr></table></figure>

编译器只会自动执行一步类型转换。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error: requires two user-defined conversions:</span></span><br><span class="line"><span class="comment">//   (1) convert &quot;9-999-99999-9&quot; to string</span></span><br><span class="line"><span class="comment">//   (2) convert that (temporary) string to Sales_data</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="string">&quot;9-999-99999-9&quot;</span>);</span><br><span class="line"><span class="comment">// ok: explicit conversion to string, implicit conversion to Sales_data</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">string</span>(<span class="string">&quot;9-999-99999-9&quot;</span>));</span><br><span class="line"><span class="comment">// ok: implicit conversion to string, explicit conversion to Sales_data</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(<span class="string">&quot;9-999-99999-9&quot;</span>));</span><br></pre></td></tr></table></figure>

在要求隐式转换的程序上下文中，可以通过将构造函数声明为`explicit`的加以阻止。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="keyword">const</span> std::string &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p):</span><br><span class="line">        <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="keyword">const</span> std::string &amp;s)</span>: bookNo(s) &#123;</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(std::istream&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// remaining members as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

`explicit`关键字只对接受一个实参的构造函数有效。

只能在类内声明构造函数时使用`explicit`关键字，在类外定义时不能重复。

执行拷贝初始化时（使用`=`）会发生隐式转换，所以`explicit`构造函数只能用于直接初始化。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">item1</span> <span class="params">(null_book)</span></span>;   <span class="comment">// ok: direct initialization</span></span><br><span class="line"><span class="comment">// error: cannot use the copy form of initialization with an explicit constructor</span></span><br><span class="line">Sales_data item2 = null_book;</span><br></pre></td></tr></table></figure>

可以使用`explicit`构造函数显式地强制转换类型。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok: the argument is an explicitly constructed Sales_data object</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(null_book));</span><br><span class="line"><span class="comment">// ok: static_cast can use an explicit constructor</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="keyword">static_cast</span>&lt;Sales_data&gt;(cin));</span><br></pre></td></tr></table></figure>

#### 聚合类（Aggregate Classes）

聚合类满足如下条件：

- 所有成员都是`public`的。
- 没有定义任何构造函数。
- 没有类内初始值。
- 没有基类。
- 没有虚函数。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ival;</span><br><span class="line">    string s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

可以使用一个用花括号包围的成员初始值列表初始化聚合类的数据成员。初始值顺序必须与声明顺序一致。如果初始值列表中的元素个数少于类的成员个数，则靠后的成员被值初始化。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// val1.ival = 0; val1.s = string(&quot;Anna&quot;)</span></span><br><span class="line">Data val1 = &#123; <span class="number">0</span>, <span class="string">&quot;Anna&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

#### 字面值常量类（Literal Classes）

数据成员都是字面值类型的聚合类是字面值常量类。或者一个类不是聚合类，但符合下列条件，则也是字面值常量类：

- 数据成员都是字面值类型。
- 类至少含有一个`constexpr`构造函数。
- 如果数据成员含有类内初始值，则内置类型成员的初始值必须是常量表达式。如果成员属于类类型，则初始值必须使用成员自己的`constexpr`构造函数。
- 类必须使用析构函数的默认定义。

`constexpr`构造函数用于生成`constexpr`对象以及`constexpr`函数的参数或返回类型。

`constexpr`构造函数必须初始化所有数据成员，初始值使用`constexpr`构造函数或常量表达式。

### 类的静态成员（static Class Members）

使用关键字`static`可以声明类的静态成员。静态成员存在于任何对象之外，对象中不包含与静态成员相关的数据。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123; amount += amount * interestRate; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> interestRate; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string owner;</span><br><span class="line">    <span class="keyword">double</span> amount;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> interestRate;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

由于静态成员不与任何对象绑定，因此静态成员函数不能声明为`const`的，也不能在静态成员函数内使用`this`指针。

用户代码可以使用作用域运算符访问静态成员，也可以通过类对象、引用或指针访问。类的成员函数可以直接访问静态成员。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> r;</span><br><span class="line">r = Account::<span class="built_in">rate</span>(); <span class="comment">// access a static member using the scope operator</span></span><br><span class="line"></span><br><span class="line">Account ac1;</span><br><span class="line">Account *ac2 = &amp;ac1;</span><br><span class="line"><span class="comment">// equivalent ways to call the static member rate function</span></span><br><span class="line">r = ac1.<span class="built_in">rate</span>(); <span class="comment">// through an Account object or reference</span></span><br><span class="line">r = ac2-&gt;<span class="built_in">rate</span>(); <span class="comment">// through a pointer to an Account object</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123; amount += amount * interestRate; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> interestRate;</span><br><span class="line">    <span class="comment">// remaining members as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

在类外部定义静态成员时，不能重复`static`关键字，其只能用于类内部的声明语句。

由于静态数据成员不属于类的任何一个对象，因此它们并不是在创建类对象时被定义的。通常情况下，不应该在类内部初始化静态成员。而必须在类外部定义并初始化每个静态成员。一个静态成员只能被定义一次。一旦它被定义，就会一直存在于程序的整个生命周期中。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define and initialize a static class member</span></span><br><span class="line"><span class="keyword">double</span> Account::interestRate = <span class="built_in">initRate</span>();</span><br></pre></td></tr></table></figure>

建议把静态数据成员的定义与其他非内联函数的定义放在同一个源文件中，这样可以确保对象只被定义一次。

尽管在通常情况下，不应该在类内部初始化静态成员。但是可以为静态成员提供`const`整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的`constexpr`。初始值必须是常量表达式。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> interestRate; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> period = <span class="number">30</span>;  <span class="comment">// period is a constant</span></span><br><span class="line">    <span class="keyword">double</span> daily_tbl[period];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

静态数据成员的类型可以是它所属的类类型。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> Bar mem1;   <span class="comment">// ok: static member can have incomplete type</span></span><br><span class="line">    Bar *mem2;    <span class="comment">// ok: pointer member can have incomplete type</span></span><br><span class="line">    Bar mem3;   <span class="comment">// error: data members must have complete type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

可以使用静态成员作为函数的默认实参。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// bkground refers to the static member</span></span><br><span class="line">    <span class="comment">// declared later in the class definition</span></span><br><span class="line">    <span class="function">Screen&amp; <span class="title">clear</span><span class="params">(<span class="keyword">char</span> = bkground)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> bkground;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

--------------

## 第8章 IO库(简)

### 前面章节已经在用的IO库设施

- **istream**：输入流类型，提供输入操作。
- **ostream**：输出流类型，提供输出操作
- **cin**：一个`istream`对象，从标准输入读取数据。
- **cout**：一个`ostream`对象，向标准输出写入数据。
- **cerr**：一个`ostream`对象，向标准错误写入消息。
- **>>运算符**：用来从一个`istream`对象中读取输入数据。
- **<<运算符**：用来向一个`ostream`对象中写入输出数据。
- **getline函数**：从一个给定的`istream`对象中读取一行数据，存入到一个给定的`string`对象中。
  
### IO类

#### 标准库定义的IO类型

- `iostream`头文件：从标准流中读写数据，`istream`、`ostream`等。
- `fstream`头文件：从文件中读写数据，`ifstream`、`ofstream`等。
- `sstream`头文件：从字符串中读写数据，`istringstream`、`ostringstream`

#### IO对象不可复制或赋值

- 1.IO对象不能存在容器里.
- 2.形参和返回类型也不能是流类型。
- 3.形参和返回类型一般是流的**引用**。
- 4.读写一个IO对象会改变其状态，因此传递和返回的引用不能是`const`的。

#### 条件状态

| 状态                | 解释                                                         |
| ------------------- | ------------------------------------------------------------ |
| `strm:iostate`      | 是一种机器无关的**类型**，提供了表达条件状态的完整功能       |
| `strm:badbit`       | 用来指出流已经崩溃                                           |
| `strm:failbit`      | 用来指出一个IO操作失败了                                     |
| `strm:eofbit`       | 用来指出流到达了文件结束                                     |
| `strm:goodbit`      | 用来指出流未处于错误状态，此值保证为零                       |
| `s.eof()`           | 若流`s`的`eofbit`置位，则返回`true`                          |
| `s.fail()`          | 若流`s`的`failbit`置位，则返回`true`                         |
| `s.bad()`           | 若流`s`的`badbit`置位，则返回`true`                          |
| `s.good()`          | 若流`s`处于有效状态，则返回`true`                            |
| `s.clear()`         | 将流`s`中所有条件状态位复位，将流的状态设置成有效，返回`void` |
| `s.clear(flags)`    | 将流`s`中指定的条件状态位复位，返回`void`                    |
| `s.setstate(flags)` | 根据给定的标志位，将流`s`中对应的条件状态位置位，返回`void`  |
| `s.rdstate()`       | 返回流`s`的当前条件状态，返回值类型为`strm::iostate`         |

上表中，`strm`是一种IO类型，（如`istream`）， `s`是一个流对象。

#### 管理输出缓冲

- 每个输出流都管理一个缓冲区，执行输出的代码，文本串可能立即打印出来，也可能被操作系统保存在缓冲区内，随后再打印。
- 刷新缓冲区，可以使用如下IO操纵符：
  - `endl`：输出一个换行符并刷新缓冲区。
  - `flush`：刷新流，单不添加任何字符。
  - `ends`：在缓冲区插入空字符`null`，然后刷新。
  - `unitbuf`：告诉流接下来每次操作之后都要进行一次`flush`操作。
  - `nounitbuf`：回到正常的缓冲方式。

### 文件输入输出

- 头文件`fstream`定义了三个类型来支持文件IO：
  - `ifstream`从一个给定文件读取数据。
  - `ofstream`向一个给定文件写入数据。
  - `fstream`可以读写给定文件。
- **文件流**：需要读写文件时，必须定义自己的文件流对象，并绑定在需要的文件上。

#### fstream特有的操作

| 操作                      | 解释                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `fstream fstrm;`          | 创建一个未绑定的文件流。                                     |
| `fstream fstrm(s);`       | 创建一个文件流，并打开名为`s`的文件，`s`可以是`string`也可以是`char`指针 |
| `fstream fstrm(s, mode);` | 与前一个构造函数类似，但按指定`mode`打开文件                 |
| `fstrm.open(s)`           | 打开名为`s`的文件，并和`fstrm`绑定                           |
| `fstrm.close()`           | 关闭和`fstrm`绑定的文件                                      |
| `fstrm.is_open()`         | 返回一个`bool`值，指出与`fstrm`关联的文件是否成功打开且尚未关闭 |

上表中，`fstream`是头文件`fstream`中定义的一个类型，`fstrm`是一个文件流对象。

#### 文件模式

| 文件模式 | 解释                         |
| -------- | ---------------------------- |
| `in`     | 以读的方式打开               |
| `out`    | 以写的方式打开               |
| `app`    | 每次写操作前均定位到文件末尾 |
| `ate`    | 打开文件后立即定位到文件末尾 |
| `trunc`  | 截断文件                     |
| `binary` | 以二进制方式进行IO操作。     |

### string流

- 头文件`sstream`定义了三个类型来支持内存IO：
  - `istringstream`从`string`读取数据。
  - `ostringstream`向`string`写入数据。
  - `stringstream`可以读写给定`string`。

#### stringstream特有的操作

| 操作              | 解释                               |
| ----------------- | ---------------------------------- |
| `sstream strm`    | 定义一个未绑定的`stringstream`对象 |
| `sstream strm(s)` | 用`s`初始化对象                    |
| `strm.str()`      | 返回`strm`所保存的`string`的拷贝   |
| `strm.str(s)`     | 将`s`拷贝到`strm`中，返回`void`    |

上表中`sstream`是头文件`sstream`中任意一个类型。`s`是一个`string`。

--------------

## 第8章 IO库

部分IO库设施：

- `istream`：输入流类型，提供输入操作。
- `ostream`：输出流类型，提供输出操作。
- `cin`：`istream`对象，从标准输入读取数据。
- `cout`：`ostream`对象，向标准输出写入数据。
- `cerr`：`ostream`对象，向标准错误写入数据。
- `>>`运算符：从`istream`对象读取输入数据。
- `<<`运算符：向`ostream`对象写入输出数据。
- `getline`函数：从`istream`对象读取一行数据，写入`string`对象。

### IO类（The IO Classes）

头文件`iostream`定义了用于读写流的基本类型，`fstream`定义了读写命名文件的类型，`sstream`定义了读写内存中`string`对象的类型。

![8-1](C:\Users\SEUGarfield\Desktop\Cpp-Primer-5th-Notes-CN-master\Chapter-8 The IO Library\Images\8-1.png)

宽字符版本的IO类型和函数的名字以`w`开始，如`wcin`、`wcout`和`wcerr`分别对应`cin`、`cout`和`cerr`。它们与其对应的普通`char`版本都定义在同一个头文件中，如头文件`fstream`定义了`ifstream`和`wifstream`类型。

可以将派生类的对象当作其基类的对象使用。

#### IO象无拷贝或赋值（No Copy or Assign for IO Objects）

不能拷贝或对IO对象赋值。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ofstream out1, out2;</span><br><span class="line">out1 = out2;    <span class="comment">// error: cannot assign stream objects</span></span><br><span class="line"><span class="function">ofstream <span class="title">print</span><span class="params">(ofstream)</span></span>;   <span class="comment">// error: can&#x27;t initialize the ofstream parameter</span></span><br><span class="line">out2 = <span class="built_in">print</span>(out2);     <span class="comment">// error: cannot copy stream objects</span></span><br></pre></td></tr></table></figure>

由于IO对象不能拷贝，因此不能将函数形参或返回类型定义为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是`const`的。

#### 条件状态（Condition States）

IO库条件状态：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031628813.png" alt="8-2" style="zoom:80%;" />

`badbit`表示系统级错误，如不可恢复的读写错误。通常情况下，一旦`badbit`被置位，流就无法继续使用了。在发生可恢复错误后，`failbit`会被置位，如期望读取数值却读出一个字符。如果到达文件结束位置，`eofbit`和`failbit`都会被置位。如果流未发生错误，则`goodbit`的值为0。如果`badbit`、`failbit`和`eofbit`任何一个被置位，检测流状态的条件都会失败。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    <span class="comment">// ok: read operation successful...</span></span><br></pre></td></tr></table></figure>

`good`函数在所有错误均未置位时返回`true`。而`bad`、`fail`和`eof`函数在对应错误位被置位时返回`true`。此外，在`badbit`被置位时，`fail`函数也会返回`true`。因此应该使用`good`或`fail`函数确定流的总体状态，`eof`和`bad`只能检测特定错误。

流对象的`rdstate`成员返回一个`iostate`值，表示流的当前状态。`setstate`成员用于将指定条件置位（叠加原始流状态）。`clear`成员的无参版本清除所有错误标志；含参版本接受一个`iostate`值，用于设置流的新状态（覆盖原始流状态）。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remember the current state of cin</span></span><br><span class="line"><span class="keyword">auto</span> old_state = cin.<span class="built_in">rdstate</span>();     <span class="comment">// remember the current state of cin</span></span><br><span class="line">cin.<span class="built_in">clear</span>();    <span class="comment">// make cin valid</span></span><br><span class="line"><span class="built_in">process_input</span>(cin);     <span class="comment">// use cin</span></span><br><span class="line">cin.<span class="built_in">setstate</span>(old_state);    <span class="comment">// now reset cin to its old state</span></span><br></pre></td></tr></table></figure>

#### 管理输出缓冲（Managing the Output Buffer）

每个输出流都管理一个缓冲区，用于保存程序读写的数据。导致缓冲刷新（即数据真正写入输出设备或文件）的原因有很多：

- 程序正常结束。
- 缓冲区已满。
- 使用操纵符（如`endl`）显式刷新缓冲区。
- 在每个输出操作之后，可以用`unitbuf`操纵符设置流的内部状态，从而清空缓冲区。默认情况下，对`cerr`是设置`unitbuf`的，因此写到`cerr`的内容都是立即刷新的。
- 一个输出流可以被关联到另一个流。这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下，`cin`和`cerr`都关联到`cout`，因此，读`cin`或写`cerr`都会刷新`cout`的缓冲区。

`flush`操纵符刷新缓冲区，但不输出任何额外字符。`ends`向缓冲区插入一个空字符，然后刷新缓冲区。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; endl;   <span class="comment">// writes hi and a newline, then flushes the buffer</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; flush;  <span class="comment">// writes hi, then flushes the buffer; adds no data</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; ends;   <span class="comment">// writes hi and a null, then flushes the buffer</span></span><br></pre></td></tr></table></figure>

如果想在每次输出操作后都刷新缓冲区，可以使用`unitbuf`操纵符。它令流在接下来的每次写操作后都进行一次`flush`操作。而`nounitbuf`操纵符则使流恢复使用正常的缓冲区刷新机制。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; unitbuf;    <span class="comment">// all writes will be flushed immediately</span></span><br><span class="line"><span class="comment">// any output is flushed immediately, no buffering</span></span><br><span class="line">cout &lt;&lt; nounitbuf;  <span class="comment">// returns to normal buffering</span></span><br></pre></td></tr></table></figure>

如果程序异常终止，输出缓冲区不会被刷新。

当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将`cout`和`cin`关联在一起，因此下面的语句会导致`cout`的缓冲区被刷新：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; ival;</span><br></pre></td></tr></table></figure>

交互式系统通常应该关联输入流和输出流。这意味着包括用户提示信息在内的所有输出，都会在读操作之前被打印出来。

使用`tie`函数可以关联两个流。它有两个重载版本：无参版本返回指向输出流的指针。如果本对象已关联到一个输出流，则返回的就是指向这个流的指针，否则返回空指针。`tie`的第二个版本接受一个指向`ostream`的指针，将本对象关联到此`ostream`。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">tie</span>(&amp;cout);     <span class="comment">// illustration only: the library ties cin and cout for us</span></span><br><span class="line"><span class="comment">// old_tie points to the stream (if any) currently tied to cin</span></span><br><span class="line">ostream *old_tie = cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>); <span class="comment">// cin is no longer tied</span></span><br><span class="line"><span class="comment">// ties cin and cerr; not a good idea because cin should be tied to cout</span></span><br><span class="line">cin.<span class="built_in">tie</span>(&amp;cerr);     <span class="comment">// reading cin flushes cerr, not cout</span></span><br><span class="line">cin.<span class="built_in">tie</span>(old_tie);   <span class="comment">// reestablish normal tie between cin and cout</span></span><br></pre></td></tr></table></figure>

每个流同时最多关联一个流，但多个流可以同时关联同一个`ostream`。向`tie`传递空指针可以解开流的关联。

### 文件输入输出（File Input and Output）

头文件`fstream`定义了三个类型来支持文件IO：`ifstream`从给定文件读取数据，`ofstream`向指定文件写入数据，`fstream`可以同时读写指定文件。

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031628815.png" alt="8-3" style="zoom:80%;" />

#### 使用文件流对象（Using File Stream Objects）

每个文件流类型都定义了`open`函数，它完成一些系统操作，定位指定文件，并视情况打开为读或写模式。

创建文件流对象时，如果提供了文件名（可选），`open`会被自动调用。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>;   <span class="comment">// construct an ifstream and open the given file</span></span><br><span class="line">ofstream out;   <span class="comment">// output file stream that is not associated with any file</span></span><br></pre></td></tr></table></figure>

在C++11中，文件流对象的文件名可以是`string`对象或C风格字符数组。旧版本的标准库只支持C风格字符数组。

在要求使用基类对象的地方，可以用继承类型的对象代替。因此一个接受`iostream`类型引用或指针参数的函数，可以用对应的`fstream`类型来调用。

可以先定义空文件流对象，再调用`open`函数将其与指定文件关联。如果`open`调用失败，`failbit`会被置位。

对一个已经打开的文件流调用`open`会失败，并导致`failbit`被置位。随后试图使用文件流的操作都会失败。如果想将文件流关联到另一个文件，必须先调用`close`关闭当前文件，再调用`clear`重置流的条件状态（`close`不会重置流的条件状态）。

当`fstream`对象被销毁时，`close`会自动被调用。

#### 文件模式（File Modes）

每个流都有一个关联的文件模式，用来指出如何使用文件。

<img src="C:\Users\SEUGarfield\Desktop\Cpp-Primer-5th-Notes-CN-master\Chapter-8 The IO Library\Images\8-4.png" alt="8-4" style="zoom:80%;" />

- 只能对`ofstream`或`fstream`对象设定`out`模式。
- 只能对`ifstream`或`fstream`对象设定`in`模式。
- 只有当`out`被设定时才能设定`trunc`模式。
- 只要`trunc`没被设定，就能设定`app`模式。在`app`模式下，即使没有设定`out`模式，文件也是以输出方式打开。
- 默认情况下，即使没有设定`trunc`，以`out`模式打开的文件也会被截断。如果想保留以`out`模式打开的文件内容，就必须同时设定`app`模式，这会将数据追加写到文件末尾；或者同时设定`in`模式，即同时进行读写操作。
- `ate`和`binary`模式可用于任何类型的文件流对象，并可以和其他任何模式组合使用。
- 与`ifstream`对象关联的文件默认以`in`模式打开，与`ofstream`对象关联的文件默认以`out`模式打开，与`fstream`对象关联的文件默认以`in`和`out`模式打开。

默认情况下，打开`ofstream`对象时，文件内容会被丢弃，阻止文件清空的方法是同时指定`app`或`in`模式。

流对象每次打开文件时都可以改变其文件模式。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream out;   <span class="comment">// no file mode is set</span></span><br><span class="line">out.<span class="built_in">open</span>(<span class="string">&quot;scratchpad&quot;</span>);    <span class="comment">// mode implicitly out and trunc</span></span><br><span class="line">out.<span class="built_in">close</span>();    <span class="comment">// close out so we can use it for a different file</span></span><br><span class="line">out.<span class="built_in">open</span>(<span class="string">&quot;precious&quot;</span>, ofstream::app);   <span class="comment">// mode is out and app</span></span><br><span class="line">out.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

### string流（string Streams）

头文件`sstream`定义了三个类型来支持内存IO：`istringstream`从`string`读取数据，`ostringstream`向`string`写入数据，`stringstream`可以同时读写`string`的数据。

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031628824.png" alt="8-5" style="zoom:80%;" />

#### 使用istringstream（Using an istringstream）

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// members are public by default</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersonInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string name;</span><br><span class="line">    vector&lt;string&gt; phones;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string line, word;   <span class="comment">// will hold a line and word from input, respectively</span></span><br><span class="line">vector&lt;PersonInfo&gt; people;    <span class="comment">// will hold all the records from the input</span></span><br><span class="line"><span class="comment">// read the input a line at a time until cin hits end-of-file (or another error)</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line))</span><br><span class="line">&#123;</span><br><span class="line">    PersonInfo info;    <span class="comment">// create an object to hold this record&#x27;s data</span></span><br><span class="line">    <span class="function">istringstream <span class="title">record</span><span class="params">(line)</span></span>;    <span class="comment">// bind record to the line we just read</span></span><br><span class="line">    record &gt;&gt; info.name;    <span class="comment">// read the name</span></span><br><span class="line">    <span class="keyword">while</span> (record &gt;&gt; word)  <span class="comment">// read the phone numbers</span></span><br><span class="line">        info.phones.<span class="built_in">push_back</span>(word);   <span class="comment">// and store them</span></span><br><span class="line">    people.<span class="built_in">push_back</span>(info);    <span class="comment">// append this record to people</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 使用ostringstream（Using ostringstreams）

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;entry : people)</span><br><span class="line">&#123; <span class="comment">// for each entry in people</span></span><br><span class="line">    ostringstream formatted, badNums;   <span class="comment">// objects created on each loop</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;nums : entry.phones)</span><br><span class="line">    &#123; <span class="comment">// for each number</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">valid</span>(nums))</span><br><span class="line">        &#123;</span><br><span class="line">            badNums &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; nums;  <span class="comment">// string in badNums</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// &#x27;&#x27;writes&#x27;&#x27; to formatted&#x27;s string</span></span><br><span class="line">            formatted &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; format(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (badNums.<span class="built_in">str</span>().<span class="built_in">empty</span>())   <span class="comment">// there were no bad numbers</span></span><br><span class="line">        os &lt;&lt; entry.name &lt;&lt; <span class="string">&quot; &quot;</span>  <span class="comment">// print the name</span></span><br><span class="line">            &lt;&lt; formatted.<span class="built_in">str</span>() &lt;&lt; endl;   <span class="comment">// and reformatted numbers</span></span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// otherwise, print the name and bad numbers</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;input error: &quot;</span> &lt;&lt; entry.name</span><br><span class="line">            &lt;&lt; <span class="string">&quot; invalid number(s) &quot;</span> &lt;&lt; badNums.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

-------------

## 第9章 顺序容器(简)

### 顺序容器概述

- **顺序容器**（sequential container）：为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。

#### 顺序容器类型

| 容器类型       | 介绍                                                         |
| -------------- | ------------------------------------------------------------ |
| `vector`       | 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。 |
| `deque`        | 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。    |
| `list`         | 双向链表。只支持双向顺序访问。在`list`中任何位置进行插入/删除操作速度都很快。 |
| `forward_list` | 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。 |
| `array`        | 固定大小数组。支持快速随机访问。不能添加或者删除元素。       |
| `string`       | 与`vector`相似的容器，但专门用于保存字符。随机访问块。在尾部插入/删除速度快。 |

- 除了固定大小的`array`外，其他容器都提供高效、灵活的内存管理。
- `forward_list`和`array`是新C++标准增加的类型。
- 通常使用`vector`是最好的选择，除非你有很好的理由选择其他容器。
- 新标准库的容器比旧版的快得多。

### 容器操作

#### 类型

| 操作              | 解释                                               |
| ----------------- | -------------------------------------------------- |
| `iterator`        | 此容器类型的迭代器类型                             |
| `const_iterator`  | 可以读取元素但不能修改元素的迭代器类型             |
| `size_type`       | 无符号整数类型，足够保存此种容器类型最大可能的大小 |
| `difference_type` | 带符号整数类型，足够保存两个迭代器之间的距离       |
| `value_type`      | 元素类型                                           |
| `reference`       | 元素的左值类型；和`value_type &`含义相同           |
| `const_reference` | 元素的`const`左值类型，即`const value_type &`      |

#### 构造函数

| 操作                      | 解释                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `C c;`                    | 默认构造函数，构造空容器                                     |
| `C c1(c2);`或`C c1 = c2;` | 构造`c2`的拷贝`c1`                                           |
| `C c(b, e)`               | 构造`c`，将迭代器`b`和`e`指定范围内的所有元素拷贝到`c`       |
| `C c(a, b, c...)`         | 列表初始化`c`                                                |
| `C c(n)`                  | 只支持顺序容器，且不包括`array`，包含`n`个元素，这些元素进行了值初始化 |
| `C c(n, t)`               | 包含`n`个初始值为`t`的元素                                   |

- 只有顺序容器的构造函数才接受大小参数，关联容器并不支持。
- `array`具有固定大小。
- 和其他容器不同，默认构造的`array`是非空的。
- 直接复制：将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同。
- 使用迭代器复制：不要求容器类型相同，容器内的元素类型也可以不同。

#### 赋值和`swap`

| 操作                | 解释                                                         |
| ------------------- | ------------------------------------------------------------ |
| `c1 = c2;`          | 将`c1`中的元素替换成`c2`中的元素                             |
| `c1 = &#123;a, b, c...&#125;` | 将`c1`中的元素替换成列表中的元素（不适用于`array`）          |
| `c1.swap(c2)`       | 交换`c1`和`c2`的元素                                         |
| `swap(c1, c2)`      | 等价于`c1.swap(c2)`                                          |
| `c.assign(b, e)`    | 将`c`中的元素替换成迭代器`b`和`e`表示范围中的元素，`b`和`e`不能指向`c`中的元素 |
| `c.assign(il)`      | 将`c`中的元素替换成初始化列表`il`中的元素                    |
| `c.assign(n, r)`    | 将`c`中的元素替换为`n`个值是`t`的元素                        |

- 使用非成员版本的`swap`是一个好习惯。
- `assign`操作不适用于关联容器和`array`

#### 大小

| 操作           | 解释                                           |
| -------------- | ---------------------------------------------- |
| `c.size()`     | `c`中元素的数目（不支持`forward_list`）        |
| `c.max_size()` | `c`中可保存的最大元素数目                      |
| `c.empty()`    | 若`c`中存储了元素，返回`false`，否则返回`true` |

#### 添加元素

| 操作                    | 解释                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `c.push_back(t)`        | 在`c`尾部创建一个值为`t`的元素，返回`void`                   |
| `c.emplace_back(args)`  | 同上                                                         |
| `c.push_front(t)`       | 在`c`头部创建一个值为`t`的元素，返回`void`                   |
| `c.emplace_front(args)` | 同上                                                         |
| `c.insert(p, t)`        | 在迭代器`p`指向的元素之前创建一个值是`t`的元素，返回指向新元素的迭代器 |
| `c.emplace(p, args)`    | 同上                                                         |
| `c.insert(p, n, t)`     | 在迭代器`p`指向的元素之前插入`n`个值为`t`的元素，返回指向第一个新元素的迭代器；如果`n`是0，则返回`p` |
| `c.insert(p, b, e)`     | 将迭代器`b`和`e`范围内的元素，插入到`p`指向的元素之前；如果范围为空，则返回`p` |
| `c.insert(p, il)`       | `il`是一个花括号包围中的元素值列表，将其插入到`p`指向的元素之前；如果`il`是空，则返回`p` |

- 因为这些操作会改变大小，因此不适用于`array`。
- `forward_list`有自己专有版本的`insert`和`emplace`。
- `forward_list`不支持`push_back`和`emplace_back`。
- 当我们用一个对象去初始化容器或者将对象插入到容器时，实际上放入的是对象的拷贝。
- `emplace`开头的函数是新标准引入的，这些操作是构造而不是拷贝元素。
- 传递给`emplace`的参数必须和元素类型的构造函数相匹配。

#### 访问元素

| 操作        | 解释                                                         |
| ----------- | ------------------------------------------------------------ |
| `c.back()`  | 返回`c`中尾元素的引用。若`c`为空，函数行为未定义             |
| `c.front()` | 返回`c`中头元素的引用。若`c`为空，函数行为未定义             |
| `c[n]`      | 返回`c`中下标是`n`的元素的引用，`n`时候一个无符号证书。若`n>=c.size()`，则函数行为未定义 |
| `c.at(n)`   | 返回下标为`n`的元素引用。如果下标越界，则抛出`out_of_range`异常 |

- 访问成员函数返回的是引用。
- `at`和下标操作只适用于`string`、`vector`、`deque`、`array`。
- `back`不适用于`forward_list`。
- 如果希望下标是合法的，可以使用`at`函数。

#### 删除元素

| 操作            | 解释                                                         |
| --------------- | ------------------------------------------------------------ |
| `c.pop_back()`  | 删除`c`中尾元素，若`c`为空，则函数行为未定义。函数返回`void` |
| `c.pop_front()` | 删除`c`中首元素，若`c`为空，则函数行为未定义。函数返回`void` |
| `c.erase(p)`    | 删除迭代器`p`指向的元素，返回一个指向被删除元素之后的元素的迭代器，若`p`本身是尾后迭代器，则函数行为未定义 |
| `c.erase(b, e)` | 删除迭代器`b`和`e`范围内的元素，返回指向最后一个被删元素之后元素的迭代器，若`e`本身就是尾后迭代器，则返回尾后迭代器 |
| `c.clear()`     | 删除`c`中所有元素，返回`void`                                |

- 会改变容器大小，不适用于`array`。
- `forward_list`有特殊版本的`erase`
- `forward_list`不支持`pop_back`
- `vector`和`string`不支持`pop_front`

#### 特殊的forwad_list操作

- 链表在删除元素时需要修改前置节点的内容，双向链表会前驱的指针，但是单向链表没有保存，因此需要增加获取前置节点的方法。
- `forward_list`定义了`before_begin`，即首前（off-the-begining）迭代器，允许我们再在首元素之前添加或删除元素。

| 操作                        | 解释                                                         |
| --------------------------- | ------------------------------------------------------------ |
| `lst.before_begin()`        | 返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用。 |
| `lst.cbefore_begin()`       | 同上，但是返回的是常量迭代器。                               |
| `lst.insert_after(p, t)`    | 在迭代器`p`之后插入元素。`t`是一个对象                       |
| `lst.insert_after(p, n, t)` | 在迭代器`p`之后插入元素。`t`是一个对象，`n`是数量。若`n`是0则函数行为未定义 |
| `lst.insert_after(p, b, e)` | 在迭代器`p`之后插入元素。由迭代器`b`和`e`指定范围。          |
| `lst.insert_after(p, il)`   | 在迭代器`p`之后插入元素。由`il`指定初始化列表。              |
| `emplace_after(p, args)`    | 使用`args`在`p`之后的位置，创建一个元素，返回一个指向这个新元素的迭代器。若`p`为尾后迭代器，则函数行为未定义。 |
| `lst.erase_after(p)`        | 删除`p`指向位置之后的元素，返回一个指向被删元素之后的元素的迭代器，若`p`指向`lst`的尾元素或者是一个尾后迭代器，则函数行为未定义。 |
| `lst.erase_after(b, e)`     | 类似上面，删除对象换成从`b`到`e`指定的范围。                 |

#### 改变容器大小

| 操作             | 解释                                                         |
| ---------------- | ------------------------------------------------------------ |
| `c.resize(n)`    | 调整`c`的大小为`n`个元素，若`n<c.size()`，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化 |
| `c.resize(n, t)` | 调整`c`的大小为`n`个元素，任何新添加的元素都初始化为值`t`    |

#### 获取迭代器

| 操作                     | 解释                                        |
| ------------------------ | ------------------------------------------- |
| `c.begin()`, `c.end()`   | 返回指向`c`的首元素和尾元素之后位置的迭代器 |
| `c.cbegin()`, `c.cend()` | 返回`const_iterator`                        |

- 以`c`开头的版本是C++11新标准引入的
- 当不需要写访问时，应该使用`cbegin`和`cend`。

#### 反向容器的额外成员

| 操作                       | 解释                                        |
| -------------------------- | ------------------------------------------- |
| `reverse_iterator`         | 按逆序寻址元素的迭代器                      |
| `const_reverse_iterator`   | 不能修改元素的逆序迭代器                    |
| `c.rbegin()`, `c.rend()`   | 返回指向`c`的尾元素和首元素之前位置的迭代器 |
| `c.crbegin()`, `c.crend()` | 返回`const_reverse_iterator`                |

- 不支持`forward_list`

#### 迭代器

- 迭代器范围：`begin`到`end`，即第一个元素到最后一个元素的后面一个位置。
- 左闭合区间：`[begin, end)`
- 左闭合范围蕴含的编程设定：
  - 如果`begin`和`end`相等，则范围为空。
  - 如果二者不等，则范围至少包含一个元素，且`begin`指向该范围中的第一个元素。
  - 可以对`begin`递增若干次，使得`begin == end`。

#### 容器操作可能使迭代器失效

- 在向容器添加元素后：
  - 如果容器是`vector`或`string`，且存储空间被重新分配，则指向容器的迭代器、指针、引用都会失效。
  - 对于`deque`，插入到除首尾位置之外的任何位置都会导致指向容器的迭代器、指针、引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在元素的引用和指针不会失效。
  - 对于`list`和`forward_list`，指向容器的迭代器、指针和引用依然有效。
- 在从一个容器中删除元素后：
  - 对于`list`和`forward_list`，指向容器其他位置的迭代器、引用和指针仍然有效。
  - 对于`deque`，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、指针、引用都会失效；如果是删除`deque`的尾元素，则尾后迭代器会失效，但其他不受影响；如果删除的是`deque`的头元素，这些也不会受影响。
  - 对于`vector`和`string`，指向被删元素之前的迭代器、引用、指针仍然有效。
  - 注意：当我们删除元素时，尾后迭代器总是会失效。
  - 注意：使用失效的迭代器、指针、引用是严重的运行时错误！
  - 建议：将要求迭代器必须保持有效的程序片段最小化。
  - 建议：不要保存`end`返回的迭代器。

#### 容器内元素的类型约束

- 元素类型必须支持赋值运算；
- 元素类型的对象必须可以复制。
- 除了输入输出标准库类型外，其他所有标准库类型都是有效的容器元素类型。

### vector对象是如何增长的

`vector`和`string`在内存中是连续保存的，如果原先分配的内存位置已经使用完，则需要重新分配新空间，将已有元素从就位置移动到新空间中，然后添加新元素。

#### 管理容量的成员函数

| 操作                | 解释                                          |
| ------------------- | --------------------------------------------- |
| `c.shrink_to_fit()` | 将`capacity()`减少到和`size()`相同大小        |
| `c.capacity()`      | 不重新分配内存空间的话，`c`可以保存多少个元素 |
| `c.reverse(n)`      | 分配至少能容纳`n`个元素的内存空间             |

- `shrink_to_fit`只适用于`vector`、`string`和`deque`
- `capacity`和`reverse`只适用于`vector`和`string`。

### 额外的string操作

#### 构造string的其他方法

| 操作                       | 解释                                                         |
| -------------------------- | ------------------------------------------------------------ |
| `string s(cp, n)`          | `s`是`cp`指向的数组中前`n`个字符的拷贝，此数组               |
| `string s(s2, pos2)`       | `s`是`string s2`从下标`pos2`开始的字符的拷贝。若`pos2 > s2.size()`，则构造函数的行为未定义。 |
| `string s(s2, pos2, len2)` | `s`是`string s2`从下标`pos2`开始的`len2`个字符的拷贝。       |

- `n`,`len2`,`pos2`都是无符号值。

#### substr操作

| 操作               | 解释                                                         |
| ------------------ | ------------------------------------------------------------ |
| `s.substr(pos, n)` | 返回一个`string`，包含`s`中从`pos`开始的`n`个字符的拷贝。`pos`的默认值是0，`n`的默认值是`s.size() - pos`，即拷贝从`pos`开始的所有字符。 |

#### 改变string的其他方法

| 操作                     | 解释                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `s.insert(pos, args)`    | 在`pos`之前插入`args`指定的字符。`pos`可以使是下标或者迭代器。接受下标的版本返回指向`s`的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。 |
| `s.erase(pos, len)`      | 删除从`pos`开始的`len`个字符，如果`len`被省略，则删除后面所有字符，返回指向`s`的引用。 |
| `s.assign(args)`         | 将`s`中的字符替换成`args`指定的字符。返回一个指向`s`的引用。 |
| `s.append(args)`         | 将`args`指定的字符追加到`s`，返回一个指向`s`的引用。         |
| `s.replace(range, args)` | 删除`s`中范围`range`中的字符，替换成`args`指定的字符。返回一个指向`s`的引用。 |

#### string搜索操作

- `string`类提供了6个不同的搜索函数，每个函数都有4个重载版本。
- 每个搜索操作都返回一个`string::size_type`值，表示匹配发生位置的下标。如果搜索失败则返回一个名为`string::npos`的`static`成员（类型是`string::size_type`，初始化值是-1，也就是`string`最大的可能大小）。

| 搜索操作                    | 解释                                              |
| --------------------------- | ------------------------------------------------- |
| `s.find(args)`              | 查找`s`中`args`第一次出现的位置                   |
| `s.rfind(args)`             | 查找`s`中`args`最后一次出现的位置                 |
| `s.find_first_of(args)`     | 在`s`中查找`args`中任何一个字符第一次出现的位置   |
| `s.find_last_of(args)`      | 在`s`中查找`args`中任何一个字符最后一次出现的位置 |
| `s.find_first_not_of(args)` | 在`s`中查找第一个不在`args`中的字符               |
| `s.find_first_not_of(args)` | 在`s`中查找最后一个不在`args`中的字符             |

args必须是一下的形式之一：

| `args`形式   | 解释                                                         |
| ------------ | ------------------------------------------------------------ |
| `c, pos`     | 从`s`中位置`pos`开始查找字符`c`。`pos`默认是0                |
| `s2, pos`    | 从`s`中位置`pos`开始查找字符串`s`。`pos`默认是0              |
| `cp, pos`    | 从`s`中位置`pos`开始查找指针`cp`指向的以空字符结尾的C风格字符串。`pos`默认是0 |
| `cp, pos, n` | 从`s`中位置`pos`开始查找指针`cp`指向的前`n`个字符。`pos`和`n`无默认值。 |

#### s.compare的几种参数形式

逻辑类似于C标准库的`strcmp`函数，根据`s`是等于、大于还是小于参数指定的字符串，`s.compare`返回0、正数或负数。

| 参数形式                 | 解释                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `s2`                     | 比较`s`和`s2`                                                |
| `pos1, n1, s2`           | 比较`s`从`pos1`开始的`n1`个字符和`s2`                        |
| `pos1, n1, s2, pos2, n2` | 比较`s`从`pos1`开始的`n1`个字符和`s2`                        |
| `cp`                     | 比较`s`和`cp`指向的以空字符结尾的字符数组                    |
| `pos1, n1, cp`           | 比较`s`从`pos1`开始的`n1`个字符和`cp`指向的以空字符结尾的字符数组 |
| `pos1, n1, cp, n2`       | 比较`s`从`pos1`开始的`n1`个字符和`cp`指向的地址开始`n2`个字符 |

#### string和数值转换

| 转换              | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| `to_string(val)`  | 一组重载函数，返回数值`val`的`string`表示。`val`可以使任何算术类型。对每个浮点类型和`int`或更大的整型，都有相应版本的`to_string()`。和往常一样，小整型会被提升。 |
| `stoi(s, p, b)`   | 返回`s`起始子串（表示整数内容）的数值，`p`是`s`中第一个非数值字符的下标，默认是0，`b`是转换所用的基数。返回`int` |
| `stol(s, p, b)`   | 返回`long`                                                   |
| `stoul(s, p, b)`  | 返回`unsigned long`                                          |
| `stoll(s, p, b)`  | 返回`long long`                                              |
| `stoull(s, p, b)` | 返回`unsigned long long`                                     |
| `stof(s, p)`      | 返回`s`起始子串（表示浮点数内容）的数值，`p`是`s`中第一个非数值字符的下标，默认是0。返回`float` |
| `stod(s, p)`      | 返回`double`                                                 |
| `stold(s, p)`     | 返回`long double`                                            |

### 容器适配器（adapter）

- 适配器是使一事物的行为类似于另一事物的行为的一种机制，例如`stack`可以使任何一种顺序容器以栈的方式工作。
- 初始化 `deque<int> deq; stack<int> stk(deq);` 从`deq`拷贝元素到`stk`。
- 创建适配器时，指定一个顺序容器，可以覆盖默认的基础容器： `stack<string, vector<string> > str_stk;`。

#### 适配器的通用操作和类型

| 操作             | 解释                                                         |
| ---------------- | ------------------------------------------------------------ |
| `size_type`      | 一种类型，须以保存当前类型的最大对象的大小                   |
| `value_type`     | 元素类型                                                     |
| `container_type` | 实现适配器的底层容器类型                                     |
| `A a;`           | 创建一个名为`a`的空适配器                                    |
| `A a(c)`         | 创建一个名为`a`的适配器，带有容器`c`的一个拷贝               |
| 关系运算符       | 每个适配器都支持所有关系运算符：`==`、`!=`、`<`、 `<=`、`>`、`>=`这些运算符返回底层容器的比较结果 |
| `a.empty()`      | 若`a`包含任何元素，返回`false`;否则返回`true`                |
| `a.size()`       | 返回`a`中的元素数目                                          |
| `swap(a, b)`     | 交换`a`和`b`的内容，`a`和`b`必须有相同类型，包括底层容器类型也必须相同 |
| `a.swap(b)`      | 同上                                                         |

#### stack

| 操作              | 解释                                                     |
| ----------------- | -------------------------------------------------------- |
| `s.pop()`         | 删除栈顶元素，不返回。                                   |
| `s.push(item)`    | 创建一个新元素，压入栈顶，该元素通过拷贝或移动`item`而来 |
| `s.emplace(args)` | 同上，但元素由`args`来构造。                             |
| `s.top()`         | 返回栈顶元素，不删除。                                   |

- 定义在`stack`头文件中。
- `stack`默认基于`deque`实现，也可以在`list`或`vector`之上实现。

#### queue和priority_queue

| 操作              | 解释                                      |
| ----------------- | ----------------------------------------- |
| `q.pop()`         | 删除队首元素，但不返回。                  |
| `q.front()`       | 返回队首元素的值，不删除。                |
| `q.back()`        | 返回队尾元素的值，不删除。只适用于`queue` |
| `q.top()`         | 返回具有最高优先级的元素值，不删除。      |
| `q.push(item)`    | 在队尾压入一个新元素。                    |
| `q.emplace(args)` |                                           |

- 定义在`queue`头文件中。
- `queue`默认基于`deque`实现，`priority_queue`默认基于`vector`实现。
- `queue`可以在`list`或`vector`之上实现，`priority_queue`也可以用`deque`实现。

---------

## 第9章 顺序容器

### 顺序容器概述（Overview of the Sequential Containers）

顺序容器类型：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031633805.png" alt="9-1" style="zoom:80%;" />

|      类型      |                             特性                             |
| :------------: | :----------------------------------------------------------: |
|    `vector`    | 可变大小数组。支持快速随机访问。在尾部之外的位置插入/删除元素可能很慢 |
|    `deque`     |   双端队列。支持快速随机访问。在头尾位置插入/删除速度很快    |
|     `list`     | 双向链表。只支持双向顺序访问。在任何位置插入/删除速度都很快  |
| `forward_list` | 单向链表。只支持单向顺序访问。在任何位置插入/删除速度都很快  |
|    `array`     |      固定大小数组。支持快速随机访问。不能添加/删除元素       |
|    `string`    | 类似`vector`，但用于保存字符。支持快速随机访问。在尾部插入/删除速度很快 |

`forward_list`和`array`是C++11新增类型。与内置数组相比，`array`更安全易用。`forward_list`没有`size`操作。

容器选择原则：

- 除非有合适的理由选择其他容器，否则应该使用`vector`。
- 如果程序有很多小的元素，且空间的额外开销很重要，则不要使用`list`或`forward_list`。
- 如果程序要求随机访问容器元素，则应该使用`vector`或`deque`。
- 如果程序需要在容器头尾位置插入/删除元素，但不会在中间位置操作，则应该使用`deque`。
- 如果程序只有在读取输入时才需要在容器中间位置插入元素，之后需要随机访问元素。则：
  - 先确定是否真的需要在容器中间位置插入元素。当处理输入数据时，可以先向`vector`追加数据，再调用标准库的`sort`函数重排元素，从而避免在中间位置添加元素。
  - 如果必须在中间位置插入元素，可以在输入阶段使用`list`。输入完成后将`list`中的内容拷贝到`vector`中。
- 不确定应该使用哪种容器时，可以先只使用`vector`和`list`的公共操作：使用迭代器，不使用下标操作，避免随机访问。这样在必要时选择`vector`或`list`都很方便。

### 容器库概览（Container Library Overview）

每个容器都定义在一个头文件中，文件名与类型名相同。容器均为模板类型。

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031638283.png" alt="9-2" style="zoom:80%;" />

#### 迭代器（Iterators）

`forward_list`类型不支持递减运算符`--`。

一个迭代器范围（iterator range）由一对迭代器表示。这两个迭代器通常被称为`begin`和`end`，分别指向同一个容器中的元素或尾后地址。`end`迭代器不会指向范围中的最后一个元素，而是指向尾元素之后的位置。这种元素范围被称为左闭合区间（left-inclusive interval），其标准数学描述为`[begin，end）`。迭代器`begin`和`end`必须指向相同的容器，`end`可以与`begin`指向相同的位置，但不能指向`begin`之前的位置（由程序员确保）。

假定`begin`和`end`构成一个合法的迭代器范围，则：

- 如果`begin`等于`end`，则范围为空。
- 如果`begin`不等于`end`，则范围内至少包含一个元素，且`begin`指向该范围内的第一个元素。
- 可以递增`begin`若干次，令`begin`等于`end`。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (begin != end)</span><br><span class="line">&#123;</span><br><span class="line">    *begin = val;   <span class="comment">// ok: range isn&#x27;t empty so begin denotes an element</span></span><br><span class="line">    ++begin;    <span class="comment">// advance the iterator to get the next element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 容器类型成员（Container Type Members）

通过类型别名，可以在不了解容器元素类型的情况下使用元素。如果需要元素类型，可以使用容器的`value_type`。如果需要元素类型的引用，可以使用`reference`或`const_reference`。

#### begin和end成员（begin and end Members）

`begin`和`end`操作生成指向容器中第一个元素和尾后地址的迭代器。其常见用途是形成一个包含容器中所有元素的迭代器范围。

`begin`和`end`操作有多个版本：带`r`的版本返回反向迭代器。以`c`开头的版本（C++11新增）返回`const`迭代器。不以`c`开头的版本都是重载的，当对非常量对象调用这些成员时，返回普通迭代器，对`const`对象调用时，返回`const`迭代器。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; a = &#123;<span class="string">&quot;Milton&quot;</span>, <span class="string">&quot;Shakespeare&quot;</span>, <span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it1 = a.<span class="built_in">begin</span>();    <span class="comment">// list&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = a.<span class="built_in">rbegin</span>();   <span class="comment">// list&lt;string&gt;::reverse_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = a.<span class="built_in">cbegin</span>();   <span class="comment">// list&lt;string&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it4 = a.<span class="built_in">crbegin</span>();  <span class="comment">// list&lt;string&gt;::const_reverse_iterator</span></span><br></pre></td></tr></table></figure>

当`auto`与`begin`或`end`结合使用时，返回的迭代器类型依赖于容器类型。但调用以`c`开头的版本仍然可以获得`const`迭代器，与容器是否是常量无关。

当程序不需要写操作时，应该使用`cbegin`和`cend`。

#### 容器定义和初始化（Defining and Initializing a Container）

容器定义和初始化方式：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031638961.png" alt="9-3" style="zoom:80%;" />

将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。

传递迭代器参数来拷贝一个范围时，不要求容器类型相同，而且新容器和原容器中的元素类型也可以不同，但是要能进行类型转换。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// each container has three elements, initialized from the given initializers</span></span><br><span class="line">list&lt;string&gt; authors = &#123;<span class="string">&quot;Milton&quot;</span>, <span class="string">&quot;Shakespeare&quot;</span>, <span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; articles = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">list2</span><span class="params">(authors)</span></span>;        <span class="comment">// ok: types match</span></span><br><span class="line"><span class="function">deque&lt;string&gt; <span class="title">authList</span><span class="params">(authors)</span></span>;    <span class="comment">// error: container types don&#x27;t match</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">words</span><span class="params">(articles)</span></span>;     <span class="comment">// error: element types must match</span></span><br><span class="line"><span class="comment">// ok: converts const char* elements to string</span></span><br><span class="line"><span class="function">forward_list&lt;string&gt; <span class="title">words</span><span class="params">(articles.begin(), articles.end())</span></span>;</span><br></pre></td></tr></table></figure>

C++11允许对容器进行列表初始化。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// each container has three elements, initialized from the given initializers</span></span><br><span class="line">list&lt;string&gt; authors = &#123;<span class="string">&quot;Milton&quot;</span>, <span class="string">&quot;Shakespeare&quot;</span>, <span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; articles = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

定义和使用`array`类型时，需要同时指定元素类型和容器大小。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="keyword">int</span>, 42&gt;      <span class="comment">// type is: array that holds 42 ints</span></span><br><span class="line">array&lt;string, 10&gt;   <span class="comment">// type is: array that holds 10 strings</span></span><br><span class="line">array&lt;<span class="keyword">int</span>, 10&gt;::size_type i;   <span class="comment">// array type includes element type and size</span></span><br><span class="line">array&lt;<span class="keyword">int</span>&gt;::size_type j;       <span class="comment">// error: array&lt;int&gt; is not a type</span></span><br></pre></td></tr></table></figure>

对`array`进行列表初始化时，初始值的数量不能大于`array`的大小。如果初始值的数量小于`array`的大小，则只初始化靠前的元素，剩余元素会被值初始化。如果元素类型是类类型，则该类需要一个默认构造函数。

可以对`array`进行拷贝或赋值操作，但要求二者的元素类型和大小都相同。

#### 赋值和swap（Assignment and swap）

容器赋值操作：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031633817.png" alt="9-4" style="zoom:80%;" />

赋值运算符两侧的运算对象必须类型相同。`assign`允许用不同但相容的类型赋值，或者用容器的子序列赋值。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; names;</span><br><span class="line">vector&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; oldstyle;</span><br><span class="line">names = oldstyle;   <span class="comment">// error: container types don&#x27;t match</span></span><br><span class="line"><span class="comment">// ok: can convert from const char*to string</span></span><br><span class="line">names.<span class="built_in">assign</span>(oldstyle.<span class="built_in">cbegin</span>(), oldstyle.<span class="built_in">cend</span>());</span><br></pre></td></tr></table></figure>

由于其旧元素被替换，因此传递给`assign`的迭代器不能指向调用`assign`的容器本身。

`swap`交换两个相同类型容器的内容。除`array`外，`swap`不对任何元素进行拷贝、删除或插入操作，只交换两个容器的内部数据结构，因此可以保证快速完成。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec1</span><span class="params">(<span class="number">10</span>)</span></span>;   <span class="comment">// vector with ten elements</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec2</span><span class="params">(<span class="number">24</span>)</span></span>;   <span class="comment">// vector with 24 elements</span></span><br><span class="line"><span class="built_in">swap</span>(svec1, svec2);</span><br></pre></td></tr></table></figure>

赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而`swap`操作交换容器内容，不会导致迭代器、引用和指针失效（`array`和`string`除外）。

对于`array`，`swap`会真正交换它们的元素。因此在`swap`操作后，指针、引用和迭代器所绑定的元素不变，但元素值已经被交换。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="keyword">int</span>, 3&gt; a = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">array&lt;<span class="keyword">int</span>, 3&gt; b = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> p = a.<span class="built_in">cbegin</span>(), q = a.<span class="built_in">cend</span>();</span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line"><span class="comment">// 输出交换后的值，即4、5、6</span></span><br><span class="line"><span class="keyword">while</span> (p != q)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    ++p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

对于其他容器类型（除`string`），指针、引用和迭代器在`swap`操作后仍指向操作前的元素，但这些元素已经属于不同的容器了。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; a = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; b = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> p = a.<span class="built_in">cbegin</span>(), q = a.<span class="built_in">cend</span>();</span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line"><span class="comment">// 输出交换前的值，即1、2、3</span></span><br><span class="line"><span class="keyword">while</span> (p != q)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    ++p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

`array`不支持`assign`，也不允许用花括号列表进行赋值。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="keyword">int</span>, 10&gt; a1 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">array&lt;<span class="keyword">int</span>, 10&gt; a2 = &#123;<span class="number">0</span>&#125;;    <span class="comment">// elements all have value 0</span></span><br><span class="line">a1 = a2;    <span class="comment">// replaces elements in a1</span></span><br><span class="line">a2 = &#123;<span class="number">0</span>&#125;;   <span class="comment">// error: cannot assign to an array from a braced list</span></span><br></pre></td></tr></table></figure>

新标准库同时提供了成员和非成员函数版本的`swap`。非成员版本的`swap`在泛型编程中非常重要，建议统一使用非成员版本的`swap`。

#### 容器大小操作（Container Size Operations）

`size`成员返回容器中元素的数量；`empty`当`size`为0时返回`true`，否则返回`false`；`max_size`返回一个大于或等于该类型容器所能容纳的最大元素数量的值。`forward_list`支持`max_size`和`empty`，但不支持`size`。

#### 关系运算符（Relational Operators）

每个容器类型都支持相等运算符（`==`、`!=`）。除无序关联容器外，其他容器都支持关系运算符（`>`、`>=`、`<`、`<=`）。关系运算符两侧的容器类型和保存元素类型都必须相同。

两个容器的比较实际上是元素的逐对比较，其工作方式与`string`的关系运算符类似：

- 如果两个容器大小相同且所有元素对应相等，则这两个容器相等。
- 如果两个容器大小不同，但较小容器中的每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。
- 如果两个容器都不是对方的前缀子序列，则两个容器的比较结果取决于第一个不等元素的比较结果。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1 = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span> &#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2 = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v3 = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span> &#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v4 = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span> &#125;;</span><br><span class="line">v1 &lt; v2     <span class="comment">// true; v1 and v2 differ at element [2]: v1[2] is less than v2[2]</span></span><br><span class="line">v1 &lt; v3     <span class="comment">// false; all elements are equal, but v3 has fewer of them;</span></span><br><span class="line">v1 == v4    <span class="comment">// true; each element is equal and v1 and v4 have the same size()</span></span><br><span class="line">v1 == v2    <span class="comment">// false; v2 has fewer elements than v1</span></span><br></pre></td></tr></table></figure>

容器的相等运算符实际上是使用元素的`==`运算符实现的，而其他关系运算符则是使用元素的`<`运算符。如果元素类型不支持所需运算符，则保存该元素的容器就不能使用相应的关系运算。

### 顺序容器操作（Sequential Container Operations）

#### 向顺序容器添加元素（Adding Elements to a Sequential Container）

除`array`外，所有标准库容器都提供灵活的内存管理，在运行时可以动态添加或删除元素。

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031633821.png" alt="9-5" style="zoom:80%;" />

`push_back`将一个元素追加到容器尾部，`push_front`将元素插入容器头部。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read from standard input, putting each word onto the end of container</span></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    container.<span class="built_in">push_back</span>(word);</span><br></pre></td></tr></table></figure>

`insert`将元素插入到迭代器指定的位置之前。一些不支持`push_front`的容器可以使用`insert`将元素插入开始位置。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">list&lt;string&gt; slist;</span><br><span class="line"><span class="comment">// equivalent to calling slist.push_front(&quot;Hello!&quot;);</span></span><br><span class="line">slist.<span class="built_in">insert</span>(slist.<span class="built_in">begin</span>(), <span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line"><span class="comment">// no push_front on vector but we can insert before begin()</span></span><br><span class="line"><span class="comment">// warning: inserting anywhere but at the end of a vector might be slow</span></span><br><span class="line">svec.<span class="built_in">insert</span>(svec.<span class="built_in">begin</span>(), <span class="string">&quot;Hello!&quot;</span>);</span><br></pre></td></tr></table></figure>

将元素插入到`vector`、`deque`或`string`的任何位置都是合法的，但可能会很耗时。

在新标准库中，接受元素个数或范围的`insert`版本返回指向第一个新增元素的迭代器，而旧版本中这些操作返回`void`。如果范围为空，不插入任何元素，`insert`会返回第一个参数。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; <span class="number">1</span>st;</span><br><span class="line"><span class="keyword">auto</span> iter = <span class="number">1</span>st.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    iter = <span class="number">1</span>st.<span class="built_in">insert</span>(iter, word);  <span class="comment">// same as calling push_front</span></span><br></pre></td></tr></table></figure>

新标准库增加了三个直接构造而不是拷贝元素的操作：`emplace_front`、`emplace_back`和`emplace`，其分别对应`push_front`、`push_back`和`insert`。当调用`push`或`insert`时，元素对象被拷贝到容器中。而调用`emplace`时，则是将参数传递给元素类型的构造函数，直接在容器的内存空间中构造元素。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// construct a Sales_data object at the end of c</span></span><br><span class="line"><span class="comment">// uses the three-argument Sales_data constructor</span></span><br><span class="line">c.<span class="built_in">emplace_back</span>(<span class="string">&quot;978-0590353403&quot;</span>, <span class="number">25</span>, <span class="number">15.99</span>);</span><br><span class="line"><span class="comment">// error: there is no version of push_back that takes three arguments</span></span><br><span class="line">c.<span class="built_in">push_back</span>(<span class="string">&quot;978-0590353403&quot;</span>, <span class="number">25</span>, <span class="number">15.99</span>);</span><br><span class="line"><span class="comment">// ok: we create a temporary Sales_data object to pass to push_back</span></span><br><span class="line">c.<span class="built_in">push_back</span>(<span class="built_in">Sales_data</span>(<span class="string">&quot;978-0590353403&quot;</span>, <span class="number">25</span>, <span class="number">15.99</span>));</span><br></pre></td></tr></table></figure>

传递给`emplace`的参数必须与元素类型的构造函数相匹配。

`forward_list`有特殊版本的`insert`和`emplace`操作，且不支持`push_back`和`emplace_back`。`vector`和`string`不支持`push_front`和`emplace_front`。

#### 访问元素（Accessing Elements）

每个顺序容器都有一个`front`成员函数，而除了`forward_list`之外的顺序容器还有一个`back`成员函数。这两个操作分别返回首元素和尾元素的引用。

在调用`front`和`back`之前，要确保容器非空。

顺序容器的元素访问操作：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031633819.png" alt="9-6" style="zoom:80%;" />

在容器中访问元素的成员函数都返回引用类型。如果容器是`const`对象，则返回`const`引用，否则返回普通引用。

可以快速随机访问的容器（`string`、`vector`、`deque`和`array`）都提供下标运算符。保证下标有效是程序员的责任。如果希望确保下标合法，可以使用`at`成员函数。`at`类似下标运算，但如果下标越界，`at`会抛出`out_of_range`异常。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec;  <span class="comment">// empty vector</span></span><br><span class="line">cout &lt;&lt; svec[<span class="number">0</span>];      <span class="comment">// run-time error: there are no elements in svec!</span></span><br><span class="line">cout &lt;&lt; svec.<span class="built_in">at</span>(<span class="number">0</span>);   <span class="comment">// throws an out_of_range exception</span></span><br></pre></td></tr></table></figure>

#### 删除元素（Erasing Elements）

顺序容器的元素删除操作：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031638154.png" alt="9-7" style="zoom:80%;" />

删除`deque`中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效。删除`vector`或`string`的元素后，指向删除点之后位置的迭代器、引用和指针也都会失效。

删除元素前，程序员必须确保目标元素存在。

`pop_front`和`pop_back`函数分别删除首元素和尾元素。`vector`和`string`类型不支持`pop_front`，`forward_list`类型不支持`pop_back`。

`erase`函数删除指定位置的元素。可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定的范围内的所有元素。两种形式的`erase`都返回指向删除元素（最后一个）之后位置的迭代器。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delete the range of elements between two iterators</span></span><br><span class="line"><span class="comment">// returns an iterator to the element just after the last removed element</span></span><br><span class="line">elem1 = slist.<span class="built_in">erase</span>(elem1, elem2);  <span class="comment">// after the call elem1 == elem2</span></span><br></pre></td></tr></table></figure>

`clear`函数删除容器内的所有元素。

#### 特殊的forward_list操作（Specialized forward_list Operations）

在`forward_list`中添加或删除元素的操作是通过改变给定元素之后的元素来完成的。

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031638675.png" alt="9-8" style="zoom:80%;" />

`forward_list`的插入和删除操作：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031633227.png" alt="9-9" style="zoom:80%;" />

#### 改变容器大小（Resizing a Container）

顺序容器的大小操作：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031638183.png" alt="9-10" style="zoom:80%;" />

`resize`函数接受一个可选的元素值参数，用来初始化添加到容器中的元素，否则新元素进行值初始化。如果容器保存的是类类型元素，且`resize`向容器添加新元素，则必须提供初始值，或元素类型提供默认构造函数。

#### 容器操作可能使迭代器失效（Container Operations May Invalidate Iterators）

向容器中添加或删除元素可能会使指向容器元素的指针、引用或迭代器失效。失效的指针、引用或迭代器不再表示任何元素，使用它们是一种严重的程序设计错误。

- 向容器中添加元素后：
  - 如果容器是`vector`或`string`类型，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前元素的迭代器、指针和引用仍然有效，但指向插入位置之后元素的迭代器、指针和引用都会失效。
  - 如果容器是`deque`类型，添加到除首尾之外的任何位置都会使迭代器、指针和引用失效。如果添加到首尾位置，则迭代器会失效，而指针和引用不会失效。
  - 如果容器是`list`或`forward_list`类型，指向容器的迭代器、指针和引用仍然有效。
- 从容器中删除元素后，指向被删除元素的迭代器、指针和引用失效：
  - 如果容器是`list`或`forward_list`类型，指向容器其他位置的迭代器、指针和引用仍然有效。
  - 如果容器是`deque`类型，删除除首尾之外的任何元素都会使迭代器、指针和引用失效。如果删除尾元素，则尾后迭代器失效，其他迭代器、指针和引用不受影响。如果删除首元素，这些也不会受影响。
  - 如果容器是`vector`或`string`类型，指向删除位置之前元素的迭代器、指针和引用仍然有效。但尾后迭代器总会失效。

必须保证在每次改变容器后都正确地重新定位迭代器。

不要保存`end`函数返回的迭代器。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// safer: recalculate end on each trip whenever the loop adds/erases elements</span></span><br><span class="line"><span class="keyword">while</span> (begin != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do some processing</span></span><br><span class="line">    ++begin;    <span class="comment">// advance begin because we want to insert after this element</span></span><br><span class="line">    begin = v.<span class="built_in">insert</span>(begin, <span class="number">42</span>);    <span class="comment">// insert the new value</span></span><br><span class="line">    ++begin;    <span class="comment">// advance begin past the element we just added</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### vector对象是如何增长的（How a vector Grows）

`vector`和`string`的实现通常会分配比新空间需求更大的内存空间，容器预留这些空间作为备用，可用来保存更多新元素。

容器大小管理操作：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031633247.png" alt="9-11" style="zoom:80%;" />

`capacity`函数返回容器在不扩充内存空间的情况下最多可以容纳的元素数量。`reserve`函数告知容器应该准备保存多少元素，它并不改变容器中元素的数量，仅影响容器预先分配的内存空间大小。

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031637901.png" alt="9-12" style="zoom:80%;" />

只有当需要的内存空间超过当前容量时，`reserve`才会真正改变容器容量，分配不小于需求大小的内存空间。当需求大小小于当前容量时，`reserve`并不会退回内存空间。因此在调用`reserve`之后，`capacity`会大于或等于传递给`reserve`的参数。

在C++11中可以使用`shrink_to_fit`函数来要求`deque`、`vector`和`string`退回不需要的内存空间（并不保证退回）。

### 额外的string操作（Additional string Operations）

#### 构造string的其他方法（Other Ways to Construct strings）

构造`string`的其他方法：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031633625.png" alt="9-13" style="zoom:80%;" />

从另一个`string`对象拷贝字符构造`string`时，如果提供的拷贝开始位置（可选）大于给定`string`的大小，则构造函数会抛出`out_of_range`异常。

子字符串操作：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031633975.png" alt="9-14" style="zoom:80%;" />

如果传递给`substr`函数的开始位置超过`string`的大小，则函数会抛出`out_of_range`异常。

#### 改变string的其他方法（Other Ways to Change a string）

修改`string`的操作：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031633987.png" alt="9-15" style="zoom:80%;" />

`append`函数是在`string`末尾进行插入操作的简写形式。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;C++ Primer&quot;</span>)</span>, s2 </span>= s;     <span class="comment">// initialize s and s2 to &quot;C++ Primer&quot;</span></span><br><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">size</span>(), <span class="string">&quot; 4th Ed.&quot;</span>);     <span class="comment">// s == &quot;C++ Primer 4th Ed.&quot;</span></span><br><span class="line">s2.<span class="built_in">append</span>(<span class="string">&quot; 4th Ed.&quot;</span>);     <span class="comment">// equivalent: appends &quot; 4th Ed.&quot; to s2; s == s2</span></span><br></pre></td></tr></table></figure>

`replace`函数是调用`erase`和`insert`函数的简写形式。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equivalent way to replace &quot;4th&quot; by &quot;5th&quot;</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">11</span>, <span class="number">3</span>);         <span class="comment">// s == &quot;C++ Primer Ed.&quot;</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">11</span>, <span class="string">&quot;5th&quot;</span>);    <span class="comment">// s == &quot;C++ Primer 5th Ed.&quot;</span></span><br><span class="line"><span class="comment">// starting at position 11, erase three characters and then insert &quot;5th&quot;</span></span><br><span class="line">s2.<span class="built_in">replace</span>(<span class="number">11</span>, <span class="number">3</span>, <span class="string">&quot;5th&quot;</span>);   <span class="comment">// equivalent: s == s2</span></span><br></pre></td></tr></table></figure>

#### string搜索操作（string Search Operations）

`string`的每个搜索操作都返回一个`string::size_type`值，表示匹配位置的下标。如果搜索失败，则返回一个名为`string::npos`的`static`成员。标准库将`npos`定义为`const string::size_type`类型，并初始化为-1。

不建议用`int`或其他带符号类型来保存`string`搜索函数的返回值。

`string`搜索操作：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031637929.png" alt="9-16" style="zoom:80%;" />

#### compare函数（The compare Functions）

`string`类型提供了一组`compare`函数进行字符串比较操作，类似C标准库的`strcmp`函数。

`compare`函数的几种参数形式：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031633260.png" alt="9-17" style="zoom:80%;" />

#### 数值转换（Numeric Conversions）

C++11增加了`string`和数值之间的转换函数：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031637299.png" alt="9-18" style="zoom:80%;" />

进行数值转换时，`string`参数的第一个非空白字符必须是符号（`+`或`-`）或数字。它可以以`0x`或`0X`开头来表示十六进制数。对于转换目标是浮点值的函数，`string`参数也可以以小数点开头，并可以包含`e`或`E`来表示指数部分。

如果给定的`string`不能转换为一个数值，则转换函数会抛出`invalid_argument`异常。如果转换得到的数值无法用任何类型表示，则抛出`out_of_range`异常。

### 容器适配器（Container Adaptors）

标准库定义了`stack`、`queue`和`priority_queue`三种容器适配器。容器适配器可以改变已有容器的工作机制。

所有容器适配器都支持的操作和类型：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031633575.png" alt="9-19" style="zoom:80%;" />

默认情况下，`stack`和`queue`是基于`deque`实现的，`priority_queue`是基于`vector`实现的。可以在创建适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// empty stack implemented on top of vector</span></span><br><span class="line">stack&lt;string, vector&lt;string&gt;&gt; str_stk;</span><br><span class="line"><span class="comment">// str_stk2 is implemented on top of vector and initially holds a copy of svec</span></span><br><span class="line">stack&lt;string, vector&lt;string&gt;&gt; <span class="built_in">str_stk2</span>(svec);</span><br></pre></td></tr></table></figure>

所有适配器都要求容器具有添加和删除元素的能力，因此适配器不能构造在`array`上。适配器还要求容器具有添加、删除和访问尾元素的能力，因此也不能用`forward_list`构造适配器。

栈适配器`stack`定义在头文件`stack`中，其支持的操作如下：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031637709.png" alt="9-20" style="zoom:80%;" />

队列适配器`queue`和`priority_queue`定义在头文件`queue`中，其支持的操作如下：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031633912.png" alt="9-21" style="zoom:80%;" />

`queue`使用先进先出（first-in，first-out，FIFO）的存储和访问策略。进入队列的对象被放置到队尾，而离开队列的对象则从队首删除。

------------



## 第10章 泛型算法（简）

### 泛型算法

- 因为它们实现共同的操作，所以称之为“**算法**”；而“**泛型**”、指的是它们可以操作在多种容器类型上。
- 泛型算法本身不执行容器操作，只是单独依赖迭代器和迭代器操作实现。
- 头文件： `#include <algorithm>`或者 `#include <numeric>`(算数相关)
- 大多数算法是通过遍历两个迭代器标记的一段元素来实现其功能。
- 必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但不能直接添加或者删除元素。

#### find

- `vector<int>::const_iterator result = find(vec.begin(), vec.end(), search_value);`
- 输入：两个标记范围的迭代器和目标查找值。返回：如果找到，返回对应的迭代器，否则返回第二个参数，即标记结尾的迭代器。

### 初识泛型算法

- 标准库提供了超过100个算法，但这些算法有一致的结构。
- 理解算法的最基本的方法是了解它们是否读取元素、改变元素、重排元素顺序。

#### 只读算法

- 只读取范围中的元素，不改变元素。
- 如 `find`和 `accumulate`（在`numeric`中定义，求和）。
- `find_first_of`，输入：两对迭代器标记两段范围，在第一段中找第二段中任意元素，返回第一个匹配的元素，找不到返回第一段的`end`迭代器。
- 通常最好使用`cbegin`和`cend`。
- `equal`：确定两个序列是否保存相同的值。

#### 写容器元素的算法

- 一些算法将新值赋予序列中的元素。
- 算法不检查写操作。
- `fill`： `fill(vec.begin(), vec.end(), 0);` 将每个元素重置为0
- `fill_n`： `fill_n(vec.begin(), 10, 0);`
- 插入迭代器`back_inserter`：
  - 用来确保算法有足够的空间存储数据。
  - `#include <iterator>`
  - `back_inserter(vec)`
- 拷贝算法`copy`：
- 输入：前两个参数指定输入范围，第三个指向目标序列。
- `copy (ilst.begin(), ilst.end(), back_inserter(ivec));`
- `copy`时必须保证目标目的序列至少要包含与输入序列一样多的元素。

#### 重排容器元素的算法

- 这些算法会重排容器中元素的顺序。
- 排序算法`sort`：
  - 接受两个迭代器，表示要排序的元素范围。
- 消除重复`unique`：
  - 之前要先调用`sort`
  - 返回的迭代器指向最后一个不重复元素之后的位置。
  - 顺序会变，重复的元素被“删除”。
  - 并没有真正删除，真正删除必须使用容器操作。

### 定制操作

#### 向算法传递函数：

- 谓词（`predicate`）：
  - 是一个**可调用的表达式**，返回结果是一个能用作条件的值
  - 一元谓词：接受一个参数
  - 二元谓词：接受两个参数

- 例子：
  - `stable_sort`：
    - 保留相等元素的原始相对位置。
    - `stable_sort(words.begin(), words.end(), isShorter);`

#### lambda表达式

- 有时可能希望操作可以接受更多的参数。
- `lambda`表达式表示一个可调用的代码单元，可以理解成是一个未命名的内联函数。
- 形式：`[capture list](parameter list) -> return type &#123;function body&#125;`。
  - 其中`capture list`捕获列表是一个`lambda`所在函数定义的局部变量的列表（通常为空）。不可忽略。
  - `return type`是返回类型。可忽略。
  - `parameter`是参数列表。可忽略。
  - `function body`是函数体。不可忽略。
  - `auto f = [] &#123;return 42;&#125;`

- 例子：
  - `find_if`:
    - 接受一对表示范围的迭代器和一个谓词，用来查找第一个满足特定要求的元素。返回第一个使谓词返回非0值的元素。
    - `auto wc = find_if(words.begin(), words.end(), [sz](const string &a)&#123;return a.size() >= sz;&#125;);`
  - `for_each`：
    - 接受一个可调用对象，并对序列中每个元素调用此对象。
    - `for_each(wc, words.end(), [](const string &s)&#123;cout << s << " ";&#125;)`

#### lambda捕获和返回

- 定义`lambda`时会生成一个新的类类型和该类型的一个对象。
- 默认情况下，从`lambda`生成的类都包含一个对应该`lambda`所捕获的变量的数据成员，在`lambda`对象创建时被初始化。
- **值捕获**：前提是变量可以拷贝，`size_t v1 = 42; auto f = [v1] &#123;return v1;&#125;;`。
- **引用捕获**：必须保证在`lambda`执行时，变量是存在的，`auto f2 = [&v1] &#123;return v1;&#125;;`
- 尽量减少捕获的数据量，尽可能避免捕获指针或引用。
- **隐式捕获**：让编译器推断捕获列表，在捕获列表中写一个`&`（引用方式）或`=`（值方式）。`auto f3 = [=] &#123;return v1;&#125;`

**lambda捕获列表**：

| 捕获列表               | 解释                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `[]`                   | 空捕获列表。`lambda`不能使用所在函数中的变量。一个`lambda`只有在捕获变量后才能使用它们。 |
| `[names]`              | `names`是一个逗号分隔的名字列表，这些名字都是在`lambda`所在函数的局部变量，捕获列表中的变量都被拷贝，名字前如果使用了`&`，则采用引用捕获方式。 |
| `[&]`                  | 隐式捕获列表，采用引用捕获方式。`lambda`体中所使用的来自所在函数的实体都采用引用方式使用。 |
| `[=]`                  | 隐式捕获列表，采用值捕获方式。                               |
| `[&, identifier_list]` | `identifier_list`是一个逗号分隔的列表，包含0个或多个来自所在函数的变量。这些变量采用值捕获方式，而任何隐式捕获的变量都采用引用方式捕获。`identifier_list`中的名字前面不能使用`&` |
| `[=, identifier_list]` | `identifier_list`中的变量采用引用方式捕获，而任何隐式捕获的变量都采用值方式捕获。`identifier_list`中的名字不能包括`this`，且前面必须使用`&` |

#### 参数绑定

- `lambda`表达式更适合在一两个地方使用的简单操作。
- 如果是很多地方使用相同的操作，还是需要定义函数。
- 函数如何包装成一元谓词？使用参数绑定。
- 标准库`bind`函数：
  - 定义在头文件`functional`中，可以看做为一个通用的函数适配器。
  - `auto newCallable = bind(callable, arg_list);`
  - 我们再调用`newCallable`的时候，`newCallable`会调用`callable`并传递给它`arg_list`中的参数。
  - `_n`代表第n个位置的参数。定义在`placeholders`的命名空间中。`using std::placeholder::_1;`
  - `auto g = bind(f, a, b, _2, c, _1);`，调用`g(_1, _2)`实际上调用`f(a, b, _2, c, _1)`
  - 非占位符的参数要使用引用传参，必须使用标准库`ref`函数或者`cref`函数。

### 再探迭代器

#### 插入迭代器

- 插入器是一种迭代器适配器，接受一个容器，生成一个迭代器，能实现向给定容器添加元素。
- 三种类型：
  - `back_inserter`：创建一个使用`push_back`的迭代器。
  - `front_inserter`创建一个使用`push_front`的迭代器。
  - `inserter`创建一个使用`insert`的迭代器。接受第二个参数，即一个指向给定容器的迭代器，元素会被查到迭代器所指向的元素之前。

**插入迭代器操作**：

| 操作              | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| `it=t`            | 在`it`指定的当前位置插入值`t`。假定`c`是`it`绑定的容器，依赖于插入迭代器的不同种类，此赋值会分别调用`c.push_back(t)`、`c.push_front(t)`、`c.insert(t, p)`，其中`p`是传递给`inserter`的迭代器位置 |
| `*it, ++it, it++` | 这些操作虽然存在，但不会对`it`做任何事情，每个操作都返回`it` |

#### iostream迭代器

- 迭代器可与输入或输出流绑定在一起，用于迭代遍历所关联的 IO 流。
- 通过使用流迭代器，我们可以用泛型算法从流对象中读取数据以及向其写入数据。

**istream_iterator的操作**：

| 操作                          | 解释                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| `istream_iterator<T> in(is);` | `in`从输入流`is`读取类型为`T`的值                            |
| `istream_iterator<T> end;`    | 读取类型是`T`的值的`istream_iterator`迭代器，表示尾后位置    |
| `in1 == in2`                  | `in1`和`in2`必须读取相同类型。如果他们都是尾后迭代器，或绑定到相同的输入，则两者相等。 |
| `in1 != in2`                  | 类似上条                                                     |
| `*in`                         | 返回从流中读取的值                                           |
| `in->mem`                     | 与`*(in).mem`含义相同                                        |
| `++in, in++`                  | 使用元素类型所定义的`>>`运算符从流中读取下一个值。前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值。 |

**ostream_iterator的操作**：

| 操作                              | 解释                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| `ostream_iterator<T> out(os);`    | `out`将类型为`T`的值写到输出流`os`中                         |
| `ostream_iterator<T> out(os, d);` | `out`将类型为`T`的值写到输出流`os`中，每个值后面都输出一个`d`。`d`指向一个空字符结尾的字符数组。 |
| `out = val`                       | 用`<<`运算符将`val`写入到`out`所绑定的`ostream`中。`val`的类型必须和`out`可写的类型兼容。 |
| `*out, ++out, out++`              | 这些运算符是存在的，但不对`out`做任何事情。每个运算符都返回`out`。 |

#### 反向迭代器

- 反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。
- 对于反向迭代器，递增和递减的操作含义会颠倒。
- 实现向后遍历，配合`rbegin`和`rend`。

### 泛型算法结构

#### 5类迭代器

| 迭代器类别     | 解释                                 | 支持的操作                                                   |
| -------------- | ------------------------------------ | ------------------------------------------------------------ |
| 输入迭代器     | 只读，不写；单遍扫描，只能递增       | `==`,`!=`,`++`,`*`,`->`                                      |
| 输出迭代器     | 只写，不读；单遍扫描，只能递增       | `++`,`*`                                                     |
| 前向迭代器     | 可读写；多遍扫描，只能递增           | `==`,`!=`,`++`,`*`,`->`                                      |
| 双向迭代器     | 可读写；多遍扫描，可递增递减         | `==`,`!=`,`++`,`--`,`*`,`->`                                 |
| 随机访问迭代器 | 可读写，多遍扫描，支持全部迭代器运算 | `==`,`!=`,`<`,`<=`,`>`,`>=`,`++`,`--`,`+`,`+=`,`-`,`-=`,`*`,`->`,`iter[n]`==`*(iter[n])` |

#### 算法的形参模式

- `alg(beg, end, other args);`
- `alg(beg, end, dest, other args);`
- `alg(beg, end, beg2, other args);`
- `alg(beg, end, beg2, end2, other args);`

其中，`alg`是算法名称，`beg`和`end`表示算法所操作的输入范围。`dest`、`beg2`、`end2`都是迭代器参数，是否使用要依赖于执行的操作。

#### 算法命名规范

- 一些算法使用重载形式传递一个谓词。
- 接受一个元素值的算法通常有一个**不同名**的版本：加`_if`，接受一个谓词代替元素值。
- 区分拷贝元素的版本和不拷贝的版本：拷贝版本通常加`_copy`。

### 特定容器算法

- 对于`list`和`forward_list`，优先使用成员函数版本的算法而不是通用算法。

**list和forward_list成员函数版本的算法**：

| 操作                    | 解释                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `lst.merge(lst2)`       | 将来自`lst2`的元素合并入`lst`，二者都必须是有序的，元素将从`lst2`中删除。 |
| `lst.merge(lst2, comp)` | 同上，给定比较操作。                                         |
| `lst.remove(val)`       | 调用`erase`删除掉与给定值相等(==)的每个元素                  |
| `lst.remove_if(pred)`   | 调用`erase`删除掉令一元谓词为真的每个元素                    |
| `lst.reverse()`         | 反转`lst`中元素的顺序                                        |
| `lst.sort()`            | 使用`<`排序元素                                              |
| `lst.sort(comp)`        | 使用给定比较操作排序元素                                     |
| `lst.unique()`          | 调用`erase`删除同一个值的连续拷贝。使用`==`。                |
| `lst.unique(pred)`      | 调用`erase`删除同一个值的连续拷贝。使用给定的二元谓词。      |

- 上面的操作都返回`void`

**list和forward_list的splice成员函数版本的参数**：

| 参数              | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| `(p, lst2)`       | `p`是一个指向`lst`中元素的迭代器，或者一个指向`flst`首前位置的迭代器。函数将`lst2`中的所有元素移动到`lst`中`p`之前的位置或是`flst`中`p`之后的位置。将元素从`lst2`中删除。`lst2`的类型必须和`lst`相同，而且不能是同一个链表。 |
| `(p, lst2, p2)`   | 同上，`p2`是一个指向`lst2`中位置的有效的迭代器，将`p2`指向的元素移动到`lst`中，或将`p2`之后的元素移动到`flst`中。`lst2`可以是于`lst`或`flst`相同的链表。 |
| `(p, lst2, b, e)` | `b`和`e`表示`lst2`中的合法范围。将给定范围中的元素从`lst2`移动到`lst`或`first`中。`lst2`与`lst`可以使相同的链表，但`p`不能指向给定范围中的元素。 |

- 使用`lst.splice(args)`或`flst.splice_after(args)`



--------------

## 第10章 泛型算法

### 概述（Overview）

大多数算法都定义在头文件`algorithm`中，此外标准库还在头文件`numeric`中定义了一组数值泛型算法。一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的元素范围进行操作。

`find`函数将范围中的每个元素与给定值进行比较，返回指向第一个等于给定值的元素的迭代器。如果无匹配元素，则返回其第二个参数来表示搜索失败。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">42</span>;   <span class="comment">// value we&#x27;ll look for</span></span><br><span class="line"><span class="comment">// result will denote the element we want if it&#x27;s in vec, or vec.cend() if not</span></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">find</span>(vec.<span class="built_in">cbegin</span>(), vec.<span class="built_in">cend</span>(), val);</span><br><span class="line"><span class="comment">// report the result</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The value &quot;</span> &lt;&lt; val</span><br><span class="line">    &lt;&lt; (result == vec.<span class="built_in">cend</span>() ? <span class="string">&quot; is not present&quot;</span> : <span class="string">&quot; is present&quot;</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

迭代器参数令算法不依赖于特定容器，但依赖于元素类型操作。

泛型算法本身不会执行容器操作，它们只会运行于迭代器之上，执行迭代器操作。算法可能改变容器中元素的值，或者在容器内移动元素，但不会改变底层容器的大小（当算法操作插入迭代器时，迭代器可以向容器中添加元素，但算法自身不会进行这种操作）。

### 初识泛型算法（A First Look at the Algorithms）

#### 只读算法（Read-Only Algorithms）

`accumulate`函数（定义在头文件`numeric`中）用于计算一个序列的和。它接受三个参数，前两个参数指定需要求和的元素范围，第三个参数是和的初值（决定加法运算类型和返回值类型）。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum the elements in vec starting the summation with the value 0</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="built_in">accumulate</span>(vec.<span class="built_in">cbegin</span>(), vec.<span class="built_in">cend</span>(), <span class="number">0</span>);</span><br><span class="line">string sum = <span class="built_in">accumulate</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), <span class="built_in">string</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line"><span class="comment">// error: no + on const char*</span></span><br><span class="line">string sum = <span class="built_in">accumulate</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

建议在只读算法中使用`cbegin`和`cend`函数。

`equal`函数用于确定两个序列是否保存相同的值。它接受三个迭代器参数，前两个参数指定第一个序列范围，第三个参数指定第二个序列的首元素。`equal`函数假定第二个序列至少与第一个序列一样长。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// roster2 should have at least as many elements as roster1</span></span><br><span class="line"><span class="built_in">equal</span>(roster1.<span class="built_in">cbegin</span>(), roster1.<span class="built_in">cend</span>(), roster2.<span class="built_in">cbegin</span>());</span><br></pre></td></tr></table></figure>

只接受单一迭代器表示第二个操作序列的算法都假定第二个序列至少与第一个序列一样长。

#### 写容器元素的算法（Algorithms That Write Container Elements）

`fill`函数接受两个迭代器参数表示序列范围，还接受一个值作为第三个参数，它将给定值赋予范围内的每个元素。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reset each element to 0</span></span><br><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

`fill_n`函数接受单个迭代器参数、一个计数值和一个值，它将给定值赋予迭代器指向位置开始的指定个元素。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reset all the elements of vec to 0</span></span><br><span class="line"><span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

向目的位置迭代器写入数据的算法都假定目的位置足够大，能容纳要写入的元素。

插入迭代器（insert iterator）是一种向容器内添加元素的迭代器。通过插入迭代器赋值时，一个与赋值号右侧值相等的元素会被添加到容器中。

`back_inserter`函数（定义在头文件`iterator`中）接受一个指向容器的引用，返回与该容器绑定的插入迭代器。通过此迭代器赋值时，赋值运算符会调用`push_back`将一个具有给定值的元素添加到容器中。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;    <span class="comment">// empty vector</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">back_inserter</span>(vec);   <span class="comment">// assigning through it adds elements to vec</span></span><br><span class="line">*it = <span class="number">42</span>;   <span class="comment">// vec now has one element with value 42</span></span><br><span class="line"><span class="comment">// ok: back_inserter creates an insert iterator that adds elements to vec</span></span><br><span class="line"><span class="built_in">fill_n</span>(<span class="built_in">back_inserter</span>(vec), <span class="number">10</span>, <span class="number">0</span>);  <span class="comment">// appends ten elements to vec</span></span><br></pre></td></tr></table></figure>

`copy`函数接受三个迭代器参数，前两个参数指定输入序列，第三个参数指定目的序列的起始位置。它将输入序列中的元素拷贝到目的序列中，返回目的位置迭代器（递增后）的值。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> a2[<span class="built_in"><span class="keyword">sizeof</span></span>(a1) / <span class="built_in"><span class="keyword">sizeof</span></span>(*a1)];     <span class="comment">// a2 has the same size as a1</span></span><br><span class="line"><span class="comment">// ret points just past the last element copied into a2</span></span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">copy</span>(<span class="built_in">begin</span>(a1), <span class="built_in">end</span>(a1), a2);    <span class="comment">// copy a1 into a2</span></span><br></pre></td></tr></table></figure>

`replace`函数接受四个参数，前两个迭代器参数指定输入序列，后两个参数指定要搜索的值和替换值。它将序列中所有等于第一个值的元素都替换为第二个值。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// replace any element with the value 0 with 42</span></span><br><span class="line"><span class="built_in">replace</span>(ilst.<span class="built_in">begin</span>(), ilst.<span class="built_in">end</span>(), <span class="number">0</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

相对于`replace`，`replace_copy`函数可以保留原序列不变。它接受第三个迭代器参数，指定调整后序列的保存位置。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use back_inserter to grow destination as needed</span></span><br><span class="line"><span class="built_in">replace_copy</span>(ilst.<span class="built_in">cbegin</span>(), ilst.<span class="built_in">cend</span>(), <span class="built_in">back_inserter</span>(ivec), <span class="number">0</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

很多算法都提供“copy”版本，这些版本不会将新元素放回输入序列，而是创建一个新序列保存结果。

#### 重排容器元素的算法（Algorithms That Reorder Container Elements）

`sort`函数接受两个迭代器参数，指定排序范围。它利用元素类型的`<`运算符重新排列元素。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">elimDups</span><span class="params">(vector&lt;string&gt; &amp;words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// sort words alphabetically so we can find the duplicates</span></span><br><span class="line">    <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// unique reorders the input range so that each word appears once in the</span></span><br><span class="line">    <span class="comment">// front portion of the range and returns an iterator one past the unique range</span></span><br><span class="line">    <span class="keyword">auto</span> end_unique = <span class="built_in">unique</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// erase uses a vector operation to remove the nonunique elements</span></span><br><span class="line">    words.<span class="built_in">erase</span>(end_unique, words.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

`unique`函数重排输入序列，消除相邻的重复项，返回指向不重复值范围末尾的迭代器。

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031643823.png" alt="10-1" style="zoom:80%;" />

### 定制操作（Customizing Operations）

默认情况下，很多比较算法使用元素类型的`<`或`==`运算符完成操作。可以为这些算法提供自定义操作来代替默认运算符。

#### 向算法传递函数（Passing a Function to an Algorithm）

谓词（predicate）是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法使用的谓词分为一元谓词（unary predicate，接受一个参数）和二元谓词（binary predicate，接受两个参数）。接受谓词参数的算法会对输入序列中的元素调用谓词，因此元素类型必须能转换为谓词的参数类型。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// comparison function to be used to sort by word length</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort on word length, shortest to longest</span></span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), isShorter);</span><br></pre></td></tr></table></figure>

稳定排序函数`stable_sort`可以维持输入序列中相等元素的原有顺序。

#### lambda表达式（Lambda Expressions）

`find_if`函数接受两个迭代器参数和一个谓词参数。迭代器参数用于指定序列范围，之后对序列中的每个元素调用给定谓词，并返回第一个使谓词返回非0值的元素。如果不存在，则返回尾迭代器。

对于一个对象或表达式，如果可以对其使用调用运算符`()`，则称它为可调用对象（callable object）。可以向算法传递任何类别的可调用对象。

一个`lambda`表达式表示一个可调用的代码单元，类似未命名的内联函数，但可以定义在函数内部。其形式如下：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (parameter list) -&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>

其中，`capture list`（捕获列表）是一个由`lambda`所在函数定义的局部变量的列表（通常为空）。`return type`、`parameter list`和`function body`与普通函数一样，分别表示返回类型、参数列表和函数体。但与普通函数不同，`lambda`必须使用尾置返回类型，且不能有默认实参。

定义`lambda`时可以省略参数列表和返回类型，但必须包含捕获列表和函数体。省略参数列表等价于指定空参数列表。省略返回类型时，若函数体只是一个`return`语句，则返回类型由返回表达式的类型推断而来。否则返回类型为`void`。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl;    <span class="comment">// prints 42</span></span><br></pre></td></tr></table></figure>

`lambda`可以使用其所在函数的局部变量，但必须先将其包含在捕获列表中。捕获列表只能用于局部非`static`变量，`lambda`可以直接使用局部`static`变量和其所在函数之外声明的名字。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get an iterator to the first element whose size() is &gt;= sz</span></span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">                    [sz](<span class="keyword">const</span> string &amp;a) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz; &#125;);</span><br></pre></td></tr></table></figure>

`for_each`函数接受一个输入序列和一个可调用对象，它对输入序列中的每个元素调用此对象。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print words of the given size or longer, each one followed by a space</span></span><br><span class="line">for_each(wc, words.<span class="built_in">end</span>(),</span><br><span class="line">            [] (<span class="keyword">const</span> string &amp;s) &#123; cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br></pre></td></tr></table></figure>

#### lambda捕获和返回（Lambda Captures and Returns）

被`lambda`捕获的变量的值是在`lambda`创建时拷贝，而不是调用时拷贝。在`lambda`创建后修改局部变量不会影响`lambda`内对应的值。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> v1 = <span class="number">42</span>; <span class="comment">// local variable</span></span><br><span class="line"><span class="comment">// copies v1 into the callable object named f</span></span><br><span class="line"><span class="keyword">auto</span> f = [v1] &#123; <span class="keyword">return</span> v1; &#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = <span class="built_in">f</span>();   <span class="comment">// j is 42; f stored a copy of v1 when we created it</span></span><br></pre></td></tr></table></figure>

`lambda`可以以引用方式捕获变量，但必须保证`lambda`执行时变量存在。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> v1 = <span class="number">42</span>; <span class="comment">// local variable</span></span><br><span class="line"><span class="comment">// the object f2 contains a reference to v1</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;v1] &#123; <span class="keyword">return</span> v1; &#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = <span class="built_in">f2</span>();  <span class="comment">// j is 0; f2 refers to v1; it doesn&#x27;t store it</span></span><br></pre></td></tr></table></figure>

可以让编译器根据`lambda`代码隐式捕获函数变量，方法是在捕获列表中写一个`&`或`=`符号。`&`为引用捕获，`=`为值捕获。

可以混合使用显式捕获和隐式捕获。混合使用时，捕获列表中的第一个元素必须是`&`或`=`符号，用于指定默认捕获方式。显式捕获的变量必须使用与隐式捕获不同的方式。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os implicitly captured by reference; c explicitly captured by value</span></span><br><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">            [&amp;, c] (<span class="keyword">const</span> string &amp;s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;);</span><br><span class="line"><span class="comment">// os explicitly captured by reference; c implicitly captured by value</span></span><br><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">            [=, &amp;os] (<span class="keyword">const</span> string &amp;s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;);</span><br></pre></td></tr></table></figure>

`lambda`捕获列表形式：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031640095.png" alt="10-2" style="zoom:80%;" />

默认情况下，对于值方式捕获的变量，`lambda`不能修改其值。如果希望修改，就必须在参数列表后添加关键字`mutable`。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> v1 = <span class="number">42</span>; <span class="comment">// local variable</span></span><br><span class="line"><span class="comment">// f can change the value of the variables it captures</span></span><br><span class="line"><span class="keyword">auto</span> f = [v1] () <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> ++v1; &#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = <span class="built_in">f</span>();   <span class="comment">// j is 43</span></span><br></pre></td></tr></table></figure>

对于引用方式捕获的变量，`lambda`是否可以修改依赖于此引用指向的是否是`const`类型。

`transform`函数接受三个迭代器参数和一个可调用对象。前两个迭代器参数指定输入序列，第三个迭代器参数表示目的位置。它对输入序列中的每个元素调用可调用对象，并将结果写入目的位置。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi.<span class="built_in">begin</span>(),</span><br><span class="line">            [](<span class="keyword">int</span> i) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i; &#125;);</span><br></pre></td></tr></table></figure>

为`lambda`定义返回类型时，必须使用尾置返回类型。

#### 参数绑定（Binding Arguments）

`bind`函数定义在头文件`functional`中，相当于一个函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适配原对象的参数列表。一般形式如下：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = <span class="built_in">bind</span>(callable, arg_list);</span><br></pre></td></tr></table></figure>

其中，`newCallable`本身是一个可调用对象，`arg_list`是一个以逗号分隔的参数列表，对应给定的`callable`的参数。之后调用`newCallable`时，`newCallable`会再调用`callable`，并传递给它`arg_list`中的参数。`arg_list`中可能包含形如`_n`的名字，其中`n`是一个整数。这些参数是占位符，表示`newCallable`的参数，它们占据了传递给`newCallable`的参数的位置。数值`n`表示生成的可调用对象中参数的位置：`_1`为`newCallable`的第一个参数，`_2`为`newCallable`的第二个参数，依次类推。这些名字都定义在命名空间`placeholders`中，它又定义在命名空间`std`中，因此使用时应该进行双重限定。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_size</span><span class="params">(<span class="keyword">const</span> string &amp;s, string::size_type sz)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check6 is a callable object that takes one argument of type string</span></span><br><span class="line"><span class="comment">// and calls check_size on its given string and the value 6</span></span><br><span class="line"><span class="keyword">auto</span> check6 = <span class="built_in">bind</span>(check_size, _1, <span class="number">6</span>);</span><br><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">bool</span> b1 = <span class="built_in">check6</span>(s);    <span class="comment">// check6(s) calls check_size(s, 6)</span></span><br></pre></td></tr></table></figure>

`bind`函数可以调整给定可调用对象中的参数顺序。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort on word length, shortest to longest</span></span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), isShorter);</span><br><span class="line"><span class="comment">// sort on word length, longest to shortest</span></span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">bind</span>(isShorter, _2, _1));</span><br></pre></td></tr></table></figure>

默认情况下，`bind`函数的非占位符参数被拷贝到`bind`返回的可调用对象中。但有些类型不支持拷贝操作。

如果希望传递给`bind`一个对象而又不拷贝它，则必须使用标准库的`ref`函数。`ref`函数返回一个对象，包含给定的引用，此对象是可以拷贝的。`cref`函数生成保存`const`引用的类。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> string &amp;s, <span class="keyword">char</span> c)</span></span>;</span><br><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">bind</span>(print, <span class="built_in">ref</span>(os), _1, <span class="string">&#x27; &#x27;</span>));</span><br></pre></td></tr></table></figure>

### 再探迭代器（Revisiting Iterators）

除了为每种容器定义的迭代器之外，标准库还在头文件`iterator`中定义了另外几种迭代器。

- 插入迭代器（insert iterator）：该类型迭代器被绑定到容器对象上，可用来向容器中插入元素。
- 流迭代器（stream iterator）：该类型迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流。
- 反向迭代器（reverse iterator）：该类型迭代器向后而不是向前移动。除了`forward_list`之外的标准库容器都有反向迭代器。
- 移动迭代器（move iterator）：该类型迭代器用来移动容器元素。

#### 插入迭代器（Insert Iterators）

插入器是一种迭代器适配器，它接受一个容器参数，生成一个插入迭代器。通过插入迭代器赋值时，该迭代器调用容器操作向给定容器的指定位置插入一个元素。

插入迭代器操作：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031643798.png" alt="10-3" style="zoom:80%;" />

插入器有三种类型，区别在于元素插入的位置：

- `back_inserter`：创建一个调用`push_back`操作的迭代器。
- `front_inserter`：创建一个调用`push_front`操作的迭代器。
- `inserter`：创建一个调用`insert`操作的迭代器。此函数接受第二个参数，该参数必须是一个指向给定容器的迭代器，元素会被插入到该参数指向的元素之前。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lst = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">list&lt;<span class="keyword">int</span>&gt; lst2, lst3;   <span class="comment">// empty lists</span></span><br><span class="line"><span class="comment">// after copy completes, lst2 contains 4 3 2 1</span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">cbegin</span>(), lst.<span class="built_in">cend</span>(), <span class="built_in">front_inserter</span>(lst2));</span><br><span class="line"><span class="comment">// after copy completes, lst3 contains 1 2 3 4</span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">cbegin</span>(), lst.<span class="built_in">cend</span>(), <span class="built_in">inserter</span>(lst3, lst3.<span class="built_in">begin</span>()));</span><br></pre></td></tr></table></figure>

#### iostream迭代器（iostream Iterators）

`istream_iterator`从输入流读取数据，`ostream_iterator`向输出流写入数据。这些迭代器将流当作特定类型的元素序列处理。

创建流迭代器时，必须指定迭代器读写的对象类型。`istream_iterator`使用`>>`来读取流，因此`istream_iterator`要读取的类型必须定义了`>>`运算符。创建`istream_iterator`时，可以将其绑定到一个流。如果默认初始化，则创建的是尾后迭代器。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">int_it</span><span class="params">(cin)</span></span>;  <span class="comment">// reads ints from cin</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; int_eof;      <span class="comment">// end iterator value</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;afile&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">istream_iterator&lt;string&gt; <span class="title">str_it</span><span class="params">(in)</span></span>;   <span class="comment">// reads strings from &quot;afile&quot;</span></span><br></pre></td></tr></table></figure>

对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或IO错误，迭代器的值就与尾后迭代器相等。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span></span>;     <span class="comment">// read ints from cin</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; eof;      <span class="comment">// istream &#x27;&#x27;end&#x27;&#x27; iterator</span></span><br><span class="line"><span class="keyword">while</span> (in_iter != eof)      <span class="comment">// while there&#x27;s valid input to read</span></span><br><span class="line">    <span class="comment">// postfix increment reads the stream and returns the old value of the iterator</span></span><br><span class="line">    <span class="comment">// we dereference that iterator to get the previous value read from the stream</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(*in_iter++);</span><br></pre></td></tr></table></figure>

可以直接使用流迭代器构造容器。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span>, eof</span>;    <span class="comment">// read ints from cin</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(in_iter, eof)</span></span>;      <span class="comment">// construct vec from an iterator range</span></span><br></pre></td></tr></table></figure>

`istream_iterator`操作：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031643954.png" alt="10-4" style="zoom:80%;" />

将`istream_iterator`绑定到一个流时，标准库并不保证迭代器立即从流读取数据。但可以保证在第一次解引用迭代器之前，从流中读取数据的操作已经完成了。

定义`ostream_iterator`对象时，必须将其绑定到一个指定的流。不允许定义空的或者表示尾后位置的`ostream_iterator`。

`ostream_iterator`操作：

<img src="C:\Users\SEUGarfield\Desktop\Cpp-Primer-5th-Notes-CN-master\Chapter-10 Generic Algorithms\Images\10-5.png" alt="10-5" style="zoom:80%;" />

`*`和`++`运算符实际上不会对`ostream_iterator`对象做任何操作。但是建议代码写法与其他迭代器保持一致。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out_iter</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : vec)</span><br><span class="line">    *out_iter++ = e;    <span class="comment">// the assignment writes this element to cout</span></span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

可以为任何定义了`<<`运算符的类型创建`istream_iterator`对象，为定义了`>>`运算符的类型创建`ostream_iterator`对象。

#### 反向迭代器（Reverse Iterators）

递增反向迭代器会移动到前一个元素，递减会移动到后一个元素。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());   <span class="comment">// sorts vec in &quot;normal&quot; order</span></span><br><span class="line"><span class="comment">// sorts in reverse: puts the smallest element at the end of vec</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">rbegin</span>(), vec.<span class="built_in">rend</span>());</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031640107.png" alt="10-6" style="zoom:80%;" />

不能从`forward_list`或流迭代器创建反向迭代器。

调用反向迭代器的`base`函数可以获得其对应的普通迭代器。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find the last element in a comma-separated list</span></span><br><span class="line"><span class="keyword">auto</span> rcomma = <span class="built_in">find</span>(line.<span class="built_in">crbegin</span>(), line.<span class="built_in">crend</span>(), <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"><span class="comment">// WRONG: will generate the word in reverse order</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">string</span>(line.<span class="built_in">crbegin</span>(), rcomma) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// ok: get a forward iterator and read to the end of line</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">string</span>(rcomma.<span class="built_in">base</span>(), line.<span class="built_in">cend</span>()) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031640825.png" alt="10-7" style="zoom:80%;" />

反向迭代器的目的是表示元素范围，而这些范围是不对称的。用普通迭代器初始化反向迭代器，或者给反向迭代器赋值时，结果迭代器与原迭代器指向的并不是相同元素。

### 泛型算法结构（Structure of Generic Algorithms）

算法要求的迭代器操作可以分为5个迭代器类别（iterator category）：

<img src="C:\Users\SEUGarfield\Desktop\Cpp-Primer-5th-Notes-CN-master\Chapter-10 Generic Algorithms\Images\10-8.png" alt="10-8" style="zoom:80%;" />

#### 5类迭代器（The Five Iterator Categories）

C++标准指定了泛型和数值算法的每个迭代器参数的最小类别。对于迭代器实参来说，其能力必须大于或等于规定的最小类别。向算法传递更低级的迭代器参数会产生错误（大部分编译器不会提示错误）。

迭代器类别：

- 输入迭代器（input iterator）：可以读取序列中的元素，只能用于单遍扫描算法。必须支持以下操作：

- - 用于比较两个迭代器相等性的相等`==`和不等运算符`!=`。
  - 用于推进迭代器位置的前置和后置递增运算符`++`。
  - 用于读取元素的解引用运算符`*`；解引用只能出现在赋值运算符右侧。
  - 用于读取元素的箭头运算符`->`。

- 输出迭代器（output iterator）：可以读写序列中的元素，只能用于单遍扫描算法，通常指向目的位置。必须支持以下操作：

- - 用于推进迭代器位置的前置和后置递增运算符`++`。
  - 用于读取元素的解引用运算符`*`；解引用只能出现在赋值运算符左侧（向已经解引用的输出迭代器赋值，等价于将值写入其指向的元素）。

- 前向迭代器（forward iterator）：可以读写序列中的元素。只能在序列中沿一个方向移动。支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此可以使用前向迭代器对序列进行多遍扫描。

- 双向迭代器（bidirectional iterator）：可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，还支持前置和后置递减运算符`--`。除`forward_list`之外的其他标准库容器都提供符合双向迭代器要求的迭代器。

- 随机访问迭代器（random-access iterator）：可以在常量时间内访问序列中的任何元素。除了支持所有双向迭代器的操作之外，还必须支持以下操作：

- - 用于比较两个迭代器相对位置的关系运算符`<`、`<=`、`>`、`>=`。
  - 迭代器和一个整数值的加减法运算`+`、`+=`、`-`、`-=`，计算结果是迭代器在序列中前进或后退给定整数个元素后的位置。
  - 用于两个迭代器上的减法运算符`-`，计算得到两个迭代器的距离。
  - 下标运算符`[]`。

#### 算法形参模式（Algorithm Parameter Patterns）

大多数算法的形参模式是以下四种形式之一：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alg</span>(beg, end, other args);</span><br><span class="line"><span class="built_in">alg</span>(beg, end, dest, other args);</span><br><span class="line"><span class="built_in">alg</span>(beg, end, beg2, other args);</span><br><span class="line"><span class="built_in">alg</span>(beg, end, beg2, end2, other args);</span><br></pre></td></tr></table></figure>

其中`alg`是算法名称，`beg`和`end`表示算法所操作的输入范围。几乎所有算法都接受一个输入范围，是否有其他参数依赖于算法操作。`dest`表示输出范围，`beg2`和`end2`表示第二个输入范围。

向输出迭代器写入数据的算法都假定目标空间足够容纳要写入的数据。

接受单独一个迭代器参数表示第二个输入范围的算法都假定从迭代器参数开始的序列至少与第一个输入范围一样大。

#### 算法命名规范（Algorithm Naming Conventions）

接受谓词参数的算法都有附加的`_if`后缀。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(beg, end, val);       <span class="comment">// find the first instance of val in the input range</span></span><br><span class="line"><span class="built_in">find_if</span>(beg, end, pred);   <span class="comment">// find the first instance for which pred is true</span></span><br></pre></td></tr></table></figure>

将执行结果写入额外目的空间的算法都有`_copy`后缀。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(beg, end);              <span class="comment">// reverse the elements in the input range</span></span><br><span class="line"><span class="built_in">reverse_copy</span>(beg, end, dest);   <span class="comment">// copy elements in reverse order into dest</span></span><br></pre></td></tr></table></figure>

一些算法同时提供`_copy`和`_if`版本。

### 特定容器算法（Container-Specific Algorithms）

对于`list`和`forward_list`类型，应该优先使用成员函数版本的算法，而非通用算法。

`list`和`forward_list`成员函数版本的算法：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031644127.png" alt="10-9" style="zoom:80%;" />

`list`和`forward_list`的`splice`函数可以进行容器合并，其参数如下：

<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031640067.png" alt="10-10" style="zoom:80%;" />

链表特有版本的算法操作会改变底层容器。

-----------

## 第11章 关联容器（简）

- 关联容器和顺序容器的不同：关联容器中的元素时按照**关键字**来保存和访问的。
- 关联容器支持通过关键字来高效地查找和读取元素，基本的关联容器类型是 `map`和 `set`。

**关联容器类型**：

| 容器类型             | 解释                                |
| -------------------- | ----------------------------------- |
| 按顺序存储           |                                     |
| `map`                | 关键数组：保存`关键字-值`对         |
| `set`                | 关键字即值，即只保存关键字的容器    |
| `multimap`           | 支持同一个键多次出现的`map`         |
| `multiset`           | 支持同一个键多次出现的`set`         |
| 无序集合             |                                     |
| `unordered_map`      | 用哈希函数组织的`map`               |
| `unordered_set`      | 用哈希函数组织的`set`               |
| `unordered_multimap` | 哈希组织的`map`，关键字可以重复出现 |
| `unordered_multiset` | 哈希组织的`set`，关键字可以重复出现 |

### 关联容器概述

#### 定义关联容器

- 需要指定元素类型。
- 列表初始化：
  - `map`：`map<string, int> word_count = &#123;&#123;"a", 1&#125;, &#123;"b", 2&#125;&#125;;</code>
<ul>
<li><code>set</code>：<code>set&lt;string&gt; exclude = &#123;&quot;the&quot;, &quot;a&quot;&#125;;</code></li>
</ul>
</li>
</ul>
<h4 id="关键字类型的要求">关键字类型的要求</h4>
<ul>
<li>对于有序容器，关键字类型必须定义元素比较的方法。默认是<code>&lt;</code>。</li>
<li>如果想传递一个比较的函数，可以这样定义：<code>multiset&lt;Sales_data, decltype(compareIsbn)*&gt; bookstore(compareIsbn);</code></li>
</ul>
<h4 id="pair">pair</h4>
<ul>
<li>在<code>utility</code>头文件中定义。</li>
<li>一个<code>pair</code>保存两个数据成员，两个类型不要求一样。</li>
</ul>
<p><strong>pair的操作</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pair&lt;T1, T2&gt; p;</code></td>
<td><code>p</code>是一个<code>pair</code>，两个类型分别是<code>T1</code>和<code>T2</code>的成员都进行了值初始化。</td>
</tr>
<tr>
<td><code>pair&lt;T1, T2&gt; p(v1, v2);</code></td>
<td><code>first</code>和<code>second</code>分别用<code>v1</code>和<code>v2</code>进行初始化。</td>
</tr>
<tr>
<td><code>pair&lt;T1, T2&gt;p = &#123;v1, v2&#125;;</code></td>
<td>等价于`p(v1, v2)</td>
</tr>
<tr>
<td><code>make_pair(v1, v2);</code></td>
<td><code>pair</code>的类型从<code>v1</code>和<code>v2</code>的类型推断出来。</td>
</tr>
<tr>
<td><code>p.first</code></td>
<td>返回<code>p</code>的名为<code>first</code>的数据成员。</td>
</tr>
<tr>
<td><code>p.second</code></td>
<td>返回<code>p</code>的名为<code>second</code>的数据成员。</td>
</tr>
<tr>
<td><code>p1 relop p2</code></td>
<td>运算关系符按字典序定义。</td>
</tr>
<tr>
<td><code>p1 == p2</code></td>
<td>必须两对元素两两相等</td>
</tr>
<tr>
<td><code>p1 != p2</code></td>
<td>同上</td>
</tr>
</tbody>
</table>
<h3 id="关联容器操作">关联容器操作</h3>
<p><strong>关联容器额外的类型别名</strong>：</p>
<table>
<thead>
<tr>
<th>类型别名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key_type</code></td>
<td>此容器类型的关键字类型</td>
</tr>
<tr>
<td><code>mapped_type</code></td>
<td>每个关键字关联的类型，只适用于<code>map</code></td>
</tr>
<tr>
<td><code>value_type</code></td>
<td>对于<code>map</code>，是<code>pair&lt;const key_type, mapped_type&gt;</code>; 对于<code>set</code>，和<code>key_type</code>相同。</td>
</tr>
</tbody>
</table>
<h4 id="关联容器迭代器">关联容器迭代器</h4>
<ul>
<li>解引用一个关联容器迭代器时，会得到一个类型为容器的<code>value_type</code>的值的引用。</li>
<li><code>set</code>的迭代器是<code>const</code>的。</li>
<li>遍历关联容器：使用<code>begin</code>和<code>end</code>，遍历<code>map</code>、<code>multimap</code>、<code>set</code>、<code>multiset</code>时，迭代器按<strong>关键字升序</strong>遍历元素。</li>
</ul>
<h4 id="添加元素">添加元素</h4>
<p><strong>关联容器<code>insert</code>操作</strong>：</p>
<table>
<thead>
<tr>
<th><code>insert</code>操作</th>
<th>关联容器</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.insert(v)</code>  <code>c.emplace(args)</code></td>
<td><code>v</code>是<code>value_type</code>类型的对象；<code>args</code>用来构造一个元素。 对于<code>map</code>和<code>set</code>，只有元素的关键字不存在<code>c</code>中才插入或构造元素。函数返回一个<code>pair</code>，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否成功的<code>bool</code>值。对于<code>multimap</code>和<code>multiset</code>则会插入范围中的每个元素。</td>
</tr>
<tr>
<td><code>c.insert(b, e)</code> <code>c.insert(il)</code></td>
<td><code>b</code>和<code>e</code>是迭代器，表示一个<code>c::value_type</code>类型值的范围；<code>il</code>是这种值的花括号列表。函数返回<code>void</code>。对于 <code>map</code>和<code>set</code>，只插入关键字不在<code>c</code>中的元素。</td>
</tr>
<tr>
<td><code>c.insert(p, v)</code>  <code>c.emplace(p, args)</code></td>
<td>类似<code>insert(v)</code>，但将迭代器<code>p</code>作为一个提示，指出从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有给定关键字的元素。</td>
</tr>
</tbody>
</table>
<p>向<code>map</code>添加元素：</p>
<ul>
<li><code>word_count.insert(&#123;word, 1&#125;);</code></li>
<li><code>word_count.insert(make_pair(word, 1));</code></li>
<li><code>word_count.insert(pair&lt;string, size_t&gt;(word, 1));</code></li>
<li><code>word_count.insert(map&lt;string, size_t&gt;::value_type (word, 1));</code></li>
</ul>
<h4 id="删除元素">删除元素</h4>
<p><strong>从关联容器中删除元素</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.erase(k)</code></td>
<td>从<code>c</code>中删除每个关键字为<code>k</code>的元素。返回一个<code>size_type</code>值，指出删除的元素的数量。</td>
</tr>
<tr>
<td><code>c.erase(p)</code></td>
<td>从<code>c</code>中删除迭代器<code>p</code>指定的元素。<code>p</code>必须指向<code>c</code>中一个真实元素，不能等于<code>c.end()</code>。返回一个指向<code>p</code>之后元素的迭代器，若<code>p</code>指向<code>c</code>中的尾元素，则返回<code>c.end()</code></td>
</tr>
<tr>
<td><code>c.erase(b, e)</code></td>
<td>删除迭代器对<code>b</code>和<code>e</code>所表示范围中的元素。返回<code>e</code>。</td>
</tr>
</tbody>
</table>
<h4 id="下标操作">下标操作</h4>
<p><strong><code>map</code>和<code>unordered_map</code>的下标操作</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c[k]</code></td>
<td>返回关键字为<code>k</code>的元素；如果<code>k</code>不在<code>c</code>中，添加一个关键字为<code>k</code>的元素，对其值初始化。</td>
</tr>
<tr>
<td><code>c.at(k)</code></td>
<td>访问关键字为<code>k</code>的元素，带参数检查；若<code>k</code>不存在在<code>c</code>中，抛出一个<code>out_of_range</code>异常。</td>
</tr>
</tbody>
</table>
<h4 id="查找元素">查找元素</h4>
<p><strong>在一个关联容器中查找元素</strong>:</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.find(k)</code></td>
<td>返回一个迭代器，指向第一个关键字为<code>k</code>的元素，若<code>k</code>不在容器中，则返回尾后迭代器</td>
</tr>
<tr>
<td><code>c.count(k)</code></td>
<td>返回关键字等于<code>k</code>的元素的数量。对于不允许重复关键字的容器，返回值永远是0或1。</td>
</tr>
<tr>
<td><code>c.lower_bound(k)</code></td>
<td>返回一个迭代器，指向第一个关键字<strong>不小于</strong><code>k</code>的元素。</td>
</tr>
<tr>
<td><code>c.upper_bound(k)</code></td>
<td>返回一个迭代器，指向第一个关键字<strong>大于</strong><code>k</code>的元素。</td>
</tr>
<tr>
<td><code>c.equal_range(k)</code></td>
<td>返回一个迭代器<code>pair</code>，表示关键字等于<code>k</code>的元素的范围。若<code>k</code>不存在，<code>pair</code>的两个成员均等于<code>c.end()</code>。</td>
</tr>
</tbody>
</table>
<ul>
<li><code>lower_bound</code>和<code>upper_bound</code>不适用于无序容器。</li>
<li>下标和<code>at</code>操作只适用于非<code>const</code>的<code>map</code>和<code>unordered_map</code>。</li>
</ul>
<h3 id="无序容器">无序容器</h3>
<ul>
<li>有序容器使用比较运算符来组织元素；无序容器使用哈希函数和关键字类型的<code>==</code>运算符。</li>
<li>理论上哈希技术可以获得更好的性能。</li>
<li>无序容器在存储上组织为一组桶(bucket)，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。</li>
</ul>
<p><strong>无序容器管理操作</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>桶接口</strong></td>
<td></td>
</tr>
<tr>
<td><code>c.bucket_count()</code></td>
<td>正在使用的桶的数目</td>
</tr>
<tr>
<td><code>c.max_bucket_count()</code></td>
<td>容器能容纳的最多的桶的数目</td>
</tr>
<tr>
<td><code>c.bucket_size(n)</code></td>
<td>第<code>n</code>个桶中有多少个元素</td>
</tr>
<tr>
<td><code>c.bucket(k)</code></td>
<td>关键字为<code>k</code>的元素在哪个桶中</td>
</tr>
<tr>
<td><strong>桶迭代</strong></td>
<td></td>
</tr>
<tr>
<td><code>local_iterator</code></td>
<td>可以用来访问桶中元素的迭代器类型</td>
</tr>
<tr>
<td><code>const_local_iterator</code></td>
<td>桶迭代器的<code>const</code>版本</td>
</tr>
<tr>
<td><code>c.begin(n)</code>，<code>c.end(n)</code></td>
<td>桶<code>n</code>的首元素迭代器</td>
</tr>
<tr>
<td><code>c.cbegin(n)</code>，<code>c.cend(n)</code></td>
<td>与前两个函数类似，但返回<code>const_local_iterator</code>。</td>
</tr>
<tr>
<td><strong>哈希策略</strong></td>
<td></td>
</tr>
<tr>
<td><code>c.load_factor()</code></td>
<td>每个桶的平均元素数量，返回<code>float</code>值。</td>
</tr>
<tr>
<td><code>c.max_load_factor()</code></td>
<td><code>c</code>试图维护的平均比桶大小，返回<code>float</code>值。<code>c</code>会在需要时添加新的桶，以使得<code>load_factor&lt;=max_load_factor</code></td>
</tr>
<tr>
<td><code>c.rehash(n)</code></td>
<td>重组存储，使得<code>bucket_count&gt;=n</code>，且<code>bucket_count&gt;size/max_load_factor</code></td>
</tr>
<tr>
<td><code>c.reverse(n)</code></td>
<td>重组存储，使得<code>c</code>可以保存<code>n</code>个元素且不必<code>rehash</code>。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="第11章-关联容器">第11章 关联容器</h2>
<p>关联容器支持高效的关键字查找和访问操作。2个主要的关联容器（associative-container）类型是<code>map</code>和<code>set</code>。</p>
<ul>
<li><code>map</code>中的元素是一些键值对（key-value）：关键字起索引作用，值表示与索引相关联的数据。</li>
<li><code>set</code>中每个元素只包含一个关键字，支持高效的关键字查询操作：检查一个给定关键字是否在<code>set</code>中。</li>
</ul>
<p>标准库提供了8个关联容器，它们之间的不同体现在三个方面：</p>
<ul>
<li>是<code>map</code>还是<code>set</code>类型。</li>
<li>是否允许保存重复的关键字。</li>
<li>是否按顺序保存元素。</li>
</ul>
<p>允许重复保存关键字的容器名字都包含单词<code>multi</code>；无序保存元素的容器名字都以单词<code>unordered</code>开头。</p>
<img src="C:\Users\SEUGarfield\Desktop\Cpp-Primer-5th-Notes-CN-master\Chapter-11 Associative Containers\Images\11-1.png" alt="11-1" style="zoom:80%;" />
<p><code>map</code>和<code>multimap</code>类型定义在头文件<code>map</code>中；<code>set</code>和<code>multiset</code>类型定义在头文件<code>set</code>中；无序容器定义在头文件<code>unordered_map</code>和<code>unordered_set</code>中。</p>
<h3 id="使用关联容器（Using-an-Associative-Container）">使用关联容器（Using an Associative Container）</h3>
<p><code>map</code>类型通常被称为关联数组（associative array）。</p>
<p>从<code>map</code>中提取一个元素时，会得到一个<code>pair</code>类型的对象。<code>pair</code>是一个模板类型，保存两个名为<code>first</code>和<code>second</code>的公有数据成员。<code>map</code>所使用的<code>pair</code>用<code>first</code>成员保存关键字，用<code>second</code>成员保存对应的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// count the number of times each word occurs in the input</span></span><br><span class="line">map&lt;string, <span class="keyword">size_t</span>&gt; word_count;     <span class="comment">// empty map from string to size_t</span></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    ++word_count[word];     <span class="comment">// fetch and increment the counter for word</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : word_count)    <span class="comment">// for each element in the map</span></span><br><span class="line">    <span class="comment">// print the results</span></span><br><span class="line">    cout &lt;&lt; w.first &lt;&lt; <span class="string">&quot; occurs &quot;</span> &lt;&lt; w.second</span><br><span class="line">        &lt;&lt; ((w.second &gt; <span class="number">1</span>) ? <span class="string">&quot; times&quot;</span> : <span class="string">&quot; time&quot;</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p><code>set</code>类型的<code>find</code>成员返回一个迭代器。如果给定关键字在<code>set</code>中，则迭代器指向该关键字，否则返回的是尾后迭代器。</p>
<h3 id="关联容器概述（Overview-of-the-Associative-Containers）">关联容器概述（Overview of the Associative Containers）</h3>
<h4 id="定义关联容器（Defining-an-Associative-Container）">定义关联容器（Defining an Associative Container）</h4>
<p>定义<code>map</code>时，必须指定关键字类型和值类型；定义<code>set</code>时，只需指定关键字类型。</p>
<p>初始化<code>map</code>时，提供的每个键值对用花括号<code>&#123;&#125;</code>包围。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="keyword">size_t</span>&gt; word_count;   <span class="comment">// empty</span></span><br><span class="line"><span class="comment">// list initialization</span></span><br><span class="line">set&lt;string&gt; exclude = &#123; <span class="string">&quot;the&quot;</span>, <span class="string">&quot;but&quot;</span>, <span class="string">&quot;and&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// three elements; authors maps last name to first</span></span><br><span class="line">map&lt;string, string&gt; authors =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Joyce&quot;</span>, <span class="string">&quot;James&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Austen&quot;</span>, <span class="string">&quot;Jane&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Dickens&quot;</span>, <span class="string">&quot;Charles&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>map</code>和<code>set</code>中的关键字必须唯一，<code>multimap</code>和<code>multiset</code>没有此限制。</p>
<h4 id="关键字类型的要求（Requirements-on-Key-Type）">关键字类型的要求（Requirements on Key Type）</h4>
<p>对于有序容器——<code>map</code>、<code>multimap</code>、<code>set</code>和<code>multiset</code>，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的<code>&lt;</code>运算符来进行比较操作。</p>
<p>用来组织容器元素的操作的类型也是该容器类型的一部分。如果需要使用自定义的比较操作，则必须在定义关联容器类型时提供此操作的类型。操作类型在尖括号中紧跟着元素类型给出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() &lt; rhs.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bookstore can have several transactions with the same ISBN</span></span><br><span class="line"><span class="comment">// elements in bookstore will be in ISBN order</span></span><br><span class="line"><span class="function">multiset&lt;Sales_data, <span class="title">decltype</span><span class="params">(compareIsbn)</span>*&gt; <span class="title">bookstore</span><span class="params">(compareIsbn)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="pair类型（The-pair-Type）">pair类型（The pair Type）</h4>
<p><code>pair</code>定义在头文件<code>utility</code>中。一个<code>pair</code>可以保存两个数据成员，分别命名为<code>first</code>和<code>second</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, string&gt; anon;        <span class="comment">// holds two strings</span></span><br><span class="line">pair&lt;string, <span class="keyword">size_t</span>&gt; word_count;  <span class="comment">// holds a string and an size_t</span></span><br><span class="line">pair&lt;string, vector&lt;<span class="keyword">int</span>&gt;&gt; line;   <span class="comment">// holds string and vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>pair</code>的默认构造函数对数据成员进行值初始化。</p>
<p><code>pair</code>支持的操作：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031647318.png" alt="11-2" style="zoom:80%;" />
<p>在C++11中，如果函数需要返回<code>pair</code>，可以对返回值进行列表初始化。早期C++版本中必须显式构造返回值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;string, <span class="keyword">int</span>&gt; <span class="title">process</span><span class="params">(vector&lt;string&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// process v</span></span><br><span class="line">    <span class="keyword">if</span> (!v.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="comment">// list initialize</span></span><br><span class="line">        <span class="keyword">return</span> &#123; v.<span class="built_in">back</span>(), v.<span class="built_in">back</span>().<span class="built_in">size</span>() &#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// explicitly constructed return value</span></span><br><span class="line">        <span class="keyword">return</span> pair&lt;string, <span class="keyword">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关联容器操作（Operations-on-Associative-Containers）">关联容器操作（Operations on Associative Containers）</h3>
<p>关联容器定义了类型别名来表示容器关键字和值的类型：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031645437.png" alt="11-3" style="zoom:80%;" />
<p>对于<code>set</code>类型，<code>key_type</code>和<code>value_type</code>是一样的。<code>set</code>中保存的值就是关键字。对于<code>map</code>类型，元素是关键字-值对。即每个元素是一个<code>pair</code>对象，包含一个关键字和一个关联的值。由于元素关键字不能改变，因此<code>pair</code>的关键字部分是<code>const</code>的。另外，只有<code>map</code>类型（<code>unordered_map</code>、<code>unordered_multimap</code>、<code>multimap</code>、<code>map</code>）才定义了<code>mapped_type</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt;::value_type v1;        <span class="comment">// v1 is a string</span></span><br><span class="line">set&lt;string&gt;::key_type v2;          <span class="comment">// v2 is a string</span></span><br><span class="line">map&lt;string, <span class="keyword">int</span>&gt;::value_type v3;   <span class="comment">// v3 is a pair&lt;const string, int&gt;</span></span><br><span class="line">map&lt;string, <span class="keyword">int</span>&gt;::key_type v4;     <span class="comment">// v4 is a string</span></span><br><span class="line">map&lt;string, <span class="keyword">int</span>&gt;::mapped_type v5;  <span class="comment">// v5 is an int</span></span><br></pre></td></tr></table></figure>
<h4 id="关联容器迭代器（Associative-Container-Iterators）">关联容器迭代器（Associative Container Iterators）</h4>
<p>解引用关联容器迭代器时，会得到一个类型为容器的<code>value_type</code>的引用。对<code>map</code>而言，<code>value_type</code>是<code>pair</code>类型，其<code>first</code>成员保存<code>const</code>的关键字，<code>second</code>成员保存值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get an iterator to an element in word_count</span></span><br><span class="line"><span class="keyword">auto</span> map_it = word_count.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// *map_it is a reference to a pair&lt;const string, size_t&gt; object</span></span><br><span class="line">cout &lt;&lt; map_it-&gt;first;          <span class="comment">// prints the key for this element</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; map_it-&gt;second;  <span class="comment">// prints the value of the element</span></span><br><span class="line">map_it-&gt;first = <span class="string">&quot;new key&quot;</span>;      <span class="comment">// error: key is const</span></span><br><span class="line">++map_it-&gt;second;               <span class="comment">// ok: we can change the value through an iterator</span></span><br></pre></td></tr></table></figure>
<p>虽然<code>set</code>同时定义了<code>iterator</code>和<code>const_iterator</code>类型，但两种迭代器都只允许只读访问<code>set</code>中的元素。类似<code>map</code>，<code>set</code>中的关键字也是<code>const</code>的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; iset = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator set_it = iset.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">if</span> (set_it != iset.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    *set_it = <span class="number">42</span>;       <span class="comment">// error: keys in a set are read-only</span></span><br><span class="line">    cout &lt;&lt; *set_it &lt;&lt; endl;    <span class="comment">// ok: can read the key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>map</code>和<code>set</code>都支持<code>begin</code>和<code>end</code>操作。使用迭代器遍历<code>map</code>、<code>multimap</code>、<code>set</code>或<code>multiset</code>时，迭代器按关键字升序遍历元素。</p>
<p>通常不对关联容器使用泛型算法。</p>
<h4 id="添加元素（Adding-Elements）">添加元素（Adding Elements）</h4>
<p>使用<code>insert</code>成员可以向关联容器中添加元素。向<code>map</code>和<code>set</code>中添加已存在的元素对容器没有影响。</p>
<p>通常情况下，对于想要添加到<code>map</code>中的数据，并没有现成的<code>pair</code>对象。可以直接在<code>insert</code>的参数列表中创建<code>pair</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// four ways to add word to word_count</span></span><br><span class="line">word_count.<span class="built_in">insert</span>(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">word_count.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(word, <span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">insert</span>(pair&lt;string, <span class="keyword">size_t</span>&gt;(word, <span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">insert</span>(map&lt;string, <span class="keyword">size_t</span>&gt;::<span class="built_in">value_type</span>(word, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>关联容器的<code>insert</code>操作：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031648633.png" alt="11-4" style="zoom:80%;" />
<p><code>insert</code>或<code>emplace</code>的返回值依赖于容器类型和参数：</p>
<ul>
<li>对于不包含重复关键字的容器，添加单一元素的<code>insert</code>和<code>emplace</code>版本返回一个<code>pair</code>，表示操作是否成功。<code>pair</code>的<code>first</code>成员是一个迭代器，指向具有给定关键字的元素；<code>second</code>成员是一个<code>bool</code>值。如果关键字已在容器中，则<code>insert</code>直接返回，<code>bool</code>值为<code>false</code>。如果关键字不存在，元素会被添加至容器中，<code>bool</code>值为<code>true</code>。</li>
<li>对于允许包含重复关键字的容器，添加单一元素的<code>insert</code>和<code>emplace</code>版本返回指向新元素的迭代器。</li>
</ul>
<h4 id="删除元素（Erasing-Elements）">删除元素（Erasing Elements）</h4>
<p>关联容器的删除操作：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031645443.png" alt="11-5" style="zoom:80%;" />
<p>与顺序容器不同，关联容器提供了一个额外的<code>erase</code>操作。它接受一个<code>key_type</code>参数，删除所有匹配给定关键字的元素（如果存在），返回实际删除的元素数量。对于不包含重复关键字的容器，<code>erase</code>的返回值总是1或0。若返回值为0，则表示想要删除的元素并不在容器中。</p>
<h4 id="map的下标操作（Subscripting-a-map）">map的下标操作（Subscripting a map）</h4>
<p><code>map</code>下标运算符接受一个关键字，获取与此关键字相关联的值。如果关键字不在容器中，下标运算符会向容器中添加该关键字，并值初始化关联值。</p>
<p>由于下标运算符可能向容器中添加元素，所以只能对非<code>const</code>的<code>map</code>使用下标操作。</p>
<p><code>map</code>和<code>unordered_map</code>的下标操作：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031648107.png" alt="11-6" style="zoom:80%;" />
<p>对<code>map</code>进行下标操作时，返回的是<code>mapped_type</code>类型的对象；解引用<code>map</code>迭代器时，返回的是<code>value_type</code>类型的对象。</p>
<h4 id="访问元素（Accessing-Elements）">访问元素（Accessing Elements）</h4>
<p>关联容器的查找操作：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031645203.png" alt="11-7" style="zoom:80%;" />
<p>如果<code>multimap</code>或<code>multiset</code>中有多个元素具有相同关键字，则这些元素在容器中会相邻存储。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;string, string&gt; authors;</span><br><span class="line"><span class="comment">// adds the first element with the key Barth, John</span></span><br><span class="line">authors.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Barth, John&quot;</span>, <span class="string">&quot;Sot-Weed Factor&quot;</span>&#125;);</span><br><span class="line"><span class="comment">// ok: adds the second element with the key Barth, John</span></span><br><span class="line">authors.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Barth, John&quot;</span>, <span class="string">&quot;Lost in the Funhouse&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">search_item</span><span class="params">(<span class="string">&quot;Alain de Botton&quot;</span>)</span></span>;      <span class="comment">// author we&#x27;ll look for</span></span><br><span class="line"><span class="keyword">auto</span> entries = authors.<span class="built_in">count</span>(search_item);  <span class="comment">// number of elements</span></span><br><span class="line"><span class="keyword">auto</span> iter = authors.<span class="built_in">find</span>(search_item);      <span class="comment">// first entry for this author</span></span><br><span class="line"><span class="comment">// loop through the number of entries there are for this author</span></span><br><span class="line"><span class="keyword">while</span>(entries)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; iter-&gt;second &lt;&lt; endl;   <span class="comment">// print each title</span></span><br><span class="line">    ++iter;      <span class="comment">// advance to the next title</span></span><br><span class="line">    --entries;   <span class="comment">// keep track of how many we&#x27;ve printed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lower_bound</code>和<code>upper_bound</code>操作都接受一个关键字，返回一个迭代器。如果关键字在容器中，<code>lower_bound</code>返回的迭代器会指向第一个匹配给定关键字的元素，而<code>upper_bound</code>返回的迭代器则指向最后一个匹配元素之后的位置。如果关键字不在<code>multimap</code>中，则<code>lower_bound</code>和<code>upper_bound</code>会返回相等的迭代器，指向一个不影响排序的关键字插入位置。因此用相同的关键字调用<code>lower_bound</code>和<code>upper_bound</code>会得到一个迭代器范围，表示所有具有该关键字的元素范围。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definitions of authors and search_item as above</span></span><br><span class="line"><span class="comment">// beg and end denote the range of elements for this author</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> beg = authors.<span class="built_in">lower_bound</span>(search_item),</span><br><span class="line">        end = authors.<span class="built_in">upper_bound</span>(search_item);</span><br><span class="line">    beg != end; ++beg)</span><br><span class="line">    cout &lt;&lt; beg-&gt;second &lt;&lt; endl;    <span class="comment">// print each title</span></span><br></pre></td></tr></table></figure>
<p><code>lower_bound</code>和<code>upper_bound</code>有可能返回尾后迭代器。如果查找的元素具有容器中最大的关键字，则<code>upper_bound</code>返回尾后迭代器。如果关键字不存在，且大于容器中任何关键字，则<code>lower_bound</code>也返回尾后迭代器。</p>
<p><code>equal_range</code>操作接受一个关键字，返回一个迭代器<code>pair</code>。若关键字存在，则第一个迭代器指向第一个匹配关键字的元素，第二个迭代器指向最后一个匹配元素之后的位置。若关键字不存在，则两个迭代器都指向一个不影响排序的关键字插入位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definitions of authors and search_item as above</span></span><br><span class="line"><span class="comment">// pos holds iterators that denote the range of elements for this key</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> pos = authors.<span class="built_in">equal_range</span>(search_item);</span><br><span class="line">        pos.first != pos.second; ++pos.first)</span><br><span class="line">    cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl;  <span class="comment">// print each title</span></span><br></pre></td></tr></table></figure>
<h3 id="无序容器（The-Unordered-Containers）">无序容器（The Unordered Containers）</h3>
<p>新标准库定义了4个无序关联容器（unordered associative container），这些容器使用哈希函数（hash function）和关键字类型的<code>==</code>运算符组织元素。</p>
<p>无序容器和对应的有序容器通常可以相互替换。但是由于元素未按顺序存储，使用无序容器的程序输出一般会与有序容器的版本不同。</p>
<p>无序容器在存储上组织为一组桶，每个桶保存零或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。因此无序容器的性能依赖于哈希函数的质量和桶的数量及大小。</p>
<p>无序容器管理操作：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031645217.png" alt="11-8" style="zoom:80%;" />
<p>默认情况下，无序容器使用关键字类型的<code>==</code>运算符比较元素，还使用一个<code>hash&lt;key_type&gt;</code>类型的对象来生成每个元素的哈希值。标准库为内置类型和一些标准库类型提供了hash模板。因此可以直接定义关键字是这些类型的无序容器，而不能直接定义关键字类型为自定义类类型的无序容器，必须先提供对应的hash模板版本。</p>
<hr>
<h2 id="第12章-动态内存（简）">第12章 动态内存（简）</h2>
<ul>
<li>
<p>对象的生命周期：</p>
<ul>
<li>全局对象在程序启动时分配，结束时销毁。</li>
<li>局部对象在进入程序块时创建，离开块时销毁。</li>
<li>局部<code>static</code>对象在第一次使用前分配，在程序结束时销毁。</li>
<li>动态分配对象：只能显式地被释放。</li>
</ul>
</li>
<li>
<p>对象的内存位置：</p>
<ul>
<li><strong>静态内存</strong>用来保存局部<code>static</code>对象、类<code>static</code>对象、定义在任何函数之外的变量。</li>
<li><strong>栈内存</strong>用来保存定义在函数内的非<code>static</code>对象。</li>
<li><strong>堆内存</strong>，又称自由空间，用来存储<strong>动态分配</strong>的对象。</li>
</ul>
</li>
</ul>
<h3 id="动态内存与智能指针">动态内存与智能指针</h3>
<ul>
<li>动态内存管理：
<ul>
<li><code>new</code>：在动态内存中为对象分配空间并返回一个指向该对象的指针。</li>
<li><code>delete</code>：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</li>
</ul>
</li>
<li>智能指针：
<ul>
<li>管理动态对象。</li>
<li>行为类似常规指针。</li>
<li>负责自动释放所指向的对象。</li>
<li>智能指针也是模板。</li>
</ul>
</li>
</ul>
<h4 id="shared-ptr类">shared_ptr类</h4>
<p><strong>shared_ptr和unique_ptr都支持的操作</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>shared_ptr&lt;T&gt; sp</code>  <code>unique_ptr&lt;T&gt; up</code></td>
<td>空智能指针，可以指向类型是<code>T</code>的对象</td>
</tr>
<tr>
<td><code>p</code></td>
<td>将<code>p</code>用作一个条件判断，若<code>p</code>指向一个对象，则为<code>true</code></td>
</tr>
<tr>
<td><code>*p</code></td>
<td>解引用<code>p</code>，获得它指向的对象。</td>
</tr>
<tr>
<td><code>p-&gt;mem</code></td>
<td>等价于<code>(*p).mem</code></td>
</tr>
<tr>
<td><code>p.get()</code></td>
<td>返回<code>p</code>中保存的指针，要小心使用，若智能指针释放了对象，返回的指针所指向的对象也就消失了。</td>
</tr>
<tr>
<td><code>swap(p, q)</code> <code>p.swap(q)</code></td>
<td>交换<code>p</code>和<code>q</code>中的指针</td>
</tr>
</tbody>
</table>
<p><strong>shared_ptr独有的操作</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>make_shared&lt;T&gt;(args)</code></td>
<td>返回一个<code>shared_ptr</code>，指向一个动态分配的类型为<code>T</code>的对象。使用<code>args</code>初始化此对象。</td>
</tr>
<tr>
<td><code>shared_ptr&lt;T&gt;p(q)</code></td>
<td><code>p</code>是<code>shared_ptr q</code>的拷贝；此操作会<strong>递增</strong><code>q</code>中的计数器。<code>q</code>中的指针必须能转换为<code>T*</code></td>
</tr>
<tr>
<td><code>p = q</code></td>
<td><code>p</code>和<code>q</code>都是<code>shared_ptr</code>，所保存的指针必须能互相转换。此操作会<strong>递减</strong><code>p</code>的引用计数，<strong>递增</strong><code>q</code>的引用计数；若<code>p</code>的引用计数变为0，则将其管理的原内存释放。</td>
</tr>
<tr>
<td><code>p.unique()</code></td>
<td>若<code>p.use_count()</code>是1，返回<code>true</code>；否则返回<code>false</code></td>
</tr>
<tr>
<td><code>p.use_count()</code></td>
<td>返回与<code>p</code>共享对象的智能指针数量；可能很慢，主要用于调试。</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>使用动态内存的三种原因</strong>：
<ul>
<li>程序不知道自己需要使用多少对象（比如容器类）。</li>
<li>程序不知道所需要对象的准确类型。</li>
<li>程序需要在多个对象间共享数据。</li>
</ul>
</li>
</ul>
<h4 id="直接管理内存">直接管理内存</h4>
<ul>
<li>用<code>new</code>动态分配和初始化对象。
<ul>
<li><code>new</code>无法为分配的对象命名（因为自由空间分配的内存是无名的），因此是返回一个指向该对象的指针。</li>
<li><code>int *pi = new int(123);</code></li>
<li>一旦内存耗尽，会抛出类型是<code>bad_alloc</code>的异常。</li>
</ul>
</li>
<li>用<code>delete</code>将动态内存归还给系统。
<ul>
<li>接受一个指针，指向要释放的对象。</li>
<li><code>delete</code>后的指针称为空悬指针（dangling pointer）。</li>
</ul>
</li>
<li>使用<code>new</code>和<code>delete</code>管理动态内存存在三个常见问题：
<ul>
<li>1.忘记<code>delete</code>内存。</li>
<li>2.使用已经释放掉的对象。</li>
<li>3.同一块内存释放两次。</li>
</ul>
</li>
<li>坚持只使用智能指针可以避免上述所有问题。</li>
</ul>
<h4 id="shared-ptr和new结合使用">shared_ptr和new结合使用</h4>
<p><strong>定义和改变shared_ptr的其他方法</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>shared_ptr&lt;T&gt; p(q)</code></td>
<td><code>p</code>管理内置指针<code>q</code>所指向的对象；<code>q</code>必须指向<code>new</code>分配的内存，且能够转换为<code>T*</code>类型</td>
</tr>
<tr>
<td><code>shared_ptr&lt;T&gt; p(u)</code></td>
<td><code>p</code>从<code>unique_ptr u</code>那里接管了对象的所有权；将<code>u</code>置为空</td>
</tr>
<tr>
<td><code>shared_ptr&lt;T&gt; p(q, d)</code></td>
<td><code>p</code>接管了内置指针<code>q</code>所指向的对象的所有权。<code>q</code>必须能转换为<code>T*</code>类型。<code>p</code>将使用可调用对象<code>d</code>来代替<code>delete</code>。</td>
</tr>
<tr>
<td><code>shared_ptr&lt;T&gt; p(p2, d)</code></td>
<td><code>p</code>是<code>shared_ptr p2</code>的拷贝，唯一的区别是<code>p</code>将可调用对象<code>d</code>来代替<code>delete</code>。</td>
</tr>
<tr>
<td><code>p.reset()</code></td>
<td>若<code>p</code>是唯一指向其对象的<code>shared_ptr</code>，<code>reset</code>会释放此对象。若传递了可选的参数内置指针<code>q</code>，会令<code>p</code>指向<code>q</code>，否则会将<code>p</code>置空。若还传递了参数<code>d</code>，则会调用<code>d</code>而不是<code>delete</code>来释放<code>q</code>。</td>
</tr>
<tr>
<td><code>p.reset(q)</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>p.reset(q, d)</code></td>
<td>同上</td>
</tr>
</tbody>
</table>
<h4 id="智能指针和异常">智能指针和异常</h4>
<ul>
<li>如果使用智能指针，即使程序块由于异常过早结束，智能指针类也能确保在内存不需要的时候将其释放。</li>
<li><strong>智能指针陷阱</strong>：
<ul>
<li>不用相同的内置指针初始化（或<code>reset</code>）多个智能指针</li>
<li>不<code>delete get()</code>返回的指针。</li>
<li>如果你使用<code>get()</code>返回的指针，记得当最后一个对应的智能指针销毁后，你的指针就无效了。</li>
<li>如果你使用智能指针管理的资源不是<code>new</code>分配的内存，记住传递给它一个删除器。</li>
</ul>
</li>
</ul>
<h4 id="unique-ptr">unique_ptr</h4>
<ul>
<li>某一个时刻只能有一个<code>unique_ptr</code>指向一个给定的对象。</li>
<li>不支持拷贝或者赋值操作。</li>
<li>向后兼容：<code>auto_ptr</code>：老版本，具有<code>unique_ptr</code>的部分特性。特别是，不能在容器中保存<code>auto_ptr</code>，也不能从函数返回<code>auto_ptr</code>。</li>
</ul>
<p><strong>unique_ptr操作</strong>:</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>unique_ptr&lt;T&gt; u1</code></td>
<td>空<code>unique_ptr</code>，可以指向类型是<code>T</code>的对象。<code>u1</code>会使用<code>delete</code>来是释放它的指针。</td>
</tr>
<tr>
<td><code>unique_ptr&lt;T, D&gt; u2</code></td>
<td><code>u2</code>会使用一个类型为<code>D</code>的可调用对象来释放它的指针。</td>
</tr>
<tr>
<td><code>unique_ptr&lt;T, D&gt; u(d)</code></td>
<td>空<code>unique_ptr</code>，指向类型为<code>T</code>的对象，用类型为<code>D</code>的对象<code>d</code>代替<code>delete</code></td>
</tr>
<tr>
<td><code>u = nullptr</code></td>
<td>释放<code>u</code>指向的对象，将<code>u</code>置为空。</td>
</tr>
<tr>
<td><code>u.release()</code></td>
<td><code>u</code>放弃对指针的控制权，返回指针，并将<code>u</code>置空。</td>
</tr>
<tr>
<td><code>u.reset()</code></td>
<td>释放<code>u</code>指向的对象</td>
</tr>
<tr>
<td><code>u.reset(q)</code></td>
<td>令<code>u</code>指向<code>q</code>指向的对象</td>
</tr>
<tr>
<td><code>u.reset(nullptr)</code></td>
<td>将<code>u</code>置空</td>
</tr>
</tbody>
</table>
<h4 id="weak-ptr">weak_ptr</h4>
<ul>
<li><code>weak_ptr</code>是一种不控制所指向对象生存期的智能指针。</li>
<li>指向一个由<code>shared_ptr</code>管理的对象，不改变<code>shared_ptr</code>的引用计数。</li>
<li>一旦最后一个指向对象的<code>shared_ptr</code>被销毁，对象就会被释放，不管有没有<code>weak_ptr</code>指向该对象。</li>
</ul>
<p><strong>weak_ptr操作</strong>:</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>weak_ptr&lt;T&gt; w</code></td>
<td>空<code>weak_ptr</code>可以指向类型为<code>T</code>的对象</td>
</tr>
<tr>
<td><code>weak_ptr&lt;T&gt; w(sp)</code></td>
<td>与<code>shared_ptr</code>指向相同对象的<code>weak_ptr</code>。<code>T</code>必须能转换为<code>sp</code>指向的类型。</td>
</tr>
<tr>
<td><code>w = p</code></td>
<td><code>p</code>可以是<code>shared_ptr</code>或一个<code>weak_ptr</code>。赋值后<code>w</code>和<code>p</code>共享对象。</td>
</tr>
<tr>
<td><code>w.reset()</code></td>
<td>将<code>w</code>置为空。</td>
</tr>
<tr>
<td><code>w.use_count()</code></td>
<td>与<code>w</code>共享对象的<code>shared_ptr</code>的数量。</td>
</tr>
<tr>
<td><code>w.expired()</code></td>
<td>若<code>w.use_count()</code>为0，返回<code>true</code>，否则返回<code>false</code></td>
</tr>
<tr>
<td><code>w.lock()</code></td>
<td>如果<code>expired</code>为<code>true</code>，则返回一个空<code>shared_ptr</code>；否则返回一个指向<code>w</code>的对象的<code>shared_ptr</code>。</td>
</tr>
</tbody>
</table>
<h3 id="动态数组">动态数组</h3>
<h4 id="new和数组">new和数组</h4>
<ul>
<li>
<p><code>new</code>一个动态数组：</p>
<ul>
<li>类型名之后加一对方括号，指明分配的对象数目（必须是整型，不必是常量）。</li>
<li>返回<strong>指向第一个对象的指针</strong>。</li>
<li><code>int *p = new int[size];</code></li>
</ul>
</li>
<li>
<p><code>delete</code>一个动态数组：</p>
<ul>
<li><code>delete [] p;</code></li>
</ul>
</li>
<li>
<p><code>unique_ptr</code>和数组：</p>
<ul>
<li>指向数组的<code>unique_ptr</code>不支持成员访问运算符（点和箭头）。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>unique_ptr&lt;T[]&gt; u</code></td>
<td><code>u</code>可以指向一个动态分配的数组，整数元素类型为<code>T</code></td>
</tr>
<tr>
<td><code>unique_ptr&lt;T[]&gt; u(p)</code></td>
<td><code>u</code>指向内置指针<code>p</code>所指向的动态分配的数组。<code>p</code>必须能转换为类型<code>T*</code>。</td>
</tr>
<tr>
<td><code>u[i]</code></td>
<td>返回<code>u</code>拥有的数组中位置<code>i</code>处的对象。<code>u</code>必须指向一个数组。</td>
</tr>
</tbody>
</table>
<h4 id="allocator类">allocator类</h4>
<ul>
<li>标准库<code>allocator</code>类定义在头文件<code>memory</code>中，帮助我们将内存分配和对象构造分离开。</li>
<li>分配的是原始的、未构造的内存。</li>
<li><code>allocator</code>是一个模板。</li>
<li><code>allocator&lt;string&gt; alloc;</code></li>
</ul>
<p><strong>标准库allocator类及其算法</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>allocator&lt;T&gt; a</code></td>
<td>定义了一个名为<code>a</code>的<code>allocator</code>对象，它可以为类型为<code>T</code>的对象分配内存</td>
</tr>
<tr>
<td><code>a.allocate(n)</code></td>
<td>分配一段原始的、未构造的内存，保存<code>n</code>个类型为<code>T</code>的对象。</td>
</tr>
<tr>
<td><code>a.deallocate(p, n)</code></td>
<td>释放从<code>T*</code>指针<code>p</code>中地址开始的内存，这块内存保存了<code>n</code>个类型为<code>T</code>的对象；<code>p</code>必须是一个先前由<code>allocate</code>返回的指针。且<code>n</code>必须是<code>p</code>创建时所要求的大小。在调用<code>deallocate</code>之前，用户必须对每个在这块内存中创建的对象调用<code>destroy</code>。</td>
</tr>
<tr>
<td><code>a.construct(p, args)</code></td>
<td><code>p</code>必须是一个类型是<code>T*</code>的指针，指向一块原始内存；<code>args</code>被传递给类型为<code>T</code>的构造函数，用来在<code>p</code>指向的内存中构造一个对象。</td>
</tr>
<tr>
<td><code>a.destroy(p)</code></td>
<td><code>p</code>为<code>T*</code>类型的指针，此算法对<code>p</code>指向的对象执行析构函数。</td>
</tr>
</tbody>
</table>
<p><strong>allocator伴随算法</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>uninitialized_copy(b, e, b2)</code></td>
<td>从迭代器<code>b</code>和<code>e</code>给定的输入范围中拷贝元素到迭代器<code>b2</code>指定的未构造的原始内存中。<code>b2</code>指向的内存必须足够大，能够容纳输入序列中元素的拷贝。</td>
</tr>
<tr>
<td><code>uninitialized_copy_n(b, n, b2)</code></td>
<td>从迭代器<code>b</code>指向的元素开始，拷贝<code>n</code>个元素到<code>b2</code>开始的内存中。</td>
</tr>
<tr>
<td><code>uninitialized_fill(b, e, t)</code></td>
<td>在迭代器<code>b</code>和<code>e</code>执行的原始内存范围中创建对象，对象的值均为<code>t</code>的拷贝。</td>
</tr>
<tr>
<td><code>uninitialized_fill_n(b, n, t)</code></td>
<td>从迭代器<code>b</code>指向的内存地址开始创建<code>n</code>个对象。<code>b</code>必须指向足够大的未构造的原始内存，能够容纳给定数量的对象。</td>
</tr>
</tbody>
</table>
<ul>
<li>定义在头文件<code>memory</code>中。</li>
<li>在给定目的位置创建元素，而不是由系统分配内存给他们。</li>
</ul>
<hr>
<h2 id="第12章-动态内存">第12章 动态内存</h2>
<p>程序用堆（heap）来存储动态分配（dynamically allocate）的对象。动态对象的生存期由程序控制。</p>
<h3 id="动态内存与智能指针（Dynamic-Memory-and-Smart-Pointers）">动态内存与智能指针（Dynamic Memory and Smart Pointers）</h3>
<p>C++中的动态内存管理通过一对运算符完成：<code>new</code>在动态内存中为对象分配空间并返回指向该对象的指针，可以选择对对象进行初始化；<code>delete</code>接受一个动态对象的指针，销毁该对象并释放与之关联的内存。</p>
<p>新标准库提供了两种智能指针（smart pointer）类型来管理动态对象。智能指针的行为类似常规指针，但它自动释放所指向的对象。这两种智能指针的区别在于管理底层指针的方式：<code>shared_ptr</code>允许多个指针指向同一个对象；<code>unique_ptr</code>独占所指向的对象。标准库还定义了一个名为<code>weak_ptr</code>的伴随类，它是一种弱引用，指向<code>shared_ptr</code>所管理的对象。这三种类型都定义在头文件<code>memory</code>中。</p>
<h4 id="shared-ptr类（The-shared-ptr-Class）">shared_ptr类（The shared_ptr Class）</h4>
<p>智能指针是模板，创建时需要指明指针可以指向的类型。默认初始化的智能指针中保存着一个空指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p1;      <span class="comment">// shared_ptr that can point at a string</span></span><br><span class="line">shared_ptr&lt;list&lt;<span class="keyword">int</span>&gt;&gt; p2;   <span class="comment">// shared_ptr that can point at a list of ints</span></span><br></pre></td></tr></table></figure>
<p><code>shared_ptr</code>和<code>unique_ptr</code>都支持的操作：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031648188.png" alt="12-1" style="zoom:80%;" />
<p><code>shared_ptr</code>独有的操作：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031648189.png" alt="12-2" style="zoom:80%;" />
<p><code>make_shared</code>函数（定义在头文件<code>memory</code>中）在动态内存中分配一个对象并初始化它，返回指向此对象的<code>shared_ptr</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared_ptr that points to an int with value 42</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p3 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// p4 points to a string with value 9999999999</span></span><br><span class="line">shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(<span class="number">10</span>, <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"><span class="comment">// p5 points to an int that is value initialized</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p5 = make_shared&lt;<span class="keyword">int</span>&gt;();</span><br></pre></td></tr></table></figure>
<p>进行拷贝或赋值操作时，每个<code>shared_ptr</code>会记录有多少个其他<code>shared_ptr</code>与其指向相同的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);  <span class="comment">// object to which p points has one user</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>;  <span class="comment">// p and q point to the same object</span></span><br><span class="line">            <span class="comment">// object to which p and q point has two users</span></span><br></pre></td></tr></table></figure>
<p>每个<code>shared_ptr</code>都有一个与之关联的计数器，通常称为引用计数（reference count）。拷贝<code>shared_ptr</code>时引用计数会递增。例如使用一个<code>shared_ptr</code>初始化另一个<code>shared_ptr</code>，或将它作为参数传递给函数以及作为函数的返回值返回。给<code>shared_ptr</code>赋予新值或<code>shared_ptr</code>被销毁时引用计数会递减。例如一个局部<code>shared_ptr</code>离开其作用域。一旦一个<code>shared_ptr</code>的引用计数变为0，它就会自动释放其所管理的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);  <span class="comment">// int to which r points has one user</span></span><br><span class="line">r = q;  <span class="comment">// assign to r, making it point to a different address</span></span><br><span class="line">        <span class="comment">// increase the use count for the object to which q points</span></span><br><span class="line">        <span class="comment">// reduce the use count of the object to which r had pointed</span></span><br><span class="line">        <span class="comment">// the object r had pointed to has no users; that object is automatically freed</span></span><br></pre></td></tr></table></figure>
<p><code>shared_ptr</code>的析构函数会递减它所指向对象的引用计数。如果引用计数变为0，<code>shared_ptr</code>的析构函数会销毁对象并释放空间。</p>
<p>如果将<code>shared_ptr</code>存放于容器中，而后不再需要全部元素，而只使用其中一部分，应该用<code>erase</code>删除不再需要的元素。</p>
<p>程序使用动态内存通常出于以下三种原因之一：</p>
<ul>
<li>不确定需要使用多少对象。</li>
<li>不确定所需对象的准确类型。</li>
<li>需要在多个对象间共享数据。</li>
</ul>
<h4 id="直接管理内存（Managing-Memory-Directly）">直接管理内存（Managing Memory Directly）</h4>
<p>相对于智能指针，使用<code>new</code>和<code>delete</code>管理内存很容易出错。</p>
<p>默认情况下，动态分配的对象是默认初始化的。所以内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string *ps = <span class="keyword">new</span> string;    <span class="comment">// initialized to empty string</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>;     <span class="comment">// pi points to an uninitialized int</span></span><br></pre></td></tr></table></figure>
<p>可以使用值初始化方式、直接初始化方式、传统构造方式（圆括号<code>()</code>）或新标准下的列表初始化方式（花括号<code>&#123;&#125;</code>）初始化动态分配的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1024</span>);            <span class="comment">// object to which pi points has value 1024</span></span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">&#x27;9&#x27;</span>);   <span class="comment">// *ps is &quot;9999999999&quot;</span></span><br><span class="line"><span class="comment">// vector with ten elements with values from 0 to 9</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; *pv = <span class="keyword">new</span> vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">string *ps1 = <span class="keyword">new</span> string;     <span class="comment">// default initialized to the empty string</span></span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>();    <span class="comment">// value initialized to the empty string</span></span><br><span class="line"><span class="keyword">int</span> *pi1 = <span class="keyword">new</span> <span class="keyword">int</span>;      <span class="comment">// default initialized; *pi1 is undefined</span></span><br><span class="line"><span class="keyword">int</span> *pi2 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>();    <span class="comment">// value initialized to 0; *pi2 is 0</span></span><br></pre></td></tr></table></figure>
<p>只有当初始化的括号中仅有单一初始化器时才可以使用<code>auto</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">auto</span></span>(obj);    <span class="comment">// p points to an object of the type of obj</span></span><br><span class="line">                            <span class="comment">// that object is initialized from obj</span></span><br><span class="line"><span class="keyword">auto</span> p2 = <span class="keyword">new</span> <span class="keyword">auto</span>&#123;a,b,c&#125;;  <span class="comment">// error: must use parentheses for the initializer</span></span><br></pre></td></tr></table></figure>
<p>可以用<code>new</code>分配<code>const</code>对象，返回指向<code>const</code>类型的指针。动态分配的<code>const</code>对象必须初始化。</p>
<p>默认情况下，如果<code>new</code>不能分配所要求的内存空间，会抛出<code>bad_alloc</code>异常。使用定位<code>new</code>（placement new）可以阻止其抛出异常。定位<code>new</code>表达式允许程序向<code>new</code>传递额外参数。如果将<code>nothrow</code>传递给<code>new</code>，则<code>new</code>在分配失败后会返回空指针。<code>bad_alloc</code>和<code>nothrow</code>都定义在头文件<code>new</code>中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if allocation fails, new returns a null pointer</span></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>;            <span class="comment">// if allocation fails, new throws std::bad_alloc</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="built_in"><span class="keyword">new</span></span> (nothrow) <span class="keyword">int</span>;  <span class="comment">// if allocation fails, new returns a null pointer</span></span><br></pre></td></tr></table></figure>
<p>使用<code>delete</code>释放一块并非<code>new</code>分配的内存，或者将相同的指针值释放多次的行为是未定义的。</p>
<p>由内置指针管理的动态对象在被显式释放前一直存在。</p>
<p><code>delete</code>一个指针后，指针值就无效了（空悬指针，dangling pointer）。为了防止后续的错误访问，应该在<code>delete</code>之后将指针值置空。</p>
<h4 id="shared-ptr和new结合使用（Using-shared-ptrs-with-new）">shared_ptr和new结合使用（Using shared_ptrs with new）</h4>
<p>可以用<code>new</code>返回的指针初始化智能指针。该构造函数是<code>explicit</code>的，因此必须使用直接初始化形式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1024</span>);    <span class="comment">// error: must use direct initialization</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>;     <span class="comment">// ok: uses direct initialization</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，用来初始化智能指针的内置指针必须指向动态内存，因为智能指针默认使用<code>delete</code>释放它所管理的对象。如果要将智能指针绑定到一个指向其他类型资源的指针上，就必须提供自定义操作来代替<code>delete</code>。</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031648186.png" alt="12-3" style="zoom:80%;" />
<p>不要混合使用内置指针和智能指针。当将<code>shared_ptr</code>绑定到内置指针后，资源管理就应该交由<code>shared_ptr</code>负责。不应该再使用内置指针访问<code>shared_ptr</code>指向的内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ptr is created and initialized when process is called</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(shared_ptr&lt;<span class="keyword">int</span>&gt; ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// use ptr</span></span><br><span class="line">&#125;   <span class="comment">// ptr goes out of scope and is destroyed</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>;   <span class="comment">// dangerous: x is a plain pointer, not a smart pointer</span></span><br><span class="line"><span class="built_in">process</span>(x);     <span class="comment">// error: cannot convert int* to shared_ptr&lt;int&gt;</span></span><br><span class="line"><span class="built_in">process</span>(shared_ptr&lt;<span class="keyword">int</span>&gt;(x));    <span class="comment">// legal, but the memory will be deleted!</span></span><br><span class="line"><span class="keyword">int</span> j = *x;     <span class="comment">// undefined: x is a dangling pointer!</span></span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>;   <span class="comment">// reference count is 1</span></span><br><span class="line"><span class="built_in">process</span>(p);     <span class="comment">// copying p increments its count; in process the reference count is 2</span></span><br><span class="line"><span class="keyword">int</span> i = *p;     <span class="comment">// ok: reference count is 1</span></span><br></pre></td></tr></table></figure>
<p>智能指针的<code>get</code>函数返回一个内置指针，指向智能指针管理的对象。主要用于向不能使用智能指针的代码传递内置指针。使用<code>get</code>返回指针的代码不能<code>delete</code>此指针。</p>
<p>不要使用<code>get</code>初始化另一个智能指针或为智能指针赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>;    <span class="comment">// reference count is 1</span></span><br><span class="line"><span class="keyword">int</span> *q = p.<span class="built_in">get</span>();   <span class="comment">// ok: but don&#x27;t use q in any way that might delete its pointer</span></span><br><span class="line">&#123;   <span class="comment">// new block</span></span><br><span class="line">    <span class="comment">// undefined: two independent shared_ptrs point to the same memory</span></span><br><span class="line">    shared_ptr&lt;<span class="keyword">int</span>&gt;(q);</span><br><span class="line">&#125; <span class="comment">// block ends, q is destroyed, and the memory to which q points is freed</span></span><br><span class="line"><span class="keyword">int</span> foo = *p;   <span class="comment">// undefined; the memory to which p points was freed</span></span><br></pre></td></tr></table></figure>
<p>可以用<code>reset</code>函数将新的指针赋予<code>shared_ptr</code>。与赋值类似，<code>reset</code>会更新引用计数，如果需要的话，还会释放内存空间。<code>reset</code>经常与<code>unique</code>一起使用，来控制多个<code>shared_ptr</code>共享的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p.<span class="built_in">unique</span>())</span><br><span class="line">    p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p));   <span class="comment">// we aren&#x27;t alone; allocate a new copy</span></span><br><span class="line">*p += newVal;   <span class="comment">// now that we know we&#x27;re the only pointer, okay to change this object</span></span><br></pre></td></tr></table></figure>
<h4 id="智能指针和异常（Smart-Pointers-and-Exceptions）">智能指针和异常（Smart Pointers and Exceptions）</h4>
<p>如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">42</span>);    <span class="comment">// dynamically allocate a new object</span></span><br><span class="line">    <span class="comment">// code that throws an exception that is not caught inside f</span></span><br><span class="line">    <span class="keyword">delete</span> ip;     <span class="comment">// free the memory before exiting</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>;    <span class="comment">// allocate a new object</span></span><br><span class="line">    <span class="comment">// code that throws an exception that is not caught inside f</span></span><br><span class="line">&#125; <span class="comment">// shared_ptr freed automatically when the function ends</span></span><br></pre></td></tr></table></figure>
<p>默认情况下<code>shared_ptr</code>假定其指向动态内存，使用<code>delete</code>释放对象。创建<code>shared_ptr</code>时可以传递一个（可选）指向删除函数的指针参数，用来代替<code>delete</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">destination</span>;</span>    <span class="comment">// represents what we are connecting to</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">connection</span>;</span>     <span class="comment">// information needed to use the connection</span></span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destination*)</span></span>;   <span class="comment">// open the connection</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(connection)</span></span>;    <span class="comment">// close the given connection</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">disconnect</span>(*p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* other parameters */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    connection c = <span class="built_in">connect</span>(&amp;d);</span><br><span class="line">    <span class="function">shared_ptr&lt;connection&gt; <span class="title">p</span><span class="params">(&amp;c, end_connection)</span></span>;</span><br><span class="line">    <span class="comment">// use the connection</span></span><br><span class="line">    <span class="comment">// when f exits, even if by an exception, the connection will be properly closed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>智能指针规范：</p>
<ul>
<li>不使用相同的内置指针值初始化或<code>reset</code>多个智能指针。</li>
<li>不释放<code>get</code>返回的指针。</li>
<li>不使用<code>get</code>初始化或<code>reset</code>另一个智能指针。</li>
<li>使用<code>get</code>返回的指针时，如果最后一个对应的智能指针被销毁，指针就无效了。</li>
<li>使用<code>shared_ptr</code>管理并非<code>new</code>分配的资源时，应该传递删除函数。</li>
</ul>
<h4 id="unique-ptr（unique-ptr）">unique_ptr（unique_ptr）</h4>
<p>与<code>shared_ptr</code>不同，同一时刻只能有一个<code>unique_ptr</code>指向给定的对象。当<code>unique_ptr</code>被销毁时，它指向的对象也会被销毁。</p>
<p><code>make_unique</code>函数（C++14新增，定义在头文件<code>memory</code>中）在动态内存中分配一个对象并初始化它，返回指向此对象的<code>unique_ptr</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="comment">// C++14</span></span><br><span class="line">unique_ptr&lt;<span class="keyword">int</span>&gt; p2 = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>由于<code>unique_ptr</code>独占其指向的对象，因此<code>unique_ptr</code>不支持普通的拷贝或赋值操作。</p>
<p><code>unique_ptr</code>操作：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031657608.png" alt="12-4" style="zoom:80%;" />
<p><code>release</code>函数返回<code>unique_ptr</code>当前保存的指针并将其置为空。</p>
<p><code>reset</code>函数成员接受一个可选的指针参数，重新设置<code>unique_ptr</code>保存的指针。如果<code>unique_ptr</code>不为空，则它原来指向的对象会被释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transfers ownership from p1 (which points to the string Stegosaurus) to p2</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>;    <span class="comment">// release makes p1 null</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Trex&quot;</span>))</span></span>;</span><br><span class="line"><span class="comment">// transfers ownership from p3 to p2</span></span><br><span class="line">p2.<span class="built_in">reset</span>(p3.<span class="built_in">release</span>()); <span class="comment">// reset deletes the memory to which p2 had pointed</span></span><br></pre></td></tr></table></figure>
<p>调用<code>release</code>会切断<code>unique_ptr</code>和它原来管理的对象之间的联系。<code>release</code>返回的指针通常被用来初始化另一个智能指针或给智能指针赋值。如果没有用另一个智能指针保存<code>release</code>返回的指针，程序就要负责资源的释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p2.<span class="built_in">release</span>();   <span class="comment">// WRONG: p2 won&#x27;t free the memory and we&#x27;ve lost the pointer</span></span><br><span class="line"><span class="keyword">auto</span> p = p2.<span class="built_in">release</span>();   <span class="comment">// ok, but we must remember to delete(p)</span></span><br></pre></td></tr></table></figure>
<p>不能拷贝<code>unique_ptr</code>的规则有一个例外：可以拷贝或赋值一个即将被销毁的<code>unique_ptr</code>（移动构造、移动赋值）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span> (p))</span></span>;</span><br><span class="line">    <span class="comment">// . . .</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>老版本的标准库包含了一个名为<code>auto_ptr</code>的类，</p>
<p>类似<code>shared_ptr</code>，默认情况下<code>unique_ptr</code>用<code>delete</code>释放其指向的对象。<code>unique_ptr</code>的删除器同样可以重载，但<code>unique_ptr</code>管理删除器的方式与<code>shared_ptr</code>不同。定义<code>unique_ptr</code>时必须在尖括号中提供删除器类型。创建或<code>reset</code>这种<code>unique_ptr</code>类型的对象时，必须提供一个指定类型的可调用对象（删除器）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p points to an object of type objT and uses an object of type delT to free that object</span></span><br><span class="line"><span class="comment">// it will call an object named fcn of type delT</span></span><br><span class="line"><span class="function">unique_ptr&lt;objT, delT&gt; <span class="title">p</span> <span class="params">(<span class="keyword">new</span> objT, fcn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* other needed parameters */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    connection c = <span class="built_in">connect</span>(&amp;d);  <span class="comment">// open the connection</span></span><br><span class="line">    <span class="comment">// when p is destroyed, the connection will be closed</span></span><br><span class="line">    <span class="function">unique_ptr&lt;connection, <span class="title">decltype</span><span class="params">(end_connection)</span>*&gt; <span class="title">p</span><span class="params">(&amp;c, end_connection)</span></span>;</span><br><span class="line">    <span class="comment">// use the connection</span></span><br><span class="line">    <span class="comment">// when f exits, even if by an exception, the connection will be properly closed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="weak-ptr（weak-ptr）">weak_ptr（weak_ptr）</h4>
<p><code>weak_ptr</code>是一种不控制所指向对象生存期的智能指针，它指向一个由<code>shared_ptr</code>管理的对象。将<code>weak_ptr</code>绑定到<code>shared_ptr</code>不会改变<code>shared_ptr</code>的引用计数。如果<code>shared_ptr</code>被销毁，即使有<code>weak_ptr</code>指向对象，对象仍然有可能被释放。</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031657906.png" alt="12-5" style="zoom:80%;" />
<p>创建一个<code>weak_ptr</code>时，需要使用<code>shared_ptr</code>来初始化它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>;    <span class="comment">// wp weakly shares with p; use count in p is unchanged</span></span><br></pre></td></tr></table></figure>
<p>使用<code>weak_ptr</code>访问对象时，必须先调用<code>lock</code>函数。该函数检查<code>weak_ptr</code>指向的对象是否仍然存在。如果存在，则返回指向共享对象的<code>shared_ptr</code>，否则返回空指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shared_ptr&lt;<span class="keyword">int</span>&gt; np = wp.<span class="built_in">lock</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// true if np is not null</span></span><br><span class="line">    <span class="comment">// inside the if, np shares its object with p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态数组（Dynamic-Arrays）">动态数组（Dynamic Arrays）</h3>
<p>使用<code>allocator</code>类可以将内存分配和初始化过程分离，这通常会提供更好的性能和更灵活的内存管理能力。</p>
<h4 id="new和数组（new-and-Arrays）">new和数组（new and Arrays）</h4>
<p>使用<code>new</code>分配对象数组时需要在类型名之后跟一对方括号，在其中指明要分配的对象数量（必须是整型，但不必是常量）。<code>new</code>返回指向第一个对象的指针（元素类型）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call get_size to determine how many ints to allocate</span></span><br><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">get_size</span>()];   <span class="comment">// pia points to the first of these ints</span></span><br></pre></td></tr></table></figure>
<p>由于<code>new</code>分配的内存并不是数组类型，因此不能对动态数组调用<code>begin</code>和<code>end</code>，也不能用范围<code>for</code>语句处理其中的元素。</p>
<p>默认情况下，<code>new</code>分配的对象是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小后面跟一对空括号<code>()</code>。在新标准中，还可以提供一个元素初始化器的花括号列表。如果初始化器数量大于元素数量，则<code>new</code>表达式失败，不会分配任何内存，并抛出<code>bad_array_new_length</code>异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];     <span class="comment">// block of ten uninitialized ints</span></span><br><span class="line"><span class="keyword">int</span> *pia2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]();    <span class="comment">// block of ten ints value initialized to 0</span></span><br><span class="line">string *psa = <span class="keyword">new</span> string[<span class="number">10</span>];    <span class="comment">// block of ten empty strings</span></span><br><span class="line">string *psa2 = <span class="keyword">new</span> string[<span class="number">10</span>]();    <span class="comment">// block of ten empty strings</span></span><br><span class="line"><span class="comment">// block of ten ints each initialized from the corresponding initializer</span></span><br><span class="line"><span class="keyword">int</span> *pia3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>] &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">// block of ten strings; the first four are initialized from the given initializers</span></span><br><span class="line"><span class="comment">// remaining elements are value initialized</span></span><br><span class="line">string *psa3 = <span class="keyword">new</span> string[<span class="number">10</span>] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="built_in">string</span>(<span class="number">3</span>,<span class="string">&#x27;x&#x27;</span>) &#125;;</span><br></pre></td></tr></table></figure>
<p>虽然可以使用空括号对<code>new</code>分配的数组元素进行值初始化，但不能在括号中指定初始化器。这意味着不能用<code>auto</code>分配数组。</p>
<p>动态分配一个空数组是合法的，此时<code>new</code>会返回一个合法的非空指针。对于零长度的数组来说，该指针类似尾后指针，不能解引用。</p>
<p>使用<code>delete[]</code>释放动态数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;       <span class="comment">// p must point to a dynamically allocated object or be null</span></span><br><span class="line"><span class="keyword">delete</span> [] pa;   <span class="comment">// pa must point to a dynamically allocated array or be null</span></span><br></pre></td></tr></table></figure>
<p>如果在<code>delete</code>数组指针时忘记添加方括号，或者在<code>delete</code>单一对象时使用了方括号，编译器很可能不会给出任何警告，程序可能会在执行过程中行为异常。</p>
<p><code>unique_ptr</code>可以直接管理动态数组，定义时需要在对象类型后添加一对空方括号<code>[]</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// up points to an array of ten uninitialized ints</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>[]&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line">up.<span class="built_in">release</span>();   <span class="comment">// automatically uses delete[] to destroy its pointer</span></span><br></pre></td></tr></table></figure>
<p>指向数组的<code>unique_ptr</code>：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031657623.png" alt="12-6" style="zoom:80%;" />
<p>与<code>unique_ptr</code>不同，<code>shared_ptr</code>不直接支持动态数组管理。如果想用<code>shared_ptr</code>管理动态数组，必须提供自定义的删除器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// to use a shared_ptr we must supply a deleter</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span> *p) &#123; <span class="keyword">delete</span>[] p; &#125;)</span></span>;</span><br><span class="line">sp.<span class="built_in">reset</span>();    <span class="comment">// uses the lambda we supplied that uses delete[] to free the array</span></span><br></pre></td></tr></table></figure>
<p><code>shared_ptr</code>未定义下标运算符，智能指针类型也不支持指针算术运算。因此如果想访问<code>shared_ptr</code>管理的数组元素，必须先用<code>get</code>获取内置指针，再用内置指针进行访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared_ptrs don&#x27;t have subscript operator and don&#x27;t support pointer arithmetic</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    *(sp.<span class="built_in">get</span>() + i) = i;    <span class="comment">// use get to get a built-in pointer</span></span><br></pre></td></tr></table></figure>
<h4 id="allocator类（The-allocator-Class）">allocator类（The allocator Class）</h4>
<p><code>allocator</code>类是一个模板，定义时必须指定其可以分配的对象类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;string&gt; alloc;    <span class="comment">// object that can allocate strings</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> p = alloc.<span class="built_in">allocate</span>(n);   <span class="comment">// allocate n unconstructed strings</span></span><br></pre></td></tr></table></figure>
<p>标准库<code>allocator</code>类及其算法：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031649473.png" alt="12-7" style="zoom:80%;" />
<p><code>allocator</code>分配的内存是未构造的，程序需要在此内存中构造对象。新标准库的<code>construct</code>函数接受一个指针和零或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象，必须与对象类型相匹配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> q = p;     <span class="comment">// q will point to one past the last constructed element</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++);    <span class="comment">// *q is the empty string</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++, <span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>);  <span class="comment">// *q is cccccccccc</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++, <span class="string">&quot;hi&quot;</span>);     <span class="comment">// *q is hi!</span></span><br></pre></td></tr></table></figure>
<p>直接使用<code>allocator</code>返回的未构造内存是错误行为，其结果是未定义的。</p>
<p>对象使用完后，必须对每个构造的元素调用<code>destroy</code>进行销毁。<code>destroy</code>函数接受一个指针，对指向的对象执行析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (q != p)</span><br><span class="line">    alloc.<span class="built_in">destroy</span>(--q);  <span class="comment">// free the strings we actually allocated</span></span><br></pre></td></tr></table></figure>
<p><code>deallocate</code>函数用于释放<code>allocator</code>分配的内存空间。传递给<code>deallocate</code>的指针不能为空，它必须指向由<code>allocator</code>分配的内存。而且传递给<code>deallocate</code>的大小参数必须与调用<code>allocator</code>分配内存时提供的大小参数相一致。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc.<span class="built_in">deallocate</span>(p, n);</span><br></pre></td></tr></table></figure>
<p><code>allocator</code>算法：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031658147.png" alt="12-8" style="zoom:80%;" />
<p>传递给<code>uninitialized_copy</code>的目的位置迭代器必须指向未构造的内存，它直接在给定位置构造元素。返回（递增后的）目的位置迭代器。</p>
<hr>
<h2 id="第13章-拷贝控制（简）">第13章 拷贝控制（简）</h2>
<p><strong>拷贝控制操作</strong>（copy control）:</p>
<ul>
<li>拷贝构造函数（copy constructor）</li>
<li>拷贝赋值运算符（copy-assignment operator）</li>
<li>移动构造函数（move constructor）</li>
<li>移动赋值函数（move-assignement operator）</li>
<li>析构函数（destructor）</li>
</ul>
<h3 id="拷贝、赋值和销毁">拷贝、赋值和销毁</h3>
<h4 id="拷贝构造函数">拷贝构造函数</h4>
<ul>
<li>如果一个构造函数的第一个参数是<strong>自身类类型的引用</strong>，且任何额外参数都有默认值，则此构造函数是<strong>拷贝构造函数</strong>。</li>
<li><code>class Foo&#123; public: Foo(const Foo&amp;); &#125;</code></li>
<li><strong>合成的拷贝构造函数</strong>（synthesized copy constructor）：会将参数的成员逐个拷贝到正在创建的对象中。</li>
<li><strong>拷贝初始化</strong>：
<ul>
<li>将右侧运算对象拷贝到正在创建的对象中，如果需要，还需进行类型转换。</li>
<li>通常使用拷贝构造函数完成。</li>
<li><code>string book = &quot;9-99&quot;;</code></li>
<li>出现场景：
<ul>
<li>用<code>=</code>定义变量时。</li>
<li>将一个对象作为实参传递给一个非引用类型的形参。</li>
<li>从一个返回类型为非引用类型的函数返回一个对象。</li>
<li>用花括号列表初始化一个数组中的元素或者一个聚合类中的成员。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="拷贝赋值运算符">拷贝赋值运算符</h4>
<ul>
<li><strong>重载赋值运算符</strong>：
<ul>
<li>重写一个名为<code>operator=</code>的函数.</li>
<li>通常返回一个指向其左侧运算对象的引用。</li>
<li><code>Foo&amp; operator=(const Foo&amp;);</code></li>
</ul>
</li>
<li><strong>合成拷贝赋值运算符</strong>：
<ul>
<li>将右侧运算对象的每个非<code>static</code>成员赋予左侧运算对象的对应成员。</li>
</ul>
</li>
</ul>
<h4 id="析构函数">析构函数</h4>
<ul>
<li>释放对象所使用的资源，并销毁对象的非<code>static</code>数据成员。</li>
<li>名字由波浪号接类名构成。没有返回值，也不接受参数。</li>
<li><code>~Foo();</code></li>
<li>调用时机：
<ul>
<li>变量在离开其作用域时。</li>
<li>当一个对象被销毁时，其成员被销毁。</li>
<li>容器被销毁时，其元素被销毁。</li>
<li>动态分配的对象，当对指向它的指针应用<code>delete</code>运算符时。</li>
<li>对于临时对象，当创建它的完整表达式结束时。</li>
</ul>
</li>
<li><strong>合成析构函数</strong>：
<ul>
<li>空函数体执行完后，<strong>成员会被自动销毁。</strong></li>
<li>注意：析构函数体本身并不直接销毁成员。</li>
</ul>
</li>
</ul>
<h4 id="三-五法则">三/五法则</h4>
<ul>
<li>需要析构函数的类也需要拷贝和赋值操作。</li>
<li>需要拷贝操作的类也需要赋值操作，反之亦然。</li>
</ul>
<h4 id="使用-default">使用=default</h4>
<ul>
<li>可以通过将拷贝控制成员定义为<code>=default</code>来显式地要求编译器生成合成的版本。</li>
<li>合成的函数将隐式地声明为内联的。</li>
</ul>
<h4 id="阻止拷贝">阻止拷贝</h4>
<ul>
<li>大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。</li>
<li>定义删除的函数：<code>=delete</code>。</li>
<li>虽然声明了它们，但是不能以任何方式使用它们。</li>
<li>析构函数不能是删除的成员。</li>
<li>如果一个类有数据成员不能默认构造、拷贝、复制或者销毁，则对应的成员函数将被定义为删除的。</li>
<li>老版本使用<code>private</code>声明来阻止拷贝。</li>
</ul>
<h3 id="拷贝控制和资源管理">拷贝控制和资源管理</h3>
<ul>
<li>类的行为可以像一个值，也可以像一个指针。
<ul>
<li>行为像值：对象有自己的状态，副本和原对象是完全独立的。</li>
<li>行为像指针：共享状态，拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。</li>
</ul>
</li>
</ul>
<h3 id="交换操作">交换操作</h3>
<ul>
<li>管理资源的类通常还定义一个名为<code>swap</code>的函数。</li>
<li>经常用于重排元素顺序的算法。</li>
<li>用<code>swap</code>而不是<code>std::swap</code>。</li>
</ul>
<h3 id="对象移动">对象移动</h3>
<ul>
<li>很多拷贝操作后，原对象会被销毁，因此引入移动操作可以大幅度提升性能。</li>
<li>在新标准中，我们可以用容器保存不可拷贝的类型，只要它们可以被移动即可。</li>
<li>标准库容器、<code>string</code>和<code>shared_ptr</code>类既可以支持移动也支持拷贝。<code>IO</code>类和<code>unique_ptr</code>类可以移动但不能拷贝。</li>
</ul>
<h4 id="右值引用">右值引用</h4>
<ul>
<li>新标准引入右值引用以支持移动操作。</li>
<li>通过<code>&amp;&amp;</code>获得右值引用。</li>
<li>只能绑定到一个将要销毁的对象。</li>
<li>常规引用可以称之为左值引用。</li>
<li>左值持久，右值短暂。</li>
</ul>
<p><strong>move函数</strong>：</p>
<ul>
<li><code>int &amp;&amp;rr2 = std::move(rr1);</code></li>
<li><code>move</code>告诉编译器，我们有一个左值，但我希望像右值一样处理它。</li>
<li>调用<code>move</code>意味着：除了对<code>rr1</code>赋值或者销毁它外，我们将不再使用它。</li>
</ul>
<h4 id="移动构造函数和移动赋值运算符">移动构造函数和移动赋值运算符</h4>
<ul>
<li><strong>移动构造函数</strong>：
<ul>
<li>第一个参数是该类类型的一个引用，关键是，这个引用参数是一个<strong>右值引用</strong>。</li>
<li><code>StrVec::StrVec(StrVec &amp;&amp;s) noexcept&#123;&#125;</code></li>
<li>不分配任何新内存，只是接管给定的内存。</li>
</ul>
</li>
<li><strong>移动赋值运算符</strong>：
<ul>
<li><code>StrVec&amp; StrVec::operator=(StrVec &amp;&amp; rhs) noexcept&#123;&#125;</code></li>
</ul>
</li>
<li>移动右值，拷贝左值。</li>
<li>如果没有移动构造函数，右值也被拷贝。</li>
<li>更新三/五法则：如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。</li>
<li>移动迭代器：
<ul>
<li><code>make_move_iterator</code>函数讲一个普通迭代器转换为一个移动迭代器。</li>
</ul>
</li>
<li>建议：小心地使用移动操作，以获得性能提升。</li>
</ul>
<h4 id="右值引用和成员函数">右值引用和成员函数</h4>
<ul>
<li>区分移动和拷贝的重载函数通常有一个版本接受一个<code>const T&amp;</code>，而另一个版本接受一个<code>T&amp;&amp;</code>。</li>
<li>引用限定符：
<ul>
<li>在参数列表后面防止一个<code>&amp;</code>，限定只能向可修改的左值赋值而不能向右值赋值。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第13章-拷贝控制">第13章 拷贝控制</h2>
<p>一个类通过定义五种特殊的成员函数来控制对象的拷贝、移动、赋值和销毁操作。</p>
<ul>
<li>拷贝构造函数（copy constructor）</li>
<li>拷贝赋值运算符（copy-assignment operator）</li>
<li>移动构造函数（move constructor）</li>
<li>移动赋值运算符（move-assignment operator）</li>
<li>析构函数（destructor）</li>
</ul>
<p>这些操作统称为拷贝控制操作（copy control）。</p>
<p>在定义任何类时，拷贝控制操作都是必要部分。</p>
<h3 id="拷贝、赋值与销毁（Copy，Assign，and-Destroy）">拷贝、赋值与销毁（Copy，Assign，and Destroy）</h3>
<h4 id="拷贝构造函数（The-Copy-Constructor）">拷贝构造函数（The Copy Constructor）</h4>
<p>如果一个构造函数的第一个参数是自身类类型的引用（几乎总是<code>const</code>引用），且任何额外参数都有默认值，则此构造函数是拷贝构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>();   <span class="comment">// default constructor</span></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="keyword">const</span> Foo&amp;);   <span class="comment">// copy constructor</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于拷贝构造函数在一些情况下会被隐式使用，因此通常不会声明为<code>explicit</code>的。</p>
<p>如果类未定义自己的拷贝构造函数，编译器会为类合成一个。一般情况下，合成拷贝构造函数（synthesized copy constructor）会将其参数的非<code>static</code>成员逐个拷贝到正在创建的对象中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// other members and constructors as before</span></span><br><span class="line">    <span class="comment">// declaration equivalent to the synthesized copy constructor</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="keyword">const</span> Sales_data&amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="keyword">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// equivalent to the copy constructor that would be synthesized for Sales_data</span></span><br><span class="line">Sales_data::<span class="built_in">Sales_data</span>(<span class="keyword">const</span> Sales_data &amp;orig):</span><br><span class="line">    <span class="built_in">bookNo</span>(orig.bookNo),    <span class="comment">// uses the string copy constructor</span></span><br><span class="line">    <span class="built_in">units_sold</span>(orig.units_sold),    <span class="comment">// copies orig.units_sold</span></span><br><span class="line">    <span class="built_in">revenue</span>(orig.revenue)   <span class="comment">// copies orig.revenue</span></span><br><span class="line">    &#123; &#125; <span class="comment">// empty bod</span></span><br></pre></td></tr></table></figure>
<p>使用直接初始化时，实际上是要求编译器按照函数匹配规则来选择与实参最匹配的构造函数。使用拷贝初始化时，是要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">dots</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;.&#x27;</span>)</span></span>;   <span class="comment">// direct initialization</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(dots)</span></span>;         <span class="comment">// direct initialization</span></span><br><span class="line">string s2 = dots;       <span class="comment">// copy initialization</span></span><br><span class="line">string null_book = <span class="string">&quot;9-999-99999-9&quot;</span>;    <span class="comment">// copy initialization</span></span><br><span class="line">string nines = <span class="built_in">string</span>(<span class="number">100</span>, <span class="string">&#x27;9&#x27;</span>);       <span class="comment">// copy initialization</span></span><br></pre></td></tr></table></figure>
<p>拷贝初始化通常使用拷贝构造函数来完成。但如果一个类拥有移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。</p>
<p>发生拷贝初始化的情况：</p>
<ul>
<li>用<code>=</code>定义变量。</li>
<li>将对象作为实参传递给非引用类型的形参。</li>
<li>从返回类型为非引用类型的函数返回对象。</li>
<li>用花括号列表初始化数组中的元素或聚合类中的成员。</li>
</ul>
<p>当传递一个实参或者从函数返回一个值时，不能隐式使用<code>explicit</code>构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">// ok: direct initialization</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2 = <span class="number">10</span>;    <span class="comment">// error: constructor that takes a size is explicit</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;)</span></span>;    <span class="comment">// f&#x27;s parameter is copy initialized</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>);      <span class="comment">// error: can&#x27;t use an explicit constructor to copy an argument</span></span><br><span class="line"><span class="built_in">f</span>(vector&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>));     <span class="comment">// ok: directly construct a temporary vector from an int</span></span><br></pre></td></tr></table></figure>
<h4 id="拷贝赋值运算符（The-Copy-Assignment-Operator）">拷贝赋值运算符（The Copy-Assignment Operator）</h4>
<p>重载运算符（overloaded operator）的参数表示运算符的运算对象。</p>
<p>如果一个运算符是成员函数，则其左侧运算对象会绑定到隐式的<code>this</code>参数上。</p>
<p>赋值运算符通常应该返回一个指向其左侧运算对象的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;);  <span class="comment">// assignment operator</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。</p>
<p>如果类未定义自己的拷贝赋值运算符，编译器会为类合成一个。一般情况下，合成拷贝赋值运算符（synthesized copy-assignment operator）会将其右侧运算对象的非<code>static</code>成员逐个赋值给左侧运算对象的对应成员，之后返回左侧运算对象的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equivalent to the synthesized copy-assignment operator</span></span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    bookNo = rhs.bookNo;    <span class="comment">// calls the string::operator=</span></span><br><span class="line">    units_sold = rhs.units_sold;    <span class="comment">// uses the built-in int assignment</span></span><br><span class="line">    revenue = rhs.revenue;  <span class="comment">// uses the built-in double assignment</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;   <span class="comment">// return a reference to this object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="析构函数（The-Destructor）">析构函数（The Destructor）</h4>
<p>析构函数负责释放对象使用的资源，并销毁对象的非<code>static</code>数据成员。</p>
<p>析构函数的名字由波浪号<code>~</code>接类名构成，它没有返回值，也不接受参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Foo</span>(); <span class="comment">// destructor</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于析构函数不接受参数，所以它不能被重载。</p>
<p>如果类未定义自己的析构函数，编译器会为类合成一个。合成析构函数（synthesized destructor）的函数体为空。</p>
<p>析构函数首先执行函数体，然后再销毁数据成员。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。成员按照初始化顺序的逆序销毁。</p>
<p>隐式销毁一个内置指针类型的成员不会<code>delete</code>它所指向的对象。</p>
<p>无论何时一个对象被销毁，都会自动调用其析构函数。</p>
<p>当指向一个对象的引用或指针离开作用域时，该对象的析构函数不会执行。</p>
<h4 id="三-五法则（The-Rule-of-Three-Five）">三/五法则（The Rule of Three/Five）</h4>
<p>需要析构函数的类一般也需要拷贝和赋值操作。</p>
<p>需要拷贝操作的类一般也需要赋值操作，反之亦然。</p>
<h4 id="使用-default（Using-default）">使用=default（Using =default）</h4>
<p>可以通过将拷贝控制成员定义为<code>=default</code>来显式地要求编译器生成合成版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// copy control; use defaults</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="keyword">const</span> Sales_data&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在类内使用<code>=default</code>修饰成员声明时，合成的函数是隐式内联的。如果不希望合成的是内联函数，应该只对成员的类外定义使用<code>=default</code>。</p>
<p>只能对具有合成版本的成员函数使用<code>=default</code>。</p>
<h4 id="阻止拷贝（Preventing-Copies）">阻止拷贝（Preventing Copies）</h4>
<p>大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是显式地还是隐式地。</p>
<p>在C++11新标准中，将拷贝构造函数和拷贝赋值运算符定义为删除的函数（deleted function）可以阻止类对象的拷贝。删除的函数是一种虽然进行了声明，但是却不能以任何方式使用的函数。定义删除函数的方式是在函数的形参列表后面添加<code>=delete</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoCopy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">NoCopy</span>() = <span class="keyword">default</span>; <span class="comment">// use the synthesized default constructor</span></span><br><span class="line">    <span class="built_in">NoCopy</span>(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>; <span class="comment">// no copy</span></span><br><span class="line">    NoCopy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>; <span class="comment">// no assignment</span></span><br><span class="line">    ~<span class="built_in">NoCopy</span>() = <span class="keyword">default</span>; <span class="comment">// use the synthesized destructor</span></span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>=delete</code>和<code>=default</code>有两点不同：</p>
<ul>
<li><code>=delete</code>可以对任何函数使用；<code>=default</code>只能对具有合成版本的函数使用。</li>
<li><code>=delete</code>必须出现在函数第一次声明的地方；<code>=default</code>既能出现在类内，也能出现在类外。</li>
</ul>
<p>析构函数不能是删除的函数。对于析构函数被删除的类型，不能定义该类型的变量或者释放指向该类型动态分配对象的指针。</p>
<p>如果一个类中有数据成员不能默认构造、拷贝或销毁，则对应的合成拷贝控制成员将被定义为删除的。</p>
<p>在旧版本的C++标准中，类通过将拷贝构造函数和拷贝赋值运算符声明为<code>private</code>成员来阻止类对象的拷贝。在新标准中建议使用<code>=delete</code>而非<code>private</code>。</p>
<h3 id="拷贝控制和资源管理（Copy-Control-and-Resource-Management）">拷贝控制和资源管理（Copy Control and Resource Management）</h3>
<p>通常，管理类外资源的类必须定义拷贝控制成员。</p>
<h4 id="行为像值的类（Classes-That-Act-Like-Values）">行为像值的类（Classes That Act Like Values）</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="keyword">const</span> std::string &amp;s = std::<span class="built_in">string</span>()):</span><br><span class="line">        <span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">    <span class="comment">// each HasPtr has its own copy of the string to which ps points</span></span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="keyword">const</span> HasPtr &amp;p):</span><br><span class="line">        <span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(*p.ps)), <span class="built_in">i</span>(p.i) &#123; &#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;);</span><br><span class="line">    ~<span class="built_in">HasPtr</span>() &#123; <span class="keyword">delete</span> ps; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编写赋值运算符时有两点需要注意：</p>
<ul>
<li>
<p>即使将一个对象赋予它自身，赋值运算符也能正确工作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WRONG way to write an assignment operator!</span></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ps;   <span class="comment">// frees the string to which this object points</span></span><br><span class="line">    <span class="comment">// if rhs and *this are the same object, we&#x27;re copying from deleted memory!</span></span><br><span class="line">    ps = <span class="keyword">new</span> <span class="built_in">string</span>(*(rhs.ps));</span><br><span class="line">    i = rhs.i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>赋值运算符通常结合了拷贝构造函数和析构函数的工作。</p>
<p>编写赋值运算符时，一个好的方法是先将右侧运算对象拷贝到一个局部临时对象中。拷贝完成后，就可以安全地销毁左侧运算对象的现有成员了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps);    <span class="comment">// copy the underlying string</span></span><br><span class="line">    <span class="keyword">delete</span> ps;   <span class="comment">// free the old memory</span></span><br><span class="line">    ps = newp;   <span class="comment">// copy data from rhs into this object</span></span><br><span class="line">    i = rhs.i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;   <span class="comment">// return this object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="定义行为像指针的类（Defining-Classes-That-Act-Like-Pointers）">定义行为像指针的类（Defining Classes That Act Like Pointers）</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructor allocates a new string and a new counter, which it sets to 1</span></span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="keyword">const</span> std::string &amp;s = std::<span class="built_in">string</span>()):</span><br><span class="line">        <span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>), <span class="built_in">use</span>(<span class="keyword">new</span> std::<span class="built_in">size_t</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line">    <span class="comment">// copy constructor copies all three data members and increments the counter</span></span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="keyword">const</span> HasPtr &amp;p):</span><br><span class="line">        <span class="built_in">ps</span>(p.ps), <span class="built_in">i</span>(p.i), <span class="built_in">use</span>(p.use) &#123; ++*use; &#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp;);</span><br><span class="line">    ~<span class="built_in">HasPtr</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    std::<span class="keyword">size_t</span> *use; <span class="comment">// member to keep track of how many objects share *ps</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>析构函数释放内存前应该判断是否还有其他对象指向这块内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">HasPtr::~<span class="built_in">HasPtr</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (--*use == <span class="number">0</span>)</span><br><span class="line">    &#123;   <span class="comment">// if the reference count goes to 0</span></span><br><span class="line">        <span class="keyword">delete</span> ps;   <span class="comment">// delete the string</span></span><br><span class="line">        <span class="keyword">delete</span> use;  <span class="comment">// and the counter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    ++*rhs.use;    <span class="comment">// increment the use count of the right-hand operand</span></span><br><span class="line">    <span class="keyword">if</span> (--*use == <span class="number">0</span>)</span><br><span class="line">    &#123;   <span class="comment">// then decrement this object&#x27;s counter</span></span><br><span class="line">        <span class="keyword">delete</span> ps; <span class="comment">// if no other users</span></span><br><span class="line">        <span class="keyword">delete</span> use; <span class="comment">// free this object&#x27;s allocated members</span></span><br><span class="line">    &#125;</span><br><span class="line">    ps = rhs.ps;    <span class="comment">// copy data from rhs into this object</span></span><br><span class="line">    i = rhs.i;</span><br><span class="line">    use = rhs.use;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;   <span class="comment">// return this object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="交换操作（Swap）">交换操作（Swap）</h3>
<p>通常，管理类外资源的类会定义<code>swap</code>函数。如果一个类定义了自己的<code>swap</code>函数，算法将使用自定义版本，否则将使用标准库定义的<code>swap</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp;, HasPtr&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// other members as in § 13.2.1 (p. 511)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(lhs.ps, rhs.ps);   <span class="comment">// swap the pointers, not the string data</span></span><br><span class="line">    <span class="built_in">swap</span>(lhs.i, rhs.i);     <span class="comment">// swap the int members</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一些算法在交换两个元素时会调用<code>swap</code>函数，其中每个<code>swap</code>调用都应该是未加限定的。如果存在类型特定的<code>swap</code>版本，其匹配程度会优于<code>std</code>中定义的版本（假定作用域中有<code>using</code>声明）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Foo &amp;lhs, Foo &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// WRONG: this function uses the library version of swap, not the HasPtr version</span></span><br><span class="line">    std::<span class="built_in">swap</span>(lhs.h, rhs.h);</span><br><span class="line">    <span class="comment">// swap other members of type Foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Foo &amp;lhs, Foo &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(lhs.h, rhs.h);  <span class="comment">// uses the HasPtr version of swap</span></span><br><span class="line">    <span class="comment">// swap other members of type Foo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与拷贝控制成员不同，<code>swap</code>函数并不是必要的。但是对于分配了资源的类，定义<code>swap</code>可能是一种重要的优化手段。</p>
<p>由于<code>swap</code>函数的存在就是为了优化代码，所以一般将其声明为内联函数。</p>
<p>定义了<code>swap</code>的类通常用<code>swap</code>来实现赋值运算符。在这种版本的赋值运算符中，右侧运算对象以值方式传递，然后将左侧运算对象与右侧运算对象的副本进行交换（拷贝并交换，copy and swap）。这种方式可以正确处理自赋值情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note rhs is passed by value, which means the HasPtr copy constructor</span></span><br><span class="line"><span class="comment">// copies the string in the right-hand operand into rhs</span></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// swap the contents of the left-hand operand with the local variable rhs</span></span><br><span class="line">    <span class="built_in">swap</span>(*<span class="keyword">this</span>, rhs);   <span class="comment">// rhs now points to the memory this object had used</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;       <span class="comment">// rhs is destroyed, which deletes the pointer in rhs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拷贝控制示例（A-Copy-Control-Example）">拷贝控制示例（A Copy-Control Example）</h3>
<p>拷贝赋值运算符通常结合了拷贝构造函数和析构函数的工作。在这种情况下，公共部分应该放在<code>private</code>的工具函数中完成。</p>
<h3 id="动态内存管理类（Classes-That-Manage-Dynamic-Memory）">动态内存管理类（Classes That Manage Dynamic Memory）</h3>
<p>移动构造函数通常是将资源从给定对象“移动”而不是拷贝到正在创建的对象中。</p>
<h3 id="对象移动（Moving-Objects）">对象移动（Moving Objects）</h3>
<p>某些情况下，一个对象拷贝后就立即被销毁了，此时移动而非拷贝对象会大幅度提高性能。</p>
<p>在旧版本的标准库中，容器所能保存的类型必须是可拷贝的。但在新标准中，可以用容器保存不可拷贝，但可移动的类型。</p>
<p>标准库容器、<code>string</code>和<code>shared_ptr</code>类既支持移动也支持拷贝。IO类和<code>unique_ptr</code>类可以移动但不能拷贝。</p>
<h4 id="右值引用（Rvalue-Reference）">右值引用（Rvalue Reference）</h4>
<p>为了支持移动操作，C++11引入了右值引用类型。右值引用就是必须绑定到右值的引用。可以通过<code>&amp;&amp;</code>来获得右值引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = i;         <span class="comment">// ok: r refers to i</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr = i;       <span class="comment">// error: cannot bind an rvalue reference to an</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = i * <span class="number">42</span>;   <span class="comment">// error: i * 42 is an rvalue</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i * <span class="number">42</span>;    <span class="comment">// ok: we can bind a reference to const to an rvalue</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = i * <span class="number">42</span>;        <span class="comment">// ok: bind rr2 to the result of the multiplication</span></span><br></pre></td></tr></table></figure>
<p>右值引用只能绑定到即将被销毁，并且没有其他用户的临时对象上。使用右值引用的代码可以自由地接管所引用对象的资源。</p>
<p>变量表达式都是左值，所以不能将一个右值引用直接绑定到一个变量上，即使这个变量的类型是右值引用也不行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = <span class="number">42</span>;     <span class="comment">// ok: literals are rvalues</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1;    <span class="comment">// error: the expression rr1 is an lvalue!</span></span><br></pre></td></tr></table></figure>
<p>调用<code>move</code>函数可以获得绑定在左值上的右值引用，此函数定义在头文件<code>utility</code>中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr1);</span><br></pre></td></tr></table></figure>
<p>调用<code>move</code>函数的代码应该使用<code>std::move</code>而非<code>move</code>，这样做可以避免潜在的名字冲突。</p>
<h4 id="移动构造函数和移动赋值运算符（Move-Constructor-and-Move-Assignment）">移动构造函数和移动赋值运算符（Move Constructor and Move Assignment）</h4>
<p>移动构造函数的第一个参数是该类类型的右值引用，其他任何额外参数都必须有默认值。</p>
<p>除了完成资源移动，移动构造函数还必须确保移后源对象是可以安全销毁的。</p>
<p>在函数的形参列表后面添加关键字<code>noexcept</code>可以指明该函数不会抛出任何异常。</p>
<p>对于构造函数，<code>noexcept</code>位于形参列表和初始化列表开头的冒号之间。在类的头文件声明和定义中（如果定义在类外）都应该指定<code>noexcept</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StrVec</span>(StrVec&amp;&amp;) <span class="keyword">noexcept</span>;  <span class="comment">// move constructor</span></span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StrVec::<span class="built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="keyword">noexcept</span> : <span class="comment">/* member initializers */</span></span><br><span class="line">&#123; <span class="comment">/* constructor body */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>标准库容器能对异常发生时其自身的行为提供保障。虽然移动操作通常不抛出异常，但抛出异常也是允许的。为了安全起见，除非容器确定元素类型的移动操作不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝而非移动操作。</p>
<p>不抛出异常的移动构造函数和移动赋值运算符必须标记为<code>noexcept</code>。</p>
<p>在移动操作之后，移后源对象必须保持有效的、可销毁的状态，但是用户不能使用它的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// direct test for self-assignment</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>();     <span class="comment">// free existing elements</span></span><br><span class="line">        elements = rhs.elements;    <span class="comment">// take over resources from rhs</span></span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;</span><br><span class="line">        <span class="comment">// leave rhs in a destructible state</span></span><br><span class="line">        rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有当一个类没有定义任何拷贝控制成员，且类的每个非<code>static</code>数据成员都可以移动时，编译器才会为类合成移动构造函数和移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，则编译器也能移动该成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the compiler will synthesize the move operations for X and hasX</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;   <span class="comment">// built-in types can be moved</span></span><br><span class="line">    std::string s;   <span class="comment">// string defines its own move operations</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hasX</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    X mem; <span class="comment">// X has synthesized move operations</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X x, x2 = std::<span class="built_in">move</span>(x);         <span class="comment">// uses the synthesized move constructor</span></span><br><span class="line">hasX hx, hx2 = std::<span class="built_in">move</span>(hx);   <span class="comment">// uses the synthesized move constructor</span></span><br></pre></td></tr></table></figure>
<p>与拷贝操作不同，移动操作永远不会被隐式定义为删除的函数。但如果显式地要求编译器生成<code>=default</code>的移动操作，且编译器不能移动全部成员，则移动操作会被定义为删除的函数。</p>
<p>定义了移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则这些成员会被默认地定义为删除的函数。</p>
<p>如果一个类有可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的，即使调用<code>move</code>函数时也是如此。拷贝赋值运算符和移动赋值运算符的情况类似。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="keyword">const</span> Foo&amp;);    <span class="comment">// copy constructor</span></span><br><span class="line">    <span class="comment">// other members, but Foo does not define a move constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo x;</span><br><span class="line"><span class="function">Foo <span class="title">y</span><span class="params">(x)</span></span>;   <span class="comment">// copy constructor; x is an lvalue</span></span><br><span class="line"><span class="function">Foo <span class="title">z</span><span class="params">(std::move(x))</span></span>;    <span class="comment">// copy constructor, because there is no move constructor</span></span><br></pre></td></tr></table></figure>
<p>使用非引用参数的单一赋值运算符可以实现拷贝赋值和移动赋值两种功能。依赖于实参的类型，左值被拷贝，右值被移动。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assignment operator is both the move- and copy-assignment operator</span></span><br><span class="line">HasPtr&amp; <span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(*<span class="keyword">this</span>, rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hp = hp2;   <span class="comment">// hp2 is an lvalue; copy constructor used to copy hp2</span></span><br><span class="line">hp = std::<span class="built_in">move</span>(hp2);    <span class="comment">// move constructor moves hp2</span></span><br></pre></td></tr></table></figure>
<p>建议将五个拷贝控制成员当成一个整体来对待。如果一个类需要任何一个拷贝操作，它就应该定义所有五个操作。</p>
<p>移动赋值运算符可以直接检查自赋值情况。</p>
<p>C++11标准库定义了移动迭代器（move iterator）适配器。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。移动迭代器的解引用运算符返回一个右值引用。</p>
<p>调用<code>make_move_iterator</code>函数能将一个普通迭代器转换成移动迭代器。原迭代器的所有其他操作在移动迭代器中都照常工作。</p>
<p>最好不要在移动构造函数和移动赋值运算符这些类实现代码之外的地方随意使用<code>move</code>操作。</p>
<h4 id="右值引用和成员函数（Rvalue-References-and-Member-Functions）">右值引用和成员函数（Rvalue References and Member Functions）</h4>
<p>区分移动和拷贝的重载函数通常有一个版本接受一个<code>const T&amp;</code>参数，另一个版本接受一个<code>T&amp;&amp;</code>参数（<code>T</code>为类型）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> X&amp;)</span></span>;   <span class="comment">// copy: binds to any kind of X</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(X&amp;&amp;)</span></span>;        <span class="comment">// move: binds only to modifiable rvalues of type X</span></span><br></pre></td></tr></table></figure>
<p>有时可以对右值赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s1, s2;</span><br><span class="line">s1 + s2 = <span class="string">&quot;wow!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>在旧标准中，没有办法阻止这种使用方式。为了维持向下兼容性，新标准库仍然允许向右值赋值。但是可以在自己的类中阻止这种行为，规定左侧运算对象（即<code>this</code>指向的对象）必须是一个左值。</p>
<p>在非<code>static</code>成员函数的形参列表后面添加引用限定符（reference qualifier）可以指定<code>this</code>的左值/右值属性。引用限定符可以是<code>&amp;</code>或者<code>&amp;&amp;</code>，分别表示<code>this</code>可以指向一个左值或右值对象。引用限定符必须同时出现在函数的声明和定义中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;) &amp;; <span class="comment">// may assign only to modifiable lvalues</span></span><br><span class="line">    <span class="comment">// other members of Foo</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo &amp;Foo::<span class="keyword">operator</span>=(<span class="keyword">const</span> Foo &amp;rhs) &amp;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do whatever is needed to assign rhs to this object</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个非<code>static</code>成员函数可以同时使用<code>const</code>和引用限定符，此时引用限定符跟在<code>const</code>限定符之后。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">someMem</span><span class="params">()</span> &amp; <span class="keyword">const</span></span>;      <span class="comment">// error: const qualifier must come first</span></span><br><span class="line">    <span class="function">Foo <span class="title">anotherMem</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>;   <span class="comment">// ok: const qualifier comes first</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>引用限定符也可以区分成员函数的重载版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;&amp;</span>;        <span class="comment">// may run on modifiable rvalues</span></span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>;   <span class="comment">// may run on any kind of Foo</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">retVal</span>().<span class="built_in">sorted</span>();   <span class="comment">// retVal() is an rvalue, calls Foo::sorted() &amp;&amp;</span></span><br><span class="line"><span class="built_in">retFoo</span>().<span class="built_in">sorted</span>();   <span class="comment">// retFoo() is an lvalue, calls Foo::sorted() const &amp;</span></span><br></pre></td></tr></table></figure>
<p>如果一个成员函数有引用限定符，则具有相同参数列表的所有重载版本都必须有引用限定符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;&amp;</span>;</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">// error: must have reference qualifier</span></span><br><span class="line">    <span class="comment">// Comp is type alias for the function type</span></span><br><span class="line">    <span class="comment">// that can be used to compare int values</span></span><br><span class="line">    <span class="keyword">using</span> Comp = <span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;);</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">(Comp*)</span></span>;  <span class="comment">// ok: different parameter list</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第14章-重载运算与类型转换（简）">第14章 重载运算与类型转换（简）</h2>
<h3 id="基本概念">基本概念</h3>
<ul>
<li>重载运算符是具有特殊名字的函数：由关键字<code>operator</code>和其后要定义的运算符号共同组成。</li>
<li>当一个重载的运算符是成员函数时，<code>this</code>绑定到左侧运算对象。动态运算符符函数的参数数量比运算对象的数量<strong>少一个</strong>。</li>
<li>只能重载大多数的运算符，而不能发明新的运算符号。</li>
<li>重载运算符的优先级和结合律跟对应的内置运算符保持一致。</li>
<li>调用方式：
<ul>
<li><code>data1 + data2;</code></li>
<li><code>operator+(data1, data2);</code></li>
</ul>
</li>
<li>是否是成员函数：
<ul>
<li>赋值（<code>=</code>）、下标（<code>[]</code>）、调用（<code>()</code>）和成员访问箭头（<code>-&gt;</code>）运算符必须是成员。</li>
<li>复合赋值运算符一般来说是成员。</li>
<li>改变对象状态的运算符或者和给定类型密切相关的运算符通常是成员，如递增、解引用。</li>
<li>具有对称性的运算符如算术、相等性、关系和位运算符等，通常是非成员函数。</li>
</ul>
</li>
</ul>
<p><strong>运算符</strong>:</p>
<table>
<thead>
<tr>
<th>可以被重载</th>
<th>不可以被重载</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^</code></td>
<td><code>::</code>, <code>.*</code>, <code>.</code>, <code>? :</code>,</td>
</tr>
<tr>
<td><code>&amp;</code>, <code>|</code>, <code>~</code>, <code>!</code>, <code>,</code>, <code>=</code></td>
<td></td>
</tr>
<tr>
<td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>++</code>, <code>--</code></td>
<td></td>
</tr>
<tr>
<td><code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>==</code>, <code>!=</code>, <code>&amp;&amp;</code>, <code>||</code></td>
<td></td>
</tr>
<tr>
<td><code>+=</code>, <code>-=</code>, <code>/=</code>, <code>%=</code>, <code>^=</code>, <code>&amp;=</code></td>
<td></td>
</tr>
<tr>
<td>|=, <code>*=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>[]</code>, <code>()</code></td>
<td></td>
</tr>
<tr>
<td><code>-&gt;</code>, <code>-&gt;*</code>, <code>new</code>, <code>new[]</code>, <code>delete</code>, <code>delete[]</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="输入和输出运算符">输入和输出运算符</h3>
<h4 id="重载输出运算符">重载输出运算符&lt;&lt;</h4>
<ul>
<li>第一个形参通常是一个非常量的<code>ostream</code>对象的引用。非常量是因为向流中写入会改变其状态；而引用是因为我们无法复制一个<code>ostream</code>对象。</li>
<li>输入输出运算符必须是非成员函数。</li>
</ul>
<h4 id="重载输入运算符">重载输入运算符&gt;&gt;</h4>
<ul>
<li>第一个形参通常是运算符将要读取的流的因不用，第二个形参是将要读取到的（非常量）对象的引用。</li>
<li>输入运算符必须处理输入可能失败的情况，而输出运算符不需要。</li>
</ul>
<h3 id="算数和关系运算符（-、-、-、-）">算数和关系运算符（+、-、*、/）</h3>
<ul>
<li>如果类同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算数运算符。</li>
</ul>
<h4 id="相等运算符">相等运算符==</h4>
<ul>
<li>如果定义了<code>operator==</code>，则这个类也应该定义<code>operator!=</code>。</li>
<li>相等运算符和不等运算符的一个应该把工作委托给另一个。</li>
<li>相等运算符应该具有传递性。</li>
<li>如果某个类在逻辑上有相等性的含义，则该类应该定义<code>operator==</code>，这样做可以使用户更容易使用标准库算法来处理这个类。</li>
</ul>
<h4 id="关系运算符">关系运算符</h4>
<ul>
<li>如果存在唯一一种逻辑可靠的<code>&lt;</code>定义，则应该考虑为这个类定义<code>&lt;</code>运算符。如果同时还包含<code>==</code>，则当且晋档<code>&lt;</code>的定义和<code>++</code>产生的结果一直时才定义<code>&lt;</code>运算符。</li>
</ul>
<h3 id="赋值运算符">赋值运算符=</h3>
<ul>
<li>我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。</li>
<li>赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这么做。这两类运算符都应该返回左侧运算对象的引用。</li>
</ul>
<h3 id="下标运算符">下标运算符[]</h3>
<ul>
<li>下标运算符必须是成员函数。</li>
<li>一般会定义两个版本：
<ul>
<li>1.返回普通引用。</li>
<li>2.类的常量成员，并返回常量引用。</li>
</ul>
</li>
</ul>
<h3 id="递增和递减运算符（-、–）">递增和递减运算符（++、–）</h3>
<ul>
<li>定义递增和递减运算符的类应该同时定义前置版本和后置版本。</li>
<li>通常应该被定义成类的成员。</li>
<li>为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。</li>
<li>同样为了和内置版本保持一致，后置运算符应该返回递增或递减前对象的值，而不是引用。</li>
<li>后置版本接受一个额外的，不被使用的<code>int</code>类型的形参。因为不会用到，所以无需命名。</li>
</ul>
<h3 id="成员访问运算符（-、-）">成员访问运算符（*、-&gt;）</h3>
<ul>
<li>箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。</li>
<li>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</li>
<li>解引用和乘法的区别是一个是一元运算符，一个是二元运算符。</li>
</ul>
<h3 id="函数调用运算符">函数调用运算符</h3>
<ul>
<li>可以像使用函数一样，调用该类的对象。因为这样对待类同时也能存储状态，所以与普通函数相比更加灵活。</li>
<li>函数调用运算符必须是成员函数。</li>
<li>一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。</li>
<li>如果累定义了调用运算符，则该类的对象称作<strong>函数对象</strong>。</li>
</ul>
<h4 id="lambda是函数对象"><code>lambda</code>是函数对象</h4>
<ul>
<li><code>lambda</code>捕获变量：<code>lambda</code>产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数。</li>
</ul>
<h4 id="标准库定义的函数对象">标准库定义的函数对象</h4>
<p><strong>标准库函数对象</strong>:</p>
<table>
<thead>
<tr>
<th>算术</th>
<th>关系</th>
<th>逻辑</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>plus&lt;Type&gt;</code></td>
<td><code>equal_to&lt;Type&gt;</code></td>
<td><code>logical_and&lt;Type&gt;</code></td>
</tr>
<tr>
<td><code>minus&lt;Type&gt;</code></td>
<td><code>not_equal_to&lt;Type&gt;</code></td>
<td><code>logical_or&lt;Type&gt;</code></td>
</tr>
<tr>
<td><code>multiplies&lt;Type&gt;</code></td>
<td><code>greater&lt;Type&gt;</code></td>
<td><code>logical_not&lt;Type&gt;</code></td>
</tr>
<tr>
<td><code>divides&lt;Type&gt;</code></td>
<td><code>greater_equal&lt;Type&gt;</code></td>
<td></td>
</tr>
<tr>
<td><code>modulus&lt;Type&gt;</code></td>
<td><code>less&lt;Type&gt;</code></td>
<td></td>
</tr>
<tr>
<td><code>negate&lt;Type&gt;</code></td>
<td><code>less_equal&lt;Type&gt;</code></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>可以在算法中使用标准库函数对象。</li>
</ul>
<h4 id="可调用对象与function">可调用对象与function</h4>
<p><strong>标准库function类型</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>function&lt;T&gt; f;</code></td>
<td><code>f</code>是一个用来存储可调用对象的空<code>function</code>，这些可调用对象的调用形式应该与类型<code>T</code>相同。</td>
</tr>
<tr>
<td><code>function&lt;T&gt; f(nullptr);</code></td>
<td>显式地构造一个空<code>function</code></td>
</tr>
<tr>
<td><code>function&lt;T&gt; f(obj)</code></td>
<td>在<code>f</code>中存储可调用对象<code>obj</code>的副本</td>
</tr>
<tr>
<td><code>f</code></td>
<td>将<code>f</code>作为条件：当<code>f</code>含有一个可调用对象时为真；否则为假。</td>
</tr>
<tr>
<td>定义为<code>function&lt;T&gt;</code>的成员的类型</td>
<td></td>
</tr>
<tr>
<td><code>result_type</code></td>
<td>该<code>function</code>类型的可调用对象返回的类型</td>
</tr>
<tr>
<td><code>argument_type</code></td>
<td>当<code>T</code>有一个或两个实参时定义的类型。如果<code>T</code>只有一个实参，则<code>argument_type</code></td>
</tr>
<tr>
<td><code>first_argument_type</code></td>
<td>第一个实参的类型</td>
</tr>
<tr>
<td><code>second_argument_type</code></td>
<td>第二个实参的类型</td>
</tr>
</tbody>
</table>
<ul>
<li>例如：声明一个<code>function</code>类型，它可以表示接受两个<code>int</code>，返回一个<code>int</code>的可调用对象。<code>function&lt;int(int, int)&gt;</code></li>
</ul>
<h3 id="重载、类型转换、运算符">重载、类型转换、运算符</h3>
<h4 id="类型转换运算符">类型转换运算符</h4>
<ul>
<li>类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下：<code>operator type() const;</code></li>
<li>一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是<code>const</code>。</li>
<li>避免过度使用类型转换函数。</li>
<li>C++11引入了显式的类型转换运算符。</li>
<li>向<code>bool</code>的类型转换通常用在条件部分，因此<code>operator bool</code>一般定义成<code>explicit</code>的。</li>
</ul>
<h4 id="避免有二义性的类型转换">避免有二义性的类型转换</h4>
<ul>
<li>通常，不要为类第几个亿相同的类型转换，也不要在类中定义两个及以上转换源或转换目标是算术类型的转换。</li>
<li>在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。</li>
</ul>
<h4 id="函数匹配与重载运算符">函数匹配与重载运算符</h4>
<ul>
<li>如果<code>a</code>是一种类型，则表达式<code>a sym b</code>可能是：
<ul>
<li><code>a.operatorsym(b);</code></li>
<li><code>operatorsym(a,b);</code></li>
</ul>
</li>
<li>如果我们队同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。</li>
</ul>
<hr>
<h2 id="第14章-重载运算与类型转换">第14章 重载运算与类型转换</h2>
<h3 id="基本概念（Basic-Concepts）">基本概念（Basic Concepts）</h3>
<p>重载的运算符是具有特殊名字的函数，它们的名字由关键字<code>operator</code>和其后要定义的运算符号组成。</p>
<p>重载运算符函数的参数数量和该运算符作用的运算对象数量一样多。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。除了重载的函数调用运算符<code>operator()</code>之外，其他重载运算符不能含有默认实参。</p>
<p>如果一个运算符函数是类的成员函数，则它的第一个运算对象会绑定到隐式的<code>this</code>指针上。因此成员运算符函数的显式参数数量比运算对象的数量少一个。</p>
<p>当运算符作用于内置类型的运算对象时，无法改变该运算符的含义。</p>
<p>只能重载大多数已有的运算符，无权声明新的运算符号。</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031702758.png" alt="14-1" style="zoom:80%;" />
<p>重载运算符的优先级和结合律与对应的内置运算符一致。</p>
<p>可以像调用普通函数一样直接调用运算符函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equivalent calls to a nonmember operator function</span></span><br><span class="line">data1 + data2;              <span class="comment">// normal expression</span></span><br><span class="line"><span class="keyword">operator</span>+(data1, data2);    <span class="comment">// equivalent function call</span></span><br><span class="line">data1 += data2;             <span class="comment">// expression-based &#x27;&#x27;call&#x27;&#x27;</span></span><br><span class="line">data1.<span class="keyword">operator</span>+=(data2);    <span class="comment">// equivalent call to a member operator function</span></span><br></pre></td></tr></table></figure>
<p>通常情况下，不应该重载逗号<code>,</code>、取地址<code>&amp;</code>、逻辑与<code>&amp;&amp;</code>和逻辑或<code>||</code>运算符。</p>
<p>建议只有当操作的含义对于用户来说清晰明了时才使用重载运算符，重载运算符的返回类型也应该与其内置版本的返回类型兼容。</p>
<p>如果类中含有算术运算符或位运算符，则最好也提供对应的复合赋值运算符。</p>
<p>把运算符定义为成员函数时，它的左侧运算对象必须是运算符所属类型的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">string t = s + <span class="string">&quot;!&quot;</span>;     <span class="comment">// ok: we can add a const char* to a string</span></span><br><span class="line">string u = <span class="string">&quot;hi&quot;</span> + s;    <span class="comment">// would be an error if + were a member of string</span></span><br></pre></td></tr></table></figure>
<p>如何选择将运算符定义为成员函数还是普通函数：</p>
<ul>
<li>赋值<code>=</code>、下标<code>[]</code>、调用<code>()</code>和成员访问箭头<code>-&gt;</code>运算符必须是成员函数。</li>
<li>复合赋值运算符一般是成员函数，但并非必须。</li>
<li>改变对象状态或者与给定类型密切相关的运算符，如递增、递减、解引用运算符，通常是成员函数。</li>
<li>具有对称性的运算符可能转换任意一端的运算对象，如算术、相等性、关系和位运算符，通常是普通函数。</li>
</ul>
<h3 id="输入和输出运算符（Input-and-Output-Operators）">输入和输出运算符（Input and Output Operators）</h3>
<h4 id="重载输出运算符-（Overloading-the-Output-Operator-）">重载输出运算符&lt;&lt;（Overloading the Output Operator &lt;&lt;）</h4>
<p>通常情况下，输出运算符的第一个形参是<code>ostream</code>类型的普通引用，第二个形参是要打印类型的常量引用，返回值是它的<code>ostream</code>形参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">        &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出运算符应该尽量减少格式化操作。</p>
<p>输入输出运算符必须是非成员函数。而由于IO操作通常需要读写类的非公有数据，所以输入输出运算符一般被声明为友元。</p>
<h4 id="重载输入运算符-（Overloading-the-Input-Operator-）">重载输入运算符&gt;&gt;（Overloading the Input Operator &gt;&gt;）</h4>
<p>通常情况下，输入运算符的第一个形参是要读取的流的普通引用，第二个形参是要读入的目的对象的普通引用，返回值是它的第一个形参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> price;   <span class="comment">// no need to initialize; we&#x27;ll read into price before we use it</span></span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    <span class="keyword">if</span> (is)    <span class="comment">// check that the inputs succeeded</span></span><br><span class="line">        item.revenue = item.units_sold * price;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        item = <span class="built_in">Sales_data</span>();    <span class="comment">// input failed: give the object the default state</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入运算符必须处理输入失败的情况，而输出运算符不需要。</p>
<p>以下情况可能导致读取操作失败：</p>
<ul>
<li>读取了错误类型的数据。</li>
<li>读取操作到达文件末尾。</li>
<li>遇到输入流的其他错误。</li>
</ul>
<p>当读取操作发生错误时，输入操作符应该负责从错误状态中恢复。</p>
<p>如果输入的数据不符合规定的格式，即使从技术上看IO操作是成功的，输入运算符也应该设置流的条件状态以标示出失败信息。通常情况下，输入运算符只设置<code>failbit</code>状态。<code>eofbit</code>、<code>badbit</code>等错误最好由IO标准库自己标示。</p>
<h3 id="算术和关系运算符（Arithmetic-and-Relational-Operators）">算术和关系运算符（Arithmetic and Relational Operators）</h3>
<p>通常情况下，算术和关系运算符应该定义为非成员函数，以便两侧的运算对象进行转换。其次，由于这些运算符一般不会改变运算对象的状态，所以形参都是常量引用。</p>
<p>算术运算符通常会计算它的两个运算对象并得到一个新值，这个值通常存储在一个局部变量内，操作完成后返回该局部变量的副本作为结果（返回类型建议设置为原对象的<code>const</code>类型）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assumes that both objects refer to the same book</span></span><br><span class="line">Sales_data <span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Sales_data sum = lhs;   <span class="comment">// copy data members from lhs into sum</span></span><br><span class="line">    sum += rhs;     <span class="comment">// add rhs into sum</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果类定义了算术运算符，则通常也会定义对应的复合赋值运算符，此时最有效的方式是使用复合赋值来实现算术运算符。</p>
<h4 id="相等运算符（Equality-Operators）">相等运算符（Equality Operators）</h4>
<p>相等运算符设计准则：</p>
<ul>
<li>
<p>如果类在逻辑上有相等性的含义，则应该定义<code>operator==</code>而非一个普通的命名函数。这样做便于使用标准库容器和算法，也更容易记忆。</p>
</li>
<li>
<p>通常情况下，<code>operator==</code>应该具有传递性。</p>
</li>
<li>
<p>如果类定义了<code>operator==</code>，则也应该定义<code>operator!=</code>。</p>
</li>
<li>
<p><code>operator==</code>和<code>operator!=</code>中的一个应该把具体工作委托给另一个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() == rhs.<span class="built_in">isbn</span>() &amp;&amp;</span><br><span class="line">        lhs.units_sold == rhs.units_sold &amp;&amp;</span><br><span class="line">        lhs.revenue == rhs.revenue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="关系运算符（Relational-Operators）">关系运算符（Relational Operators）</h4>
<p>定义了相等运算符的类通常也会定义关系运算符。因为关联容器和一些算法要用到小于运算符，所以定义<code>operator&lt;</code>会比较实用。</p>
<p>关系运算符设计准则：</p>
<ul>
<li>定义顺序关系，令其与关联容器中对关键字的要求保持一致。</li>
<li>如果类定义了<code>operator==</code>，则关系运算符的定义应该与<code>operator==</code>保持一致。特别是，如果两个对象是不相等的，那么其中一个对象应该小于另一个对象。</li>
<li>只有存在唯一一种逻辑可靠的小于关系时，才应该考虑为类定义<code>operator&lt;</code>。</li>
</ul>
<h3 id="赋值运算符（Assignment-Operators）">赋值运算符（Assignment Operators）</h3>
<p>赋值运算符必须定义为成员函数，复合赋值运算符通常也是如此。这两类运算符都应该返回其左侧运算对象的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(initializer_list&lt;string&gt; il)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// alloc_n_copy allocates space and copies elements from the given range</span></span><br><span class="line">    <span class="keyword">auto</span> data = <span class="built_in">alloc_n_copy</span>(il.<span class="built_in">begin</span>(), il.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">free</span>();     <span class="comment">// destroy the elements in this object and free the space</span></span><br><span class="line">    elements = data.first;      <span class="comment">// update data members to point to the new</span></span><br><span class="line">    space</span><br><span class="line">    first_free = cap = data.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member binary operator: left-hand operand is bound to the implicit this pointer</span></span><br><span class="line"><span class="comment">// assumes that both objects refer to the same book</span></span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="下标运算符（Subscript-Operator）">下标运算符（Subscript Operator）</h3>
<p>下标运算符必须定义为成员函数。</p>
<p>类通常会定义两个版本的下标运算符：一个返回普通引用，另一个是类的常量成员并返回常量引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string&amp; <span class="keyword">operator</span>[](std::<span class="keyword">size_t</span> n)</span><br><span class="line">    &#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line">    <span class="keyword">const</span> std::string&amp; <span class="keyword">operator</span>[](std::<span class="keyword">size_t</span> n) <span class="keyword">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string *elements;  <span class="comment">// pointer to the first element in the array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递增和递减运算符（Increment-and-Decrement-Operators）">递增和递减运算符（Increment and Decrement Operators）</h3>
<p>定义递增和递减运算符的类应该同时定义前置和后置版本，这些运算符通常定义为成员函数。</p>
<p>为了与内置操作保持一致，前置递增或递减运算符应该返回运算后对象的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prefix: return a reference to the incremented/decremented object</span></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    ++curr;     <span class="comment">// advance the current state</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后置递增或递减运算符接受一个额外的（不被使用）<code>int</code>类型形参，该形参的唯一作用就是区分运算符的前置和后置版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// increment and decrement</span></span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>++();    <span class="comment">// prefix operators</span></span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>);  <span class="comment">// postfix operators</span></span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了与内置操作保持一致，后置递增或递减运算符应该返回运算前对象的原值（返回类型建议设置为原对象的<code>const</code>类型）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;    <span class="comment">// save the current value</span></span><br><span class="line">    ++*<span class="keyword">this</span>;      <span class="comment">// advance one element; prefix ++ checks the increment</span></span><br><span class="line">    <span class="keyword">return</span> ret;   <span class="comment">// return the saved state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想通过函数调用的方式使用后置递增或递减运算符，则必须为它的整型参数传递一个值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;   <span class="comment">// p points to the vector inside a1</span></span><br><span class="line">p.<span class="keyword">operator</span>++(<span class="number">0</span>);    <span class="comment">// call postfix operator++</span></span><br><span class="line">p.<span class="keyword">operator</span>++();     <span class="comment">// call prefix operator++</span></span><br></pre></td></tr></table></figure>
<h3 id="成员访问运算符（Member-Access-Operators）">成员访问运算符（Member Access Operators）</h3>
<p>箭头运算符必须定义为成员函数，解引用运算符通常也是如此。</p>
<p>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的类的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr];   <span class="comment">// (*p) is the vector to which this object points</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::string* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">    &#123;   <span class="comment">// delegate the real work to the dereference operator</span></span><br><span class="line">        <span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于形如<code>point-&gt;mem</code>的表达式来说，<code>point</code>必须是指向类对象的指针或者是一个重载了<code>operator-&gt;</code>的类的对象。<code>point</code>类型不同，<code>point-&gt;mem</code>的含义也不同。</p>
<ul>
<li>如果<code>point</code>是指针，则调用内置箭头运算符，表达式等价于<code>(*point).mem</code>。</li>
<li>如果<code>point</code>是重载了<code>operator-&gt;</code>的类的对象，则使用<code>point.operator-&gt;()</code>的结果来获取<code>mem</code>，表达式等价于<code>(point.operator-&gt;())-&gt;mem</code>。其中，如果该结果是一个指针，则执行内置操作，否则重复调用当前操作。</li>
</ul>
<h3 id="函数调用运算符（Function-Call-Operator）">函数调用运算符（Function-Call Operator）</h3>
<p>函数调用运算符必须定义为成员函数。一个类可以定义多个不同版本的调用运算符，相互之间必须在参数数量或类型上有所区别。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrintString</span>(ostream &amp;o = cout, <span class="keyword">char</span> c = <span class="string">&#x27; &#x27;</span>):</span><br><span class="line">        <span class="built_in">os</span>(o), <span class="built_in">sep</span>(c) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> string &amp;s)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        os &lt;&lt; s &lt;&lt; sep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ostream &amp;os;   <span class="comment">// stream on which to write</span></span><br><span class="line">    <span class="keyword">char</span> sep;      <span class="comment">// character to print after each output</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PrintString printer;  <span class="comment">// uses the defaults; prints to cout</span></span><br><span class="line"><span class="built_in">printer</span>(s);     <span class="comment">// prints s followed by a space on cout</span></span><br></pre></td></tr></table></figure>
<p>如果类定义了调用运算符，则该类的对象被称作函数对象（function object），函数对象常常作为泛型算法的实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>(), <span class="built_in">PrintString</span>(cerr, <span class="string">&#x27;\n&#x27;</span>));</span><br></pre></td></tr></table></figure>
<h4 id="lambda是函数对象（Lambdas-Are-Function-Objects）">lambda是函数对象（Lambdas Are Function Objects）</h4>
<p>编写一个<code>lambda</code>后，编译器会将该表达式转换成一个未命名类的未命名对象，类中含有一个重载的函数调用运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort words by size, but maintain alphabetical order for words of the same size</span></span><br><span class="line"><span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">    [](<span class="keyword">const</span> string &amp;a, <span class="keyword">const</span> string &amp;b) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>(); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// acts like an unnamed object of a class that would look something like</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShorterString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>lambda</code>默认不能改变它捕获的变量。因此在默认情况下，由<code>lambda</code>产生的类中的函数调用运算符是一个<code>const</code>成员函数。如果<code>lambda</code>被声明为可变的，则调用运算符就不再是<code>const</code>函数了。</p>
<p><code>lambda</code>通过引用捕获变量时，由程序负责确保<code>lambda</code>执行时该引用所绑定的对象确实存在。因此编译器可以直接使用该引用而无须在<code>lambda</code>产生的类中将其存储为数据成员。相反，通过值捕获的变量被拷贝到<code>lambda</code>中，此时<code>lambda</code>产生的类必须为每个值捕获的变量建立对应的数据成员，并创建构造函数，用捕获变量的值来初始化数据成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get an iterator to the first element whose size() is &gt;= sz</span></span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">            [sz](<span class="keyword">const</span> string &amp;a) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// would generate a class that looks something like</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizeComp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SizeComp</span>(<span class="keyword">size_t</span> n): <span class="built_in">sz</span>(n) &#123; &#125;   <span class="comment">// parameter for each captured variable</span></span><br><span class="line">    <span class="comment">// call operator with the same return type, parameters, and body as the lambda</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> string &amp;s)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> sz;   <span class="comment">// a data member for each variable captured by value</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>lambda</code>产生的类不包含默认构造函数、赋值运算符和默认析构函数，它是否包含默认拷贝/移动构造函数则通常要视捕获的变量类型而定。</p>
<h4 id="标准库定义的函数对象（Library-Defined-Function-Objects）">标准库定义的函数对象（Library-Defined Function Objects）</h4>
<p>标准库在头文件<code>functional</code>中定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。这些类都被定义为模板的形式，可以为其指定具体的应用类型（即调用运算符的形参类型）。</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031703444.png" alt="14-2" style="zoom:80%;" />
<p>关系运算符的函数对象类通常被用来替换算法中的默认运算符，这些类对于指针同样适用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string *&gt; nameTable;    <span class="comment">// vector of pointers</span></span><br><span class="line"><span class="comment">// error: the pointers in nameTable are unrelated, so &lt; is undefined</span></span><br><span class="line"><span class="built_in">sort</span>(nameTable.<span class="built_in">begin</span>(), nameTable.<span class="built_in">end</span>(),</span><br><span class="line">        [](string *a, string *b) &#123; <span class="keyword">return</span> a &lt; b; &#125;);</span><br><span class="line"><span class="comment">// ok: library guarantees that less on pointer types is well defined</span></span><br><span class="line"><span class="built_in">sort</span>(nameTable.<span class="built_in">begin</span>(), nameTable.<span class="built_in">end</span>(), less&lt;string*&gt;());</span><br></pre></td></tr></table></figure>
<h4 id="可调用对象与function（Callable-Objects-and-function）">可调用对象与function（Callable Objects and function）</h4>
<p>调用形式指明了调用返回的类型以及传递给调用的实参类型。不同的可调用对象可能具有相同的调用形式。</p>
<p>标准库<code>function</code>类型是一个模板，定义在头文件<code>functional</code>中，用来表示对象的调用形式。</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031702764.png" alt="14-3" style="zoom:80%;" />
<p>创建一个具体的<code>function</code>类型时必须提供其所表示的对象的调用形式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ordinary function</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i + j; &#125;</span><br><span class="line"><span class="comment">// function-object class</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">div</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> denominator, <span class="keyword">int</span> divisor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> denominator / divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = add;      <span class="comment">// function pointer</span></span><br><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f2 = <span class="built_in">div</span>();    <span class="comment">// object of a function-object class</span></span><br><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f3 = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123; <span class="keyword">return</span> i * j; &#125;;  <span class="comment">// lambda</span></span><br><span class="line">                                   </span><br><span class="line">cout &lt;&lt; <span class="built_in">f1</span>(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl;   <span class="comment">// prints 6</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f2</span>(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl;   <span class="comment">// prints 2</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f3</span>(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl;   <span class="comment">// prints 8</span></span><br></pre></td></tr></table></figure>
<p>不能直接将重载函数的名字存入<code>function</code>类型的对象中，这样做会产生二义性错误。消除二义性的方法是使用<code>lambda</code>或者存储函数指针而非函数名字。</p>
<p>C++11新标准库中的<code>function</code>类与旧版本中的<code>unary_function</code>和<code>binary_function</code>没有关系，后两个类已经被<code>bind</code>函数代替。</p>
<h3 id="重载、类型转换与运算符（Overloading，Conversions，and-Operators）">重载、类型转换与运算符（Overloading，Conversions，and Operators）</h3>
<p>转换构造函数和类型转换运算符共同定义了类类型转换（class-type conversion）。</p>
<h4 id="类型转换运算符（Conversion-Operators）">类型转换运算符（Conversion Operators）</h4>
<p>类型转换运算符是类的一种特殊成员函数，负责将一个类类型的值转换成其他类型。它不能声明返回类型，形参列表也必须为空，一般形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>类型转换运算符可以面向除了<code>void</code>以外的任意类型（该类型要能作为函数的返回类型）进行定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="keyword">int</span> i = <span class="number">0</span>): <span class="built_in">val</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Bad SmallInt value&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后，并与其一起使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the double argument is converted to int using the built-in conversion</span></span><br><span class="line">SmallInt si = <span class="number">3.14</span>;     <span class="comment">// calls the SmallInt(int) constructor</span></span><br><span class="line"><span class="comment">// the SmallInt conversion operator converts si to int;</span></span><br><span class="line">si + <span class="number">3.14</span>;     <span class="comment">// that int is converted to double using the built-in conversion</span></span><br></pre></td></tr></table></figure>
<p>应该避免过度使用类型转换函数。如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性。</p>
<p>C++11引入了显示的类型转换运算符（explicit conversion operator）。和显式构造函数一样，编译器通常不会将显式类型转换运算符用于隐式类型转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// the compiler won&#x27;t automatically apply this conversion</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt si = <span class="number">3</span>;    <span class="comment">// ok: the SmallInt constructor is not explicit</span></span><br><span class="line">si + <span class="number">3</span>;     <span class="comment">// error: implicit is conversion required, but operator int is explicit</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>;    <span class="comment">// ok: explicitly request the conversion</span></span><br></pre></td></tr></table></figure>
<p>如果表达式被用作条件，则编译器会隐式地执行显式类型转换。</p>
<ul>
<li><code>if</code>、<code>while</code>、<code>do-while</code>语句的条件部分。</li>
<li><code>for</code>语句头的条件表达式。</li>
<li>条件运算符<code>? :</code>的条件表达式。</li>
<li>逻辑非运算符<code>!</code>、逻辑或运算符<code>||</code>、逻辑与运算符<code>&amp;&amp;</code>的运算对象。</li>
</ul>
<p>类类型向<code>bool</code>的类型转换通常用在条件部分，因此<code>operator bool</code>一般被定义为显式的。</p>
<h4 id="避免有二义性的类型转换（Avoiding-Ambiguous-Conversions）">避免有二义性的类型转换（Avoiding Ambiguous Conversions）</h4>
<p>在两种情况下可能产生多重转换路径：</p>
<ul>
<li>
<p><code>A</code>类定义了一个接受<code>B</code>类对象的转换构造函数，同时<code>B</code>类定义了一个转换目标是<code>A</code>类的类型转换运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usually a bad idea to have mutual conversions between two class types</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> B&amp;); <span class="comment">// converts a B to an A</span></span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// also converts a B to an A</span></span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">(<span class="keyword">const</span> A&amp;)</span></span>;</span><br><span class="line">B b;</span><br><span class="line">A a = <span class="built_in">f</span>(b);    <span class="comment">// error ambiguous: f(B::operator A())</span></span><br><span class="line">               <span class="comment">// or f(A::A(const B&amp;))</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类定义了多个类型转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> = <span class="number">0</span>);     <span class="comment">// usually a bad idea to have two</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">double</span>);      <span class="comment">// conversions from arithmetic types</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// usually a bad idea to have two</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">// conversions to arithmetic types</span></span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span>)</span></span>;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">f2</span>(a);    <span class="comment">// error ambiguous: f(A::operator int())</span></span><br><span class="line">          <span class="comment">// or f(A::operator double())</span></span><br><span class="line"><span class="keyword">long</span> lg;</span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(lg)</span></span>;   <span class="comment">// error ambiguous: A::A(int) or A::A(double)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以通过显式调用类型转换运算符或转换构造函数解决二义性问题，但不能使用强制类型转换，因为强制类型转换本身也存在二义性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a1 = <span class="built_in">f</span>(b.<span class="keyword">operator</span> <span class="built_in">A</span>());    <span class="comment">// ok: use B&#x27;s conversion operator</span></span><br><span class="line">A a2 = <span class="built_in">f</span>(<span class="built_in">A</span>(b));     <span class="comment">// ok: use A&#x27;s constructor</span></span><br></pre></td></tr></table></figure>
<p>通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标都是算术类型的转换。</p>
<p>使用两个用户定义的类型转换时，如果转换前后存在标准类型转换，则由标准类型转换决定最佳匹配。</p>
<p>如果在调用重载函数时需要使用构造函数或者强制类型转换来改变实参的类型，通常意味着程序设计存在不足。</p>
<p>调用重载函数时，如果需要额外的标准类型转换，则该转换只有在所有可行函数都请求同一个用户定义类型转换时才有用。如果所需的用户定义类型转换不止一个，即使其中一个调用能精确匹配而另一个调用需要额外的标准类型转换，也会产生二义性错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">C</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">E</span>(<span class="keyword">double</span>);</span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip2</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip2</span><span class="params">(<span class="keyword">const</span> E&amp;)</span></span>;</span><br><span class="line"><span class="comment">// error ambiguous: two different user-defined conversions could be used</span></span><br><span class="line"><span class="built_in">manip2</span>(<span class="number">10</span>);    <span class="comment">// manip2(C(10) or manip2(E(double(10)))</span></span><br></pre></td></tr></table></figure>
<h4 id="函数匹配与重载运算符（Function-Matching-and-Overloaded-Operators）">函数匹配与重载运算符（Function Matching and Overloaded Operators）</h4>
<p>表达式中运算符的候选函数集既包括成员函数，也包括非成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> SmallInt <span class="keyword">operator</span>+(<span class="keyword">const</span> SmallInt&amp;, <span class="keyword">const</span> SmallInt&amp;);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="keyword">int</span> = <span class="number">0</span>);    <span class="comment">// conversion from int</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;    <span class="comment">// conversion to int</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt s1, s2;</span><br><span class="line">SmallInt s3 = s1 + s2;    <span class="comment">// uses overloaded operator+</span></span><br><span class="line"><span class="keyword">int</span> i = s3 + <span class="number">0</span>;    <span class="comment">// error: ambiguous</span></span><br></pre></td></tr></table></figure>
<p>如果类既定义了转换目标是算术类型的类型转换，也定义了重载的运算符，则会遇到重载运算符与内置运算符的二义性问题。</p>
<hr>
<h2 id="第15章-面向对象程序设计（简）">第15章 面向对象程序设计（简）</h2>
<h3 id="OOP：概述">OOP：概述</h3>
<ul>
<li>面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。</li>
<li><strong>继承</strong>（inheritance）：
<ul>
<li>通过继承联系在一起的类构成一种层次关系。</li>
<li>通常在层次关系的根部有一个<strong>基类</strong>（base class）。</li>
<li>其他类直接或者简介从基类继承而来，这些继承得到的类成为<strong>派生类</strong>（derived class）。</li>
<li>基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</li>
<li>对于某些函数，基类希望它的派生类个自定义适合自己的版本，此时基类就将这些函数声明成<strong>虚函数</strong>（virtual function）。</li>
<li>派生类必须通过使用<strong>类派生列表</strong>（class derivation list）明确指出它是从哪个基类继承而来。形式：一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前都可以有访问说明符。<code>class Bulk_quote : public Quote&#123;&#125;;</code></li>
<li>派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数之前加上<code>virtual</code>关键字，也可以不加。C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个<code>override</code>关键字。</li>
</ul>
</li>
<li><strong>动态绑定</strong>（dynamic binding，又称运行时绑定）：
<ul>
<li>使用同一段代码可以分别处理基类和派生类的对象。</li>
<li>函数的运行版本由实参决定，即在运行时选择函数的版本。</li>
</ul>
</li>
</ul>
<h3 id="定义基类和派生类">定义基类和派生类</h3>
<h4 id="定义基类">定义基类</h4>
<ul>
<li>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</li>
<li>基类通过在其成员函数的声明语句前加上关键字<code>virtual</code>使得该函数执行<strong>动态绑定</strong>。</li>
<li>如果成员函数没有被声明为虚函数，则解析过程发生在编译时而非运行时。</li>
<li>访问控制：
<ul>
<li><code>protected</code> ： 基类和和其派生类还有友元可以访问。</li>
<li><code>private</code> ： 只有基类本身和友元可以访问。</li>
</ul>
</li>
</ul>
<h4 id="定义派生类">定义派生类</h4>
<ul>
<li>派生类必须通过类派生列表（class derivation list）明确指出它是从哪个基类继承而来。形式：冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有一下三种访问说明符的一个：<code>public</code>、<code>protected</code>、<code>private</code>。</li>
<li>C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个<code>override</code>关键字。</li>
<li>派生类构造函数：派生类必须使用基类的构造函数去初始化它的基类部分。</li>
<li>静态成员：如果基类定义了一个基类成员，则在整个继承体系中只存在该成员的唯一定义。</li>
<li>派生类的声明：声明中不包含它的派生列表。</li>
<li>C++11新标准提供了一种防止继承的方法，在类名后面跟一个关键字<code>final</code>。</li>
</ul>
<h4 id="类型转换与继承">类型转换与继承</h4>
<ul>
<li>理解基类和派生类之间的类型抓换是理解C++语言面向对象编程的关键所在。</li>
<li>可以将基类的指针或引用绑定到派生类对象上。</li>
<li>不存在从基类向派生类的隐式类型转换。</li>
<li>派生类向基类的自动类型转换只对指针或引用类型有效，对象之间不存在类型转换。</li>
</ul>
<h3 id="虚函数">虚函数</h3>
<ul>
<li>使用虚函数可以执行动态绑定。</li>
<li>OOP的核心思想是多态性（polymorphism）。</li>
<li>当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。</li>
<li>派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数之前加上<code>virtual</code>关键字，也可以不加。</li>
<li>C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个<code>override</code>关键字。</li>
<li>如果我们想覆盖某个虚函数，但不小心把形参列表弄错了，这个时候就不会覆盖基类中的虚函数。加上<code>override</code>可以明确程序员的意图，让编译器帮忙确认参数列表是否出错。</li>
<li>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</li>
<li>通常，只有成员函数（或友元）中的代码才需要使用<strong>作用域运算符</strong>（<code>::</code>）来回避虚函数的机制。</li>
</ul>
<h3 id="抽象基类">抽象基类</h3>
<ul>
<li><strong>纯虚函数</strong>（pure virtual）：清晰地告诉用户当前的函数是没有实际意义的。纯虚函数无需定义，只用在函数体的位置前书写<code>=0</code>就可以将一个虚函数说明为纯虚函数。</li>
<li>含有纯虚函数的类是<strong>抽象基类</strong>（abstract base class）。不能创建抽象基类的对象。</li>
</ul>
<h3 id="访问控制与继承">访问控制与继承</h3>
<ul>
<li>受保护的成员：
<ul>
<li><code>protected</code>说明符可以看做是<code>public</code>和<code>private</code>中的产物。</li>
<li>类似于私有成员，受保护的成员对类的用户来说是不可访问的。</li>
<li>类似于公有成员，受保护的成员对于派生类的成员和友元来说是可访问的。</li>
<li>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。</li>
</ul>
</li>
<li>派生访问说明符：
<ul>
<li>对于派生类的成员（及友元）能否访问其直接积累的成员没什么影响。</li>
<li>派生访问说明符的目的是：控制派生类用户对于基类成员的访问权限。比如<code>struct Priv_Drev: private Base&#123;&#125;</code>意味着在派生类<code>Priv_Drev</code>中，从<code>Base</code>继承而来的部分都是<code>private</code>的。</li>
</ul>
</li>
<li>友元关系不能继承。</li>
<li>改变个别成员的可访问性：使用<code>using</code>。</li>
<li>默认情况下，使用<code>class</code>关键字定义的派生类是私有继承的；使用<code>struct</code>关键字定义的派生类是公有继承的。</li>
</ul>
<h3 id="继承中的类作用域">继承中的类作用域</h3>
<ul>
<li>每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。</li>
<li>派生类的成员将隐藏同名的基类成员。</li>
<li>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</li>
</ul>
<h3 id="构造函数与拷贝控制">构造函数与拷贝控制</h3>
<h4 id="虚析构函数">虚析构函数</h4>
<ul>
<li>基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。</li>
<li>如果基类的析构函数不是虚函数，则<code>delete</code>一个指向派生类对象的基类指针将产生未定义的行为。</li>
<li>虚析构函数将阻止合成移动操作。</li>
</ul>
<h4 id="合成拷贝控制与继承">合成拷贝控制与继承</h4>
<ul>
<li>基类或派生类的合成拷贝控制成员的行为和其他合成的构造函数、赋值运算符或析构函数类似：他们对类本身的成员依次进行初始化、赋值或销毁的操作。</li>
</ul>
<h4 id="派生类的拷贝控制成员">派生类的拷贝控制成员</h4>
<ul>
<li>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。</li>
<li>派生类析构函数：派生类析构函数先执行，然后执行基类的析构函数。</li>
</ul>
<h4 id="继承的构造函数">继承的构造函数</h4>
<ul>
<li>C++11新标准中，派生类可以重用其直接基类定义的构造函数。</li>
<li>如<code>using Disc_quote::Disc_quote;</code>，注明了要继承<code>Disc_quote</code>的构造函数。</li>
</ul>
<h3 id="容器与继承">容器与继承</h3>
<ul>
<li>当我们使用容器存放继承体系中的对象时，通常必须采用间接存储的方式。</li>
<li>派生类对象直接赋值给积累对象，其中的派生类部分会被切掉。</li>
<li>在容器中放置（智能）指针而非对象。</li>
<li>对于C++面向对象的编程来说，一个悖论是我们无法直接使用对象进行面向对象编程。相反，我们必须使用指针和引用。因为指针会增加程序的复杂性，所以经常定义一些辅助的类来处理这些复杂的情况。</li>
</ul>
<h3 id="文本查询程序再探">文本查询程序再探</h3>
<ul>
<li>使系统支持：单词查询、逻辑非查询、逻辑或查询、逻辑与查询。</li>
</ul>
<h4 id="面向对象的解决方案">面向对象的解决方案</h4>
<ul>
<li>将几种不同的查询建模成相互独立的类，这些类共享一个公共基类：
<ul>
<li><code>WordQuery</code></li>
<li><code>NotQuery</code></li>
<li><code>OrQuery</code></li>
<li><code>AndQuery</code></li>
</ul>
</li>
<li>这些类包含两个操作：
<ul>
<li><code>eval</code>：接受一个<code>TextQuery</code>对象并返回一个<code>QueryResult</code>。</li>
<li><code>rep</code>：返回基础查询的<code>string</code>表示形式。</li>
</ul>
</li>
<li>继承和组合：
<ul>
<li>当我们令一个类公有地继承另一个类时，派生类应当反映与基类的“是一种（Is A）”的关系。</li>
<li>类型之间另一种常见的关系是“有一个（Has A）”的关系。</li>
</ul>
</li>
<li>对于面向对象编程的新手来说，想要理解一个程序，最困难的部分往往是理解程序的设计思路。一旦掌握了设计思路，接下来的实现也就水到渠成了。</li>
</ul>
<p><strong>Query程序设计</strong>:</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Query</code>程序接口类和操作</td>
<td></td>
</tr>
<tr>
<td><code>TextQuery</code></td>
<td>该类读入给定的文件并构建一个查找图。包含一个<code>query</code>操作，它接受一个<code>string</code>实参，返回一个<code>QueryResult</code>对象；该<code>QueryResult</code>对象表示<code>string</code>出现的行。</td>
</tr>
<tr>
<td><code>QueryResult</code></td>
<td>该类保存一个<code>query</code>操作的结果。</td>
</tr>
<tr>
<td><code>Query</code></td>
<td>是一个接口类，指向<code>Query_base</code>派生类的对象。</td>
</tr>
<tr>
<td><code>Query q(s)</code></td>
<td>将<code>Query</code>对象<code>q</code>绑定到一个存放着<code>string s</code>的新<code>WordQuery</code>对象上。</td>
</tr>
<tr>
<td><code>q1 &amp; q2</code></td>
<td>返回一个<code>Query</code>对象，该<code>Query</code>绑定到一个存放<code>q1</code>和<code>q2</code>的新<code>AndQuery</code>对象上。</td>
</tr>
<tr>
<td><code>q1 | q2</code></td>
<td>返回一个<code>Query</code>对象，该<code>Query</code>绑定到一个存放<code>q1</code>和<code>q2</code>的新<code>OrQuery</code>对象上。</td>
</tr>
<tr>
<td><code>~q</code></td>
<td>返回一个<code>Query</code>对象，该<code>Query</code>绑定到一个存放<code>q</code>的新<code>NotQuery</code>对象上。</td>
</tr>
<tr>
<td><code>Query</code>程序实现类</td>
<td></td>
</tr>
<tr>
<td><code>Query_base</code></td>
<td>查询类的抽象基类</td>
</tr>
<tr>
<td><code>WordQuery</code></td>
<td><code>Query_base</code>的派生类，用于查找一个给定的单词</td>
</tr>
<tr>
<td><code>NotQuery</code></td>
<td><code>Query_base</code>的派生类，用于查找一个给定的单词</td>
</tr>
<tr>
<td><code>BinaryQuery</code></td>
<td><code>Query_base</code>的派生类，查询结果是<code>Query</code>运算对象没有出现的行的集合</td>
</tr>
<tr>
<td><code>OrQuery</code></td>
<td><code>Query_base</code>的派生类，返回它的两个运算对象分别出现的行的并集</td>
</tr>
<tr>
<td><code>AndQuery</code></td>
<td><code>Query_base</code>的派生类，返回它的两个运算对象分别出现的行的交集</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="第15章-面向对象程序设计">第15章 面向对象程序设计</h2>
<h3 id="OOP：概述（OOP：An-Overview）">OOP：概述（OOP：An Overview）</h3>
<p>面向对象程序设计（object-oriented programming）的核心思想是数据抽象（封装）、继承和动态绑定（多态）。</p>
<p>通过继承（inheritance）联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类（base class），其他类则直接或间接地从基类继承而来，这些继承得到的类叫做派生类（derived class）。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p>
<p>对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类应该将这些函数声明为虚函数（virtual function）。方法是在函数名称前添加<code>virtual</code>关键字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类必须通过类派生列表（class derivation list）明确指出它是从哪个或哪些基类继承而来的。类派生列表的形式首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以添加访问说明符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote</span><br><span class="line">&#123; <span class="comment">// Bulk_quote inherits from Quote</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类必须在其内部对所有重新定义的虚函数进行声明。</p>
<p>使用基类的引用或指针调用一个虚函数时将发生动态绑定（dynamic binding），也叫运行时绑定（run-time binding）。函数的运行版本将由实参决定。</p>
<h3 id="定义基类和派生类（Defining-Base-and-Derived-Classes）">定义基类和派生类（Defining Base and Derived Classes）</h3>
<h4 id="定义基类（Defining-a-Base-Class）">定义基类（Defining a Base Class）</h4>
<p>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</p>
<p>除构造函数之外的任何非静态函数都能定义为虚函数。<code>virtual</code>关键字只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数。</p>
<p>成员函数如果没有被声明为虚函数，则其解析过程发生在编译阶段而非运行阶段。</p>
<p>派生类能访问基类的公有成员，不能访问私有成员。如果基类希望定义外部代码无法访问，但是派生类对象可以访问的成员，可以使用受保护的（protected）访问运算符进行说明。</p>
<h4 id="定义派生类（Defining-a-Derived-Class）">定义派生类（Defining a Derived Class）</h4>
<p>类派生列表中的访问说明符用于控制派生类从基类继承而来的成员是否对派生类的用户可见。</p>
<p>如果派生类没有覆盖其基类的某个虚函数，则该虚函数的行为类似于其他的普通函数，派生类会直接继承其在基类中的版本。</p>
<p>C++标准并没有明确规定派生类的对象在内存中如何分布，一个对象中继承自基类的部分和派生类自定义的部分不一定是连续存储的。</p>
<p>因为在派生类对象中含有与其基类对应的组成部分，所以能把派生类的对象当作基类对象来使用，也能将基类的指针或引用绑定到派生类对象中的基类部分上。这种转换通常称为派生类到基类的（derived-to-base）类型转换，编译器会隐式执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;         <span class="comment">// object of base type</span></span><br><span class="line">Bulk_quote bulk;    <span class="comment">// object of derived type</span></span><br><span class="line">Quote *p = &amp;item;   <span class="comment">// p points to a Quote object</span></span><br><span class="line">p = &amp;bulk;          <span class="comment">// p points to the Quote part of bulk</span></span><br><span class="line">Quote &amp;r = bulk;    <span class="comment">// r bound to the Quote part of bulk</span></span><br></pre></td></tr></table></figure>
<p>每个类控制它自己的成员初始化过程，派生类必须使用基类的构造函数来初始化它的基类部分。派生类的构造函数通过构造函数初始化列表来将实参传递给基类构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Bulk_quote</span>(<span class="keyword">const</span> std::string&amp; book, <span class="keyword">double</span> p, </span><br><span class="line">            std::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) :</span><br><span class="line">    <span class="built_in">Quote</span>(book, p), <span class="built_in">min_qty</span>(qty), <span class="built_in">discount</span>(disc) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。</p>
<p>派生类初始化时首先初始化基类部分，然后按照声明的顺序依次初始化派生类成员。</p>
<p>派生类可以访问基类的公有成员和受保护成员。</p>
<p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。如果某静态成员是可访问的，则既能通过基类也能通过派生类使用它。</p>
<p>已经完整定义的类才能被用作基类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> <span class="comment">/* ... */</span> &#125; ;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">public</span> D1 &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure>
<p><code>Base</code>是<code>D1</code>的直接基类（direct base），是<code>D2</code>的间接基类（indirect base）。最终的派生类将包含它直接基类的子对象以及每个间接基类的子对象。</p>
<p>C++11中，在类名后面添加<code>final</code>关键字可以禁止其他类继承它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="keyword">final</span> &#123;</span> <span class="comment">/* */</span> &#125;;    <span class="comment">// NoDerived can&#x27;t be a base class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> <span class="comment">/* */</span> &#125;;</span><br><span class="line"><span class="comment">// Last is final; we cannot inherit from Last</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Last</span> <span class="keyword">final</span> :</span> Base &#123; <span class="comment">/* */</span> &#125;;  <span class="comment">// Last can&#x27;t be a base class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bad</span> :</span> NoDerived &#123; <span class="comment">/* */</span> &#125;;    <span class="comment">// error: NoDerived is final</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bad2</span> :</span> Last &#123; <span class="comment">/* */</span> &#125;;        <span class="comment">// error: Last is final</span></span><br></pre></td></tr></table></figure>
<h4 id="类型转换与继承（Conversions-and-Inheritance）">类型转换与继承（Conversions and Inheritance）</h4>
<p>和内置指针一样，智能指针类也支持派生类到基类的类型转换，所以可以将一个派生类对象的指针存储在一个基类的智能指针内。</p>
<p>表达式的静态类型（static type）在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型（dynamic type）则是变量或表达式表示的内存中对象的类型，只有运行时才可知。</p>
<p>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。</p>
<p>不存在从基类到派生类的隐式类型转换，即使一个基类指针或引用绑定在一个派生类对象上也不行，因为编译器只能通过检查指针或引用的静态类型来判断转换是否合法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quote base;</span><br><span class="line">Bulk_quote* bulkP = &amp;base;   <span class="comment">// error: can&#x27;t convert base to derived</span></span><br><span class="line">Bulk_quote&amp; bulkRef = base;  <span class="comment">// error: can&#x27;t convert base to derived</span></span><br></pre></td></tr></table></figure>
<p>如果在基类中含有一个或多个虚函数，可以使用<code>dynamic_cast</code>运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用，该转换的安全检查将在运行期间执行。</p>
<p>如果已知某个基类到派生类的转换是安全的，可以使用<code>static_cast</code>强制覆盖掉编译器的检查工作。</p>
<p>派生类到基类的自动类型转换只对指针或引用有效，在派生类类型和基类类型之间不存在这种转换。</p>
<p>派生类到基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象，这些操作是基类定义的，只会处理基类自己的成员，派生类的部分被切掉（sliced down）了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;    <span class="comment">// object of derived type</span></span><br><span class="line"><span class="function">Quote <span class="title">item</span><span class="params">(bulk)</span></span>;   <span class="comment">// uses the Quote::Quote(const Quote&amp;) constructor</span></span><br><span class="line">item = bulk;        <span class="comment">// calls Quote::operator=(const Quote&amp;)</span></span><br></pre></td></tr></table></figure>
<p>用一个派生类对象为一个基类对象初始化或赋值时，只有该对象中的基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略掉。</p>
<h3 id="虚函数（Virtual-Functions）">虚函数（Virtual Functions）</h3>
<p>当且仅当通过指针或引用调用虚函数时，才会在运行过程解析该调用，也只有在这种情况下对象的动态类型有可能与静态类型不同。</p>
<p>在派生类中覆盖某个虚函数时，可以再次使用<code>virtual</code>关键字说明函数性质，但这并非强制要求。因为一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数。</p>
<p>在派生类中覆盖某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。</p>
<p>派生类可以定义一个与基类中的虚函数名字相同但形参列表不同的函数，但编译器会认为该函数与基类中原有的函数是相互独立的，此时派生类的函数并没有覆盖掉基类中的版本。</p>
<p>C++11允许派生类使用<code>override</code>关键字显式地注明虚函数。如果<code>override</code>标记了某个函数，但该函数并没有覆盖已存在的虚函数，编译器将报告错误。<code>override</code>位于函数参数列表之后。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> B </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;    <span class="comment">// ok: f1 matches f1 in the base</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>;      <span class="comment">// error: B has no f2(int) function</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;     <span class="comment">// error: f3 not virtual</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;     <span class="comment">// error: B doesn&#x27;t have a function named f4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与禁止类继承类似，函数也可以通过添加<code>final</code>关键字来禁止覆盖操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span> :</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// inherits f2() and f3() from B and overrides f1(int)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">final</span></span>;   <span class="comment">// subsequent classes can&#x27;t override f1(int)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>final</code>和<code>override</code>关键字出现在形参列表（包括任何<code>const</code>或引用修饰符）以及尾置返回类型之后。</p>
<p>虚函数也可以有默认实参，每次函数调用的默认实参值由本次调用的静态类型决定。如果通过基类的指针或引用调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。</p>
<p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参值最好一致。</p>
<p>使用作用域运算符<code>::</code>可以强制执行虚函数的某个版本，不进行动态绑定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calls the version from the base class regardless of the dynamic type of baseP</span></span><br><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>通常情况下，只有成员函数或友元中的代码才需要使用作用域运算符来回避虚函数的动态绑定机制。</p>
<p>如果一个派生类虚函数需要调用它的基类版本，但没有使用作用域运算符，则在运行时该调用会被解析为对派生类版本自身的调用，从而导致无限递归。</p>
<h3 id="抽象基类（Abstract-Base-Classes）">抽象基类（Abstract Base Classes）</h3>
<p>在类内部虚函数声明语句的分号前添加<code>=0</code>可以将一个虚函数声明为纯虚（pure virtual）函数。一个纯虚函数无须定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>可以为纯虚函数提供定义，但函数体必须定义在类的外部。</p>
<p>含有（或未经覆盖直接继承）纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。</p>
<p>不能创建抽象基类的对象。</p>
<p>派生类构造函数只初始化它的直接基类。</p>
<p>重构（refactoring）负责重新设计类的体系以便将操作或数据从一个类移动到另一个类中。</p>
<h3 id="访问控制与继承（Access-Control-and-Inheritance）">访问控制与继承（Access Control and Inheritance）</h3>
<p>一个类可以使用<code>protected</code>关键字来声明外部代码无法访问，但是派生类对象可以访问的成员。</p>
<p>派生类的成员或友元只能通过派生类对象来访问基类的<code>protected</code>成员。派生类对于一个基类对象中的<code>protected</code>成员没有任何访问权限。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> prot_mem;   <span class="comment">// protected member</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;   <span class="comment">// can access Sneaky::prot_mem</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;     <span class="comment">// can&#x27;t access Base::prot_mem</span></span><br><span class="line">    <span class="keyword">int</span> j;   <span class="comment">// j is private by default</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok: clobber can access the private and protected members in Sneaky objects</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123; s.j = s.prot_mem = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">// error: clobber can&#x27;t access the protected members in Base</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span> </span>&#123; b.prot_mem = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>基类中成员的访问说明符和派生列表中的访问说明符都会影响某个类对其继承成员的访问权限。</p>
<p>派生访问说明符对于派生类的成员及友元能否访问其直接基类的成员没有影响，对基类成员的访问权限只与基类中的访问说明符有关。</p>
<p>派生访问说明符的作用是控制派生类（包括派生类的派生类）用户对于基类成员的访问权限。</p>
<ul>
<li>如果使用公有继承，则基类的公有成员和受保护成员在派生类中属性不发生改变。</li>
<li>如果使用受保护继承，则基类的公有成员和受保护成员在派生类中变为受保护成员。</li>
<li>如果使用私有继承，则基类的公有成员和受保护成员在派生类中变为私有成员。</li>
</ul>
<p>派生类到基类转换的可访问性（假定<code>D</code>继承自<code>B</code>）：</p>
<ul>
<li>只有当<code>D</code>公有地继承<code>B</code>时，用户代码才能使用派生类到基类的转换。</li>
<li>不论<code>D</code>以什么方式继承<code>B</code>，<code>D</code>的成员函数和友元都能使用派生类到基类的转换。</li>
<li>如果<code>D</code>继承<code>B</code>的方式是公有的或者受保护的，则<code>D</code>的派生类的成员函数和友元可以使用<code>D</code>到<code>B</code>的类型转换；反之，如果<code>D</code>继承<code>B</code>的方式是私有的，则不能使用。</li>
</ul>
<p>对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类到基类的类型转换也是可访问的。</p>
<p>友元对基类的访问权限由基类自身控制，即使对于派生类中的基类部分也是如此。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// added friend declaration; other members as before</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span>   <span class="comment">// Pal has no access to classes derived from Base</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(Base b)</span> </span>&#123; <span class="keyword">return</span> b.prot_mem; &#125;     <span class="comment">// ok: Pal is a friend of Base</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(Sneaky s)</span> </span>&#123; <span class="keyword">return</span> s.j; &#125;         <span class="comment">// error: Pal not friend of Sneaky</span></span><br><span class="line">    <span class="comment">// access to a base class is controlled by the base class, even inside a derived object</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">(Sneaky s)</span> </span>&#123; <span class="keyword">return</span> s.prot_mem; &#125;  <span class="comment">// ok: Pal is a friend</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>友元关系不能继承，每个类负责控制各自成员的访问权限。</p>
<p>使用<code>using</code>声明可以改变派生类继承的某个名字的访问级别。新的访问级别由该<code>using</code>声明之前的访问说明符决定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::<span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base</span><br><span class="line">&#123; <span class="comment">// note: private inheritance</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// maintain access levels for members related to the size of the object</span></span><br><span class="line">    <span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类只能为那些它可以访问的名字提供<code>using</code>声明。</p>
<p>默认情况下，使用<code>class</code>关键字定义的派生类是私有继承的，而使用<code>struct</code>关键字定义的派生类是公有继承的。</p>
<p>建议显式地声明派生类的继承方式，不要仅仅依赖于默认设置。</p>
<h3 id="继承中的类作用域（Class-Scope-under-Inheritance）">继承中的类作用域（Class Scope under Inheritance）</h3>
<p>当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。</p>
<p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。</p>
<p>派生类定义的成员会隐藏同名的基类成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_mem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mem; &#125;   <span class="comment">// returns Derived::mem  </span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> mem;    <span class="comment">// hides mem in the base</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以通过作用域运算符<code>::</code>来使用被隐藏的基类成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_base_mem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Base::mem; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</p>
<p>和其他函数一样，成员函数无论是否是虚函数都能被重载。</p>
<p>派生类可以覆盖重载函数的0个或多个实例。如果派生类希望所有的重载版本对它来说都是可见的，那么它就需要覆盖所有版本，或者一个也不覆盖。</p>
<p>有时一个类仅需覆盖重载集合中的一些而非全部函数，此时如果我们不得不覆盖基类中的每一个版本的话，操作会极其繁琐。为了简化操作，可以为重载成员提供<code>using</code>声明。<code>using</code>声明指定了一个函数名字但不指定形参列表，所以一条基类成员函数的<code>using</code>声明语句就可以把该函数的所有重载实例添加到派生类作用域中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fm3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fm3</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 让Base内名为mf1和mf3的所有定义</span></span><br><span class="line">    <span class="comment">// 在Derived作用域内可见</span></span><br><span class="line">    <span class="keyword">using</span> Base::mf1;</span><br><span class="line">    <span class="keyword">using</span> Base::mf3;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fm3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fm4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031704383.png" alt="15-1" style="zoom:80%;" />
<p>类内使用<code>using</code>声明改变访问级别的规则同样适用于重载函数的名字。</p>
<h3 id="构造函数与拷贝控制（Constructors-and-Copy-Control）">构造函数与拷贝控制（Constructors and Copy Control）</h3>
<h4 id="虚析构函数（Virtual-Destructors）">虚析构函数（Virtual Destructors）</h4>
<p>一般来说，如果一个类需要析构函数，那么它也需要拷贝和赋值操作。但基类的析构函数不遵循该规则。</p>
<p>基类通常应该定义一个虚析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// virtual destructor needed if a base pointer pointing to a derived object is deleted</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Quote</span>() = <span class="keyword">default</span>;   <span class="comment">// dynamic binding for the destructor</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果基类的析构函数不是虚函数，则<code>delete</code>一个指向派生类对象的基类指针会产生未定义的结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Quote *itemP = <span class="keyword">new</span> Quote;   <span class="comment">// same static and dynamic type</span></span><br><span class="line"><span class="keyword">delete</span> itemP;     <span class="comment">// destructor for Quote called</span></span><br><span class="line">itemP = <span class="keyword">new</span> Bulk_quote;     <span class="comment">// static and dynamic types differ</span></span><br><span class="line"><span class="keyword">delete</span> itemP;     <span class="comment">// destructor for Bulk_quote called</span></span><br></pre></td></tr></table></figure>
<p>虚析构函数会阻止编译器为类合成移动操作。</p>
<h4 id="合成拷贝控制与继承（Synthesized-Copy-Control-and-Inheritance）">合成拷贝控制与继承（Synthesized Copy Control and Inheritance）</h4>
<p>对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类直接基类的成员。</p>
<p>派生类中删除的拷贝控制与基类的关系：</p>
<ul>
<li>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的或者不可访问的函数，则派生类中对应的成员也会是被删除的。因为编译器不能使用基类成员来执行派生类对象中基类部分的构造、赋值或销毁操作。</li>
<li>如果基类的析构函数是被删除的或者不可访问的，则派生类中合成的默认和拷贝构造函数也会是被删除的。因为编译器无法销毁派生类对象中的基类部分。</li>
<li>编译器不会合成一个被删除的移动操作。当我们使用<code>=default</code>请求一个移动操作时，如果基类中对应的操作是被删除的或者不可访问的，则派生类中的操作也会是被删除的。因为派生类对象中的基类部分不能移动。同样，如果基类的析构函数是被删除的或者不可访问的，则派生类的移动构造函数也会是被删除的。</li>
</ul>
<p>在实际编程中，如果基类没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作。</p>
<p>因为基类缺少移动操作会阻止编译器为派生类合成自己的移动操作，所以当我们确实需要执行移动操作时，应该首先在基类中进行定义。</p>
<h4 id="派生类的拷贝控制成员（Derived-Class-Copy-Control-Members）">派生类的拷贝控制成员（Derived-Class Copy-Control Members）</h4>
<p>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类成员在内的整个对象。</p>
<p>当为派生类定义拷贝或移动构造函数时，通常使用对应的基类构造函数初始化对象的基类部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> <span class="comment">/* ... */</span> &#125; ;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// by default, the base class default constructor initializes the base part of an object</span></span><br><span class="line">    <span class="comment">// to use the copy or move constructor, we must explicitly call that</span></span><br><span class="line">    <span class="comment">// constructor in the constructor initializer list</span></span><br><span class="line">    <span class="built_in">D</span>(<span class="keyword">const</span> D&amp; d): <span class="built_in">Base</span>(d)   <span class="comment">// copy the base members</span></span><br><span class="line">    <span class="comment">/* initializers for members of D */</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="built_in">D</span>(D&amp;&amp; d): <span class="built_in">Base</span>(std::<span class="built_in">move</span>(d))    <span class="comment">// move the base members</span></span><br><span class="line">    <span class="comment">/* initializers for members of D */</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// probably incorrect definition of the D copy constructor</span></span><br><span class="line"><span class="comment">// base-class part is default initialized, not copied</span></span><br><span class="line"><span class="built_in">D</span>(<span class="keyword">const</span> D&amp; d)   <span class="comment">/* member initializers, but no base-class initializer */</span></span><br><span class="line">&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果想拷贝或移动基类部分，则必须在派生类的构造函数初始化列表中显式地使用基类的拷贝或移动构造函数。</p>
<p>派生类的赋值运算符必须显式地为其基类部分赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base::operator=(const Base&amp;) is not invoked automatically</span></span><br><span class="line">D &amp;D::<span class="keyword">operator</span>=(<span class="keyword">const</span> D &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Base::<span class="keyword">operator</span>=(rhs);   <span class="comment">// assigns the base part</span></span><br><span class="line">    <span class="comment">// assign the members in the derived class, as usual,</span></span><br><span class="line">    <span class="comment">// handling self-assignment and freeing existing resources as appropriate</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>派生类的析构函数只负责销毁派生类自己分配的资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Base::~Base invoked automatically</span></span><br><span class="line">    ~<span class="built_in">D</span>() &#123; <span class="comment">/* do what it takes to clean up derived members */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果构造函数或析构函数调用了某个虚函数，则应该执行与构造函数或析构函数所属类型相对应的虚函数版本。</p>
<h4 id="继承的构造函数（Inherited-Constructors）">继承的构造函数（Inherited Constructors）</h4>
<p>C++11新标准允许派生类重用（非常规方式继承）其直接基类定义的构造函数。继承方式是提供一条注明了直接基类名的<code>using</code>声明语句。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Disc_quote::Disc_quote;   <span class="comment">// inherit Disc_quote&#x27;s constructors</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通常情况下，<code>using</code>声明语句只是令某个名字在当前作用域内可见。而作用于构造函数时，<code>using</code>声明将令编译器产生代码。对于基类的每个构造函数，编译器都会生成一个与其形参列表完全相同的派生类构造函数。如果派生类含有自己的数据成员，则这些成员会被默认初始化。</p>
<p>构造函数的<code>using</code>声明不会改变该函数的访问级别，不能指定<code>explicit</code>或<code>constexpr</code>属性。</p>
<p>定义在派生类中的构造函数会替换继承而来的具有相同形参列表的构造函数。</p>
<p>派生类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器会为其合成它们。</p>
<p>当一个基类构造函数含有默认实参时，这些默认值不会被继承。相反，派生类会获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认值的形参。</p>
<h3 id="容器与继承（Containers-and-Inheritance）">容器与继承（Containers and Inheritance）</h3>
<p>因为容器中不能保存不同类型的元素，所以不能把具有继承关系的多种类型的对象直接存储在容器中。</p>
<p>容器不能和存在继承关系的类型兼容。</p>
<p>如果想在容器中存储具有继承关系的对象，则应该存放基类的指针。</p>
<hr>
<h2 id="第16章-模板和泛型编程（简）">第16章 模板和泛型编程（简）</h2>
<ul>
<li>面向对象编程和泛型编程都能处理在编写程序时不知道类型的情况。
<ul>
<li>OOP能处理类型在程序运行之前都未知的情况；</li>
<li>泛型编程中，在编译时就可以获知类型。</li>
</ul>
</li>
</ul>
<h3 id="定义模板">定义模板</h3>
<ul>
<li><strong>模板</strong>：模板是泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。</li>
</ul>
<h4 id="函数模板">函数模板</h4>
<ul>
<li><code>template &lt;typename T&gt; int compare(const T &amp;v1, const T &amp;v2)&#123;&#125;</code></li>
<li>模板定义以关键字 <code>template</code>开始，后接<strong>模板形参表</strong>，模板形参表是用<strong>尖括号</strong><code>&lt;&gt;</code>括住的一个或多个<strong>模板形参</strong>的列表，用逗号分隔，<strong>不能为空</strong>。</li>
<li>使用模板时，我们显式或隐式地指定模板实参，将其绑定到模板参数上。</li>
<li>模板类型参数：类型参数前必须使用关键字<code>class</code>或者<code>typename</code>，这两个关键字含义相同，可以互换使用。旧的程序只能使用<code>class</code>。</li>
<li>非类型模板参数：表示一个值而非一个类型。实参必须是常量表达式。<code>template &lt;class T, size_t N&gt; void array_init(T (&amp;parm)[N])&#123;&#125;</code></li>
<li>内联函数模板： <code>template &lt;typename T&gt; inline T min(const T&amp;, const T&amp;);</code></li>
<li>模板程序应该尽量减少对实参类型的要求。</li>
<li>函数模板和类模板成员函数的定义通常放在头文件中。</li>
</ul>
<h4 id="类模板">类模板</h4>
<ul>
<li>类模板用于生成类的蓝图。</li>
<li>不同于函数模板，编译器不能推断模板参数类型。</li>
<li><strong>定义类模板</strong>：
<ul>
<li><code>template &lt;class Type&gt; class Queue &#123;&#125;;</code></li>
</ul>
</li>
<li>实例化类模板：提供显式模板实参列表，来实例化出特定的类。</li>
<li>一个类模板中所有的实例都形成一个独立的类。</li>
<li><strong>模板形参作用域</strong>：模板形参的名字可以在声明为模板形参之后直到模板声明或定义的末尾处使用。</li>
<li>类模板的成员函数：
<ul>
<li><code>template &lt;typename T&gt; ret-type Blob::member-name(parm-list)</code></li>
</ul>
</li>
<li>默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。</li>
<li>新标准允许模板将自己的类型参数成为友元。<code>template &lt;typename T&gt; class Bar&#123;friend T;&#125;;</code>。</li>
<li>模板类型别名：因为模板不是一个类型，因此无法定义一个<code>typedef</code>引用一个模板，但是新标准允许我们为类模板定义一个类型别名：<code>template&lt;typename T&gt; using twin = pair&lt;T, T&gt;;</code></li>
</ul>
<h4 id="模板参数">模板参数</h4>
<ul>
<li>模板参数与作用域：一个模板参数名的可用范围是在声明之后，至模板声明或定义结束前。</li>
<li>一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置。</li>
<li>当我们希望通知编译器一个名字表示类型时，必须使用关键字<code>typename</code>，而不能使用<code>class</code>。</li>
<li>默认模板实参：<code>template &lt;class T = int&gt; class Numbers&#123;&#125;</code></li>
</ul>
<h4 id="成员模板">成员模板</h4>
<ul>
<li>成员模板（member template）：本身是模板的函数成员。
<ul>
<li>普通（非模板）类的成员模板。</li>
<li>类模板的成员模板。</li>
</ul>
</li>
</ul>
<h4 id="控制实例化">控制实例化</h4>
<ul>
<li>动机：在多个文件中实例化相同模板的额外开销可能非常严重。</li>
<li>显式实例化：
<ul>
<li><code>extern template declaration;  // 实例化声明</code></li>
<li><code>template declaration;  // 实例化定义</code></li>
</ul>
</li>
</ul>
<h4 id="效率与灵活性">效率与灵活性</h4>
<h3 id="模板实参推断">模板实参推断</h3>
<ul>
<li>对函数模板，编译器利用调用中的函数实参来确定其模板参数，这个过程叫<strong>模板实参推断</strong>。</li>
</ul>
<h4 id="类型转换与模板类型参数">类型转换与模板类型参数</h4>
<ul>
<li>能够自动转换类型的只有：
<ul>
<li>和其他函数一样，顶层<code>const</code>会被忽略。</li>
<li>数组实参或函数实参转换为指针。</li>
</ul>
</li>
</ul>
<h4 id="函数模板显式实参">函数模板显式实参</h4>
<ul>
<li>某些情况下，编译器无法推断出模板实参的类型。</li>
<li>定义：<code>template &lt;typename T1, typename T2, typename T3&gt; T1 sum(T2, T3);</code></li>
<li>使用函数显式实参调用：<code>auto val3 = sum&lt;long long&gt;(i, lng); // T1是显式指定，T2和T3都是从函数实参类型推断而来</code></li>
<li><strong>注意</strong>：正常类型转换可以应用于显式指定的实参。</li>
</ul>
<h4 id="尾置返回类型与类型转换">尾置返回类型与类型转换</h4>
<ul>
<li>使用场景：并不清楚返回结果的准确类型，但知道所需类型是和参数相关的。</li>
<li><code>template &lt;typename It&gt; auto fcn(It beg, It end) -&gt; decltype(*beg)</code></li>
<li>尾置返回允许我们在参数列表之后声明返回类型。</li>
</ul>
<p>标准库的<strong>类型转换</strong>模板：</p>
<ul>
<li>定义在头文件<code>type_traits</code>中。</li>
</ul>
<table>
<thead>
<tr>
<th>对<code>Mod&lt;T&gt;</code>，其中<code>Mod</code>是：</th>
<th>若<code>T</code>是：</th>
<th>则<code>Mod&lt;T&gt;::type</code>是：</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>remove_reference</code></td>
<td><code>X&amp;</code>或<code>X&amp;&amp;</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>add_const</code></td>
<td><code>X&amp;</code>或<code>const X</code>或函数</td>
<td><code>T</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>const T</code></td>
</tr>
<tr>
<td><code>add_lvalue_reference</code></td>
<td><code>X&amp;</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td></td>
<td><code>X&amp;&amp;</code></td>
<td><code>X&amp;</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T&amp;</code></td>
</tr>
<tr>
<td><code>add_rvalue_reference</code></td>
<td><code>X&amp;</code>或<code>X&amp;&amp;</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T&amp;&amp;</code></td>
</tr>
<tr>
<td><code>remove_pointer</code></td>
<td><code>X*</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>add_pointer</code></td>
<td><code>X&amp;</code>或<code>X&amp;&amp;</code></td>
<td><code>X*</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T*</code></td>
</tr>
<tr>
<td><code>make_signed</code></td>
<td><code>unsigned X</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>make_unsigned</code></td>
<td>带符号类型</td>
<td><code>unsigned X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>remove_extent</code></td>
<td><code>X[n]</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>remove_all_extents</code></td>
<td><code>X[n1][n2]...</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<h4 id="函数指针和实参推断">函数指针和实参推断</h4>
<ul>
<li>当使用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。</li>
</ul>
<h4 id="模板实参推断和引用">模板实参推断和引用</h4>
<ul>
<li>从左值引用函数推断类型：若形如<code>T&amp;</code>，则只能传递给它一个左值。但如果是<code>const T&amp;</code>，则可以接受一个右值。</li>
<li>从右值引用函数推断类型：若形如<code>T&amp;&amp;</code>，则只能传递给它一个右值。</li>
<li>引用折叠和右值引用参数：
<ul>
<li>规则1：当我们将一个左值传递给函数的右值引用参数，且右值引用指向模板类型参数时（如<code>T&amp;&amp;</code>），编译器会推断模板类型参数为实参的左值引用类型。</li>
<li>规则2：如果我们间接创造一个引用的引用，则这些引用形成了<strong>折叠</strong>。折叠引用只能应用在间接创造的引用的引用，如类型别名或模板参数。对于一个给定类型<code>X</code>：
<ul>
<li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>和<code>X&amp;&amp; &amp;</code>都折叠成类型<code>X&amp;</code>。</li>
<li>类型<code>X&amp;&amp; &amp;&amp;</code>折叠成<code>X&amp;&amp;</code>。</li>
</ul>
</li>
<li>上面两个例外规则导致两个重要结果：
<ul>
<li>1.如果一个函数参数是一个指向模板类型参数的右值引用（如<code>T&amp;&amp;</code>），则它可以被绑定到一个左值上；</li>
<li>2.如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个左值引用参数（<code>T&amp;</code>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="理解std-move">理解std::move</h4>
<ul>
<li>标准库<code>move</code>函数是使用右值引用的模板的一个很好的例子。</li>
<li>从一个左值<code>static_cast</code>到一个右值引用是允许的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="转发">转发</h4>
<ul>
<li>使用一个名为<code>forward</code>的新标准库设施来传递参数，它能够保持原始实参的类型。</li>
<li>定义在头文件<code>utility</code>中。</li>
<li>必须通过显式模板实参来调用。</li>
<li><code>forward</code>返回显式实参类型的右值引用。即，<code>forward&lt;T&gt;</code>的返回类型是<code>T&amp;&amp;</code>。</li>
</ul>
<h3 id="重载与模板">重载与模板</h3>
<ul>
<li>多个可行模板：当有多个重载模板对一个调用提供同样好的匹配时，会选择最特例化的版本。</li>
<li>非模板和模板重载：对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本。</li>
</ul>
<h3 id="可变参数模板">可变参数模板</h3>
<p><strong>可变参数模板</strong>就是一个接受可变数目参数的模板函数或模板类。</p>
<ul>
<li>可变数目的参数被称为参数包。
<ul>
<li>模板参数包：标识另个或多个模板参数。</li>
<li>函数参数包：标识另个或者多个函数参数。</li>
</ul>
</li>
<li>用一个省略号来指出一个模板参数或函数参数，表示一个包。</li>
<li><code>template &lt;typename T, typename... Args&gt;</code>，<code>Args</code>第一个模板参数包。</li>
<li><code>void foo(const T &amp;t, const Args&amp; ... rest);</code>，<code>rest</code>是一个函数参数包。</li>
<li><code>sizeof...</code>运算符，返回参数的数目。</li>
</ul>
<h4 id="编写可变参数函数模板">编写可变参数函数模板</h4>
<ul>
<li>可变参数函数通常是递归的：第一步调用处理包中的第一个实参，然后用剩余实参调用自身。</li>
</ul>
<h4 id="包扩展">包扩展</h4>
<ul>
<li>对于一个参数包，除了获取它的大小，唯一能做的事情就是<strong>扩展</strong>（expand）。</li>
<li>扩展一个包时，还要提供用于每个扩展元素的<strong>模式</strong>（pattern）。</li>
</ul>
<h4 id="转发参数包">转发参数包</h4>
<ul>
<li>新标准下可以组合使用可变参数模板和<code>forward</code>机制，实现将实参不变地传递给其他函数。</li>
</ul>
<h3 id="模板特例化（Specializations）">模板特例化（Specializations）</h3>
<ul>
<li>定义函数模板特例化：关键字<code>template</code>后面跟一个空尖括号对（<code>&lt;&gt;</code>）。</li>
<li>特例化的本质是实例化一个模板，而不是重载它。特例化不影响函数匹配。</li>
<li>模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是特例化版本。</li>
<li>我们可以部分特例化类模板，但不能部分特例化函数模板。</li>
</ul>
<hr>
<h2 id="第16章-模板与泛型编程">第16章 模板与泛型编程</h2>
<h3 id="定义模板（Defining-a-Template）">定义模板（Defining a Template）</h3>
<h4 id="函数模板（Function-Templates）">函数模板（Function Templates）</h4>
<p>函数模板可以用来生成针对特定类型的函数版本。</p>
<p>模板定义以关键字<code>template</code>开始，后跟一个模板参数列表（template parameter list）。模板参数列表以尖括号<code>&lt;&gt;</code>包围，内含用逗号分隔的一个或多个模板参数（template parameter）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义模板时，模板参数列表不能为空。</p>
<p>模板参数表示在类或函数定义中用到的类型或值。当使用模板时，需要显式或隐式地指定模板实参（template argument），并将其绑定到模板参数上。</p>
<p>使用函数模板时，编译器用推断出的模板参数来实例化（instantiate）一个特定版本的函数，这些生成的函数通常被称为模板的实例（instantiation）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instantiates int compare(const int&amp;, const int&amp;)</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">compare</span>(<span class="number">1</span>, <span class="number">0</span>) &lt;&lt; endl;    <span class="comment">// T is int</span></span><br><span class="line"><span class="comment">// instantiates int compare(const vector&lt;int&gt;&amp;, const vector&lt;int&gt;&amp;)</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, vec2&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">compare</span>(vec1, vec2) &lt;&lt; endl;    <span class="comment">// T is vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure>
<p>模板类型参数（type parameter）可以用来指定函数的返回类型或参数类型，以及在函数体内用于变量声明和类型转换。类型参数前必须使用关键字<code>class</code>或<code>typename</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok: same type used for the return type and parameter</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = *p; <span class="comment">// tmp will have the type to which p points</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: must precede U with either typename or class</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, U&gt; <span class="function">T <span class="title">calc</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> U&amp;)</span></span>;</span><br><span class="line"><span class="comment">// ok: no distinction between typename and class in a template parameter list</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span> <span class="built_in">calc</span> (<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> U&amp;);</span><br></pre></td></tr></table></figure>
<p>建议使用<code>typename</code>而不是<code>class</code>来指定模板类型参数，这样更加直观。</p>
<p>模板非类型参数（nontype parameter）需要用特定的类型名来指定，表示一个值而非一个类型。非类型参数可以是整型、指向对象或函数类型的指针或左值引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[M])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[<span class="number">3</span>], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[<span class="number">4</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>绑定到整型非类型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期，不能用普通局部变量或动态对象作为指针或引用非类型参数的实参。</p>
<p>函数模板也可以声明为<code>inline</code>或<code>constexpr</code>的，说明符放在模板参数列表之后，返回类型之前。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok: inline specifier follows the template parameter list</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// error: incorrect placement of the inline specifier</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>模板程序应该尽量减少对实参类型的要求。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expected comparison</span></span><br><span class="line"><span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (v1 &gt; v2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// version of compare that will be correct even if used on pointers</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (less&lt;T&gt;()(v1, v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (less&lt;T&gt;()(v2, v1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有当模板的一个特定版本被实例化时，编译器才会生成代码。此时编译器需要掌握生成代码所需的信息，因此函数模板和类模板成员函数的定义通常放在头文件中。</p>
<p>使用模板时，所有不依赖于模板参数的名字都必须是可见的，这是由模板的设计者来保证的。模板设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。</p>
<p>调用者负责保证传递给模板的实参能正确支持模板所要求的操作。</p>
<h4 id="类模板（Class-Templates）">类模板（Class Templates）</h4>
<p>使用一个类模板时，必须提供显式模板实参（explicit template argument）列表，编译器使用这些模板实参来实例化出特定的类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Blob</span>();</span><br><span class="line">    <span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(t); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T &amp;&amp;t)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t)); &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia;   <span class="comment">// empty Blob&lt;int&gt;</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia2 = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;    <span class="comment">// Blob&lt;int&gt; with five elements</span></span><br><span class="line"><span class="comment">// these definitions instantiate two distinct Blob types</span></span><br><span class="line">Blob&lt;string&gt; names;     <span class="comment">// Blob that holds strings</span></span><br><span class="line">Blob&lt;<span class="keyword">double</span>&gt; prices;    <span class="comment">// different element type</span></span><br></pre></td></tr></table></figure>
<p>一个类模板的每个实例都形成一个独立的类，相互之间没有关联。</p>
<p>如果一个类模板中的代码使用了另一个模板，通常不会将一个实际类型（或值）的名字用作其模板实参，而是将模板自己的参数用作被使用模板的实参。</p>
<p>类模板的成员函数具有和类模板相同的模板参数，因此定义在类模板外的成员函数必须以关键字<code>template</code>开始，后跟类模板参数列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ret-type Blob&lt;T&gt;::member-<span class="built_in">name</span>(parm-list)</span><br></pre></td></tr></table></figure>
<p>默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化。</p>
<p>在类模板自己的作用域内，可以直接使用模板名而不用提供模板实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 类模板作用域内不需要写成BlobPtr&lt;T&gt;形式</span></span><br><span class="line">    BlobPtr&amp; <span class="keyword">operator</span>++();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义时需要提供模板实参</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt;&amp; BlobPtr&lt;T&gt;::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 进入类模板作用域</span></span><br><span class="line">    BlobPtr Ret = *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个类包含一个友元声明时，类与友元各自是否是模板并无关联。如果一个类模板包含一个非模板友元，则友元可以访问所有类模板实例。如果友元自身是模板，则类可以给所有友元模板实例授予访问权限，也可以只授权给特定实例。</p>
<ul>
<li>
<p>一对一友元关系</p>
<p>为了引用模板的一个特定实例，必须首先声明模板自身。模板声明包括模板参数列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forward declarations needed for friend declarations in Blob</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span>    <span class="comment">// needed for parameters in operator==</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// each instantiation of Blob grants access to the version of</span></span><br><span class="line">    <span class="comment">// BlobPtr and the equality operator instantiated with the same type</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>&lt;</span>T&gt;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==&lt;T&gt;(<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通用和特定的模板友元关系</p>
<p>为了让模板的所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forward declaration necessary to befriend a specific instantiation of a template</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span> <span class="comment">// C is an ordinary, nontemplate class</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>C&gt;;    <span class="comment">// Pal instantiated with class C is a friend to C</span></span><br><span class="line">    <span class="comment">// all instances of Pal2 are friends to C;</span></span><br><span class="line">    <span class="comment">// no forward declaration required when we befriend all instantiations</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span></span></span><br><span class="line"><span class="class">&#123;</span> <span class="comment">// C2 is itself a class template</span></span><br><span class="line">    <span class="comment">// each instantiation of C2 has the same instance of Pal as a friend</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>T&gt;;    <span class="comment">// a template declaration for Pal must be in scope</span></span><br><span class="line">    <span class="comment">// all instances of Pal2 are friends of each instance of C2, prior declaration needed</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">    <span class="comment">// Pal3 is a nontemplate class that is a friend of every instance of C2</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal3</span>;</span>      <span class="comment">// prior declaration for Pal3 not needed</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>C++11中，类模板可以将模板类型参数声明为友元。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> Type;   <span class="comment">// grants access to the type used to instantiate Bar</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>C++11允许使用<code>using</code>为类模板定义类型别名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;string&gt; authors;   <span class="comment">// authors is a pair&lt;string, string&gt;</span></span><br></pre></td></tr></table></figure>
<p>类模板可以声明<code>static</code>成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::<span class="keyword">size_t</span> <span class="title">count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ctr; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> std::<span class="keyword">size_t</span> ctr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// instantiates static members Foo&lt;string&gt;::ctr and Foo&lt;string&gt;::count</span></span><br><span class="line">Foo&lt;string&gt; fs;</span><br><span class="line"><span class="comment">// all three objects share the same Foo&lt;int&gt;::ctr and Foo&lt;int&gt;::count members</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi, fi2, fi3;</span><br></pre></td></tr></table></figure>
<p>类模板的每个实例都有一个独有的<code>static</code>对象，而每个<code>static</code>成员必须有且只有一个定义。因此与定义模板的成员函数类似，<code>static</code>成员也应该定义成模板。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Foo&lt;T&gt;::ctr = <span class="number">0</span>;    <span class="comment">// define and initialize ctr</span></span><br></pre></td></tr></table></figure>
<h4 id="模板参数（Template-Parameters）">模板参数（Template Parameters）</h4>
<p>模板参数遵循普通的作用域规则。与其他任何名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是在模板内不能重用模板参数名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> A;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A a, B b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A tmp = a;   <span class="comment">// tmp has same type as the template parameter A, not double</span></span><br><span class="line">    <span class="keyword">double</span> B;    <span class="comment">// error: redeclares template parameter B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于模板参数名不能重用，所以一个名字在一个特定模板参数列表中只能出现一次。</p>
<p>与函数参数一样，声明中模板参数的名字不必与定义中的相同。</p>
<p>一个特定文件所需要的所有模板声明通常一起放置在文件开始位置，出现在任何使用这些模板的代码之前。</p>
<p>模板中的代码使用作用域运算符<code>::</code>时，编译器无法确定其访问的名字是类型还是<code>static</code>成员。</p>
<p>默认情况下，C++假定模板中通过作用域运算符访问的名字是<code>static</code>成员。因此，如果需要使用一个模板类型参数的类型成员，就必须使用关键字<code>typename</code>显式地告知编译器该名字是一个类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span><span class="params">(<span class="keyword">const</span> T&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!c.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> c.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typename</span> T::<span class="built_in">value_type</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++11允许为函数和类模板提供默认实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare has a default template argument, less&lt;T&gt;</span></span><br><span class="line"><span class="comment">// and a default function argument, F()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">compare</span>(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2, F f = <span class="built_in">F</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(v1, v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(v2, v1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个类模板为其所有模板参数都提供了默认实参，在使用这些默认实参时，必须在模板名后面跟一个空尖括号对<code>&lt;&gt;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> =</span> <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Numbers</span></span></span><br><span class="line"><span class="class">&#123;</span> <span class="comment">// by default T is int</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Numbers</span>(T v = <span class="number">0</span>): <span class="built_in">val</span>(v) &#123; &#125;</span><br><span class="line">    <span class="comment">// various operations on numbers</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; lots_of_precision;</span><br><span class="line">Numbers&lt;&gt; average_precision;    <span class="comment">// empty &lt;&gt; says we want the default type</span></span><br></pre></td></tr></table></figure>
<h4 id="成员模板（Member-Templates）">成员模板（Member Templates）</h4>
<p>一个类（无论是普通类还是模板类）可以包含本身是模板的成员函数，这种成员被称为成员模板。成员模板不能是虚函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugDelete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DebugDelete</span>(std::ostream &amp;s = std::cerr): <span class="built_in">os</span>(s) &#123; &#125;</span><br><span class="line">    <span class="comment">// as with any function template, the type of T is deduced by the compiler</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *p)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        os &lt;&lt; <span class="string">&quot;deleting unique_ptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::ostream &amp;os;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">    <span class="built_in">Blob</span>(It b, It e);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;   <span class="comment">// type parameter for the class</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;  <span class="comment">// type parameter for the constructor</span></span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(It b, It e):</span><br><span class="line">    <span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b, e))</span><br><span class="line">    &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>为了实例化一个类模板的成员模板，必须同时提供类和函数模板的实参。</p>
<h4 id="控制实例化（Controlling-Instantiations）">控制实例化（Controlling Instantiations）</h4>
<p>因为模板在使用时才会进行实例化，所以相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中都会有该模板的一个实例。</p>
<p>在大型程序中，多个文件实例化相同模板的额外开销可能非常严重。C++11允许通过显式实例化（explicit instantiation）来避免这种开销。</p>
<p>显式实例化的形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;    <span class="comment">// instantiation declaration</span></span><br><span class="line"><span class="keyword">template</span> declaration;           <span class="comment">// instantiation definition</span></span><br></pre></td></tr></table></figure>
<p><code>declaration</code>是一个类或函数声明，其中所有模板参数已被替换为模板实参。当编译器遇到<code>extern</code>模板声明时，它不会在本文件中生成实例化代码。对于一个给定的实例化版本，可能有多个<code>extern</code>声明，但必须只有一个定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// templateBuild.cc</span></span><br><span class="line"><span class="comment">// instantiation file must provide a (nonextern) definition for every</span></span><br><span class="line"><span class="comment">// type and function that other files declare as extern</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;    <span class="comment">// instantiates all members of the class template</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Application.cc</span></span><br><span class="line"><span class="comment">// these template types must be instantiated elsewhere in the program</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;</span><br><span class="line">Blob&lt;string&gt; sa1, sa2;    <span class="comment">// instantiation will appear elsewhere</span></span><br><span class="line"><span class="comment">// Blob&lt;int&gt; and its initializer_list constructor instantiated in this file</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; a1 = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(a1)</span></span>;    <span class="comment">// copy constructor instantiated in this file</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">compare</span>(a1[<span class="number">0</span>], a2[<span class="number">0</span>]);    <span class="comment">// instantiation will appear elsewhere</span></span><br></pre></td></tr></table></figure>
<p>当编译器遇到类模板的实例化定义时，它不清楚程序会使用哪些成员函数。和处理类模板的普通实例化不同，编译器会实例化该模板的所有成员，包括内联的成员函数。因此，用来显式实例化类模板的类型必须能用于模板的所有成员。</p>
<h4 id="效率与灵活性（Efficiency-and-Flexibility）">效率与灵活性（Efficiency and Flexibility）</h4>
<p><code>unique_ptr</code>在编译时绑定删除器，避免了间接调用删除器的运行时开销。<code>shared_ptr</code>在运行时绑定删除器，使用户重载删除器的操作更加简便。</p>
<h3 id="模板实参推断（Template-Argument-Deduction）">模板实参推断（Template Argument Deduction）</h3>
<p>对于函数模板，编译器通过调用的函数实参来确定其模板参数。这个过程被称作模板实参推断。</p>
<h4 id="类型转换与模板类型参数（Conversions-and-Template-Type-Parameters）">类型转换与模板类型参数（Conversions and Template Type Parameters）</h4>
<p>与非模板函数一样，调用函数模板时传递的实参被用来初始化函数的形参。如果一个函数形参的类型使用了模板类型参数，则会采用特殊的初始化规则，只有有限的几种类型转换会自动地应用于这些实参。编译器通常会生成新的模板实例而不是对实参进行类型转换。</p>
<p>有3种类型转换可以在调用中应用于函数模板：</p>
<ul>
<li>顶层<code>const</code>会被忽略。</li>
<li>可以将一个非<code>const</code>对象的引用或指针传递给一个<code>const</code>引用或指针形参。</li>
<li>如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。数组实参可以转换为指向其首元素的指针。函数实参可以转换为该函数类型的指针。</li>
</ul>
<p>其他的类型转换，如算术转换、派生类向基类的转换以及用户定义的转换，都不能应用于函数模板。</p>
<p>一个模板类型参数可以作为多个函数形参的类型。由于允许的类型转换有限，因此传递给这些形参的实参必须具有相同的类型，否则调用失败。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line"><span class="built_in">compare</span>(lng, <span class="number">1024</span>);   <span class="comment">// error: cannot instantiate compare(long, int)</span></span><br></pre></td></tr></table></figure>
<p>如果想增强函数的兼容性，可以使用两个类型参数定义函数模板。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// argument types can differ but must be compatible</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flexibleCompare</span><span class="params">(<span class="keyword">const</span> A&amp; v1, <span class="keyword">const</span> B&amp; v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line"><span class="built_in">flexibleCompare</span>(lng, <span class="number">1024</span>);   <span class="comment">// ok: calls flexibleCompare(long, int)</span></span><br></pre></td></tr></table></figure>
<p>函数模板中使用普通类型定义的参数可以进行正常的类型转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cout, <span class="number">42</span>);   <span class="comment">// instantiates print(ostream&amp;, int)</span></span><br><span class="line"><span class="function">ofstream <span class="title">f</span><span class="params">(<span class="string">&quot;output&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">print</span>(f, <span class="number">10</span>);      <span class="comment">// uses print(ostream&amp;, int); converts f to ostream&amp;</span></span><br></pre></td></tr></table></figure>
<h4 id="函数模板显式实参（Function-Template-Explicit-Arguments）">函数模板显式实参（Function-Template Explicit Arguments）</h4>
<p>某些情况下，编译器无法推断出模板实参的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T1 cannot be deduced: it doesn&#x27;t appear in the function parameter list</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br></pre></td></tr></table></figure>
<p>显式模板实参（explicit template argument）可以让用户自己控制模板的实例化。提供显式模板实参的方式与定义类模板实例的方式相同。显式模板实参在尖括号<code>&lt;&gt;</code>中指定，位于函数名之后，实参列表之前。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T1 is explicitly specified; T2 and T3 are inferred from the argument types</span></span><br><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng);   <span class="comment">// long long sum(int, long)</span></span><br></pre></td></tr></table></figure>
<p>显式模板实参按照从左到右的顺序与对应的模板参数匹配，只有尾部参数的显式模板实参才可以忽略，而且前提是它们可以从函数参数推断出来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poor design: users must explicitly specify all three template parameters</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T3 <span class="title">alternative_sum</span><span class="params">(T2, T1)</span></span>;</span><br><span class="line"><span class="comment">// error: can&#x27;t infer initial template parameters</span></span><br><span class="line"><span class="keyword">auto</span> val3 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng);</span><br><span class="line"><span class="comment">// ok: all three parameters are explicitly specified</span></span><br><span class="line"><span class="keyword">auto</span> val2 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>, <span class="keyword">long</span>&gt;(i, lng);</span><br></pre></td></tr></table></figure>
<p>对于模板类型参数已经显式指定了的函数实参，可以进行正常的类型转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line"><span class="built_in">compare</span>(lng, <span class="number">1024</span>);         <span class="comment">// error: template parameters don&#x27;t match</span></span><br><span class="line">compare&lt;<span class="keyword">long</span>&gt;(lng, <span class="number">1024</span>);   <span class="comment">// ok: instantiates compare(long, long)</span></span><br><span class="line">compare&lt;<span class="keyword">int</span>&gt;(lng, <span class="number">1024</span>);    <span class="comment">// ok: instantiates compare(int, int)</span></span><br></pre></td></tr></table></figure>
<h4 id="尾置返回类型与类型转换（Trailing-Return-Types-and-Type-Transformation）">尾置返回类型与类型转换（Trailing Return Types and Type Transformation）</h4>
<p>由于尾置返回出现在函数列表之后，因此它可以使用函数参数来声明返回类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a trailing return lets us declare the return type after the parameter list is seen</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn</span><span class="params">(It beg, It end)</span> -&gt; <span class="title">decltype</span><span class="params">(*beg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// process the range</span></span><br><span class="line">    <span class="keyword">return</span> *beg;   <span class="comment">// return a reference to an element from the range</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准库在头文件<code>type_traits</code>中定义了类型转换模板，这些模板常用于模板元程序设计。其中每个模板都有一个名为<code>type</code>的公有类型成员，表示一个类型。此类型与模板自身的模板类型参数相关。如果不可能（或不必要）转换模板参数，则<code>type</code>成员就是模板参数类型本身。</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031706325.png" alt="16-1" style="zoom:80%;" />
<p>使用<code>remove_reference</code>可以获得引用对象的元素类型，如果用一个引用类型实例化<code>remove_reference</code>，则<code>type</code>表示被引用的类型。因为<code>type</code>是一个类的类型成员，所以在模板中必须使用关键字<code>typename</code>来告知编译器其表示一个类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// must use typename to use a type member of a template parameter</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span><span class="params">(It beg, It end)</span> -&gt; <span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// process the range</span></span><br><span class="line">    <span class="keyword">return</span> *beg;  <span class="comment">// return a copy of an element from the range</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数指针和实参推断（Function-Pointers-and-Argument-Deduction）">函数指针和实参推断（Function Pointers and Argument Deduction）</h4>
<p>使用函数模板初始化函数指针或为函数指针赋值时，编译器用指针的类型来推断模板实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf1 points to the instantiation int compare(const int&amp;, const int&amp;)</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*pf1)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = compare;</span><br></pre></td></tr></table></figure>
<p>如果编译器不能从函数指针类型确定模板实参，则会产生错误。使用显式模板实参可以消除调用歧义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// overloaded versions of func; each takes a different function pointer type</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)(<span class="keyword">const</span> string&amp;, <span class="keyword">const</span> string&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;))</span></span>;</span><br><span class="line"><span class="built_in">func</span>(compare);     <span class="comment">// error: which instantiation of compare?</span></span><br><span class="line"><span class="comment">// ok: explicitly specify which version of compare to instantiate</span></span><br><span class="line"><span class="built_in">func</span>(compare&lt;<span class="keyword">int</span>&gt;);    <span class="comment">// passing compare(const int&amp;, const int&amp;)</span></span><br></pre></td></tr></table></figure>
<h4 id="模板实参推断和引用（Template-Argument-Deduction-and-References）">模板实参推断和引用（Template Argument Deduction and References）</h4>
<p>当一个函数参数是模板类型参数的普通（左值）引用（形如<code>T&amp;</code>）时，只能传递给它一个左值（如一个变量或一个返回引用类型的表达式）。<code>T</code>被推断为实参所引用的类型，如果实参是<code>const</code>的，则<code>T</code>也为<code>const</code>类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T&amp;)</span></span>;    <span class="comment">// argument must be an lvalue</span></span><br><span class="line"><span class="comment">// calls to f1 use the referred-to type of the argument as the template parameter type</span></span><br><span class="line"><span class="built_in">f1</span>(i);     <span class="comment">// i is an int; template parameter T is int</span></span><br><span class="line"><span class="built_in">f1</span>(ci);    <span class="comment">// ci is a const int; template parameter T is const int</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">5</span>);     <span class="comment">// error: argument to a &amp; parameter must be an lvalue</span></span><br></pre></td></tr></table></figure>
<p>当一个函数参数是模板类型参数的常量引用（形如<code>const T&amp;</code>）时，可以传递给它任何类型的实参。函数参数本身是<code>const</code>时，<code>T</code>的类型推断结果不会是<code>const</code>类型。<code>const</code>已经是函数参数类型的一部分了，因此不会再是模板参数类型的一部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;    <span class="comment">// can take an rvalue</span></span><br><span class="line"><span class="comment">// parameter in f2 is const &amp;; const in the argument is irrelevant</span></span><br><span class="line"><span class="comment">// in each of these three calls, f2&#x27;s function parameter is inferred as const int&amp;</span></span><br><span class="line"><span class="built_in">f2</span>(i);     <span class="comment">// i is an int; template parameter T is int</span></span><br><span class="line"><span class="built_in">f2</span>(ci);    <span class="comment">// ci is a const int, but template parameter T is int</span></span><br><span class="line"><span class="built_in">f2</span>(<span class="number">5</span>);     <span class="comment">// a const &amp; parameter can be bound to an rvalue; T is int</span></span><br></pre></td></tr></table></figure>
<p>当一个函数参数是模板类型参数的右值引用（形如<code>T&amp;&amp;</code>）时，如果传递给它一个右值，类型推断过程类似普通左值引用函数参数的推断过程，推断出的<code>T</code>类型是该右值实参的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line"><span class="built_in">f3</span>(<span class="number">42</span>);    <span class="comment">// argument is an rvalue of type int; template parameter T is int</span></span><br></pre></td></tr></table></figure>
<p>模板参数绑定的两个例外规则：</p>
<ul>
<li>
<p>如果将一个左值传递给函数的右值引用参数，且此右值引用指向模板类型参数时，编译器推断模板类型参数为实参的左值引用类型。</p>
</li>
<li>
<p>如果间接创建了一个引用的引用（通过类型别名或者模板类型参数间接定义），则这些引用会被“折叠”。右值引用的右值引用会被折叠为右值引用。其他情况下，引用都被折叠为普通左值引用。</p>
<table>
<thead>
<tr>
<th style="text-align:center">折叠前</th>
<th style="text-align:center">折叠后</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>T&amp; &amp;</code>、<code>T&amp; &amp;&amp;</code>、<code>T&amp;&amp; &amp;</code></td>
<td style="text-align:center"><code>T&amp;</code></td>
</tr>
<tr>
<td style="text-align:center"><code>T&amp;&amp; &amp;&amp;</code></td>
<td style="text-align:center"><code>T&amp;&amp;</code></td>
</tr>
</tbody>
</table>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f3</span>(i);    <span class="comment">// argument is an lvalue; template parameter T is int&amp;</span></span><br><span class="line"><span class="built_in">f3</span>(ci);   <span class="comment">// argument is an lvalue; template parameter T is const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// invalid code, for illustration purposes only</span></span><br><span class="line"><span class="keyword">void</span> f3&lt;<span class="keyword">int</span>&amp;&gt;(<span class="keyword">int</span>&amp; &amp;&amp;);    <span class="comment">// when T is int&amp;, function parameter is int&amp; &amp;&amp;</span></span><br><span class="line"><span class="keyword">void</span> f3&lt;<span class="keyword">int</span>&amp;&gt;(<span class="keyword">int</span>&amp;);       <span class="comment">// when T is int&amp;, function parameter collapses to int&amp;</span></span><br></pre></td></tr></table></figure>
<p>模板参数绑定的两个例外规则导致了两个结果：</p>
<ul>
<li>如果一个函数参数是指向模板类型参数的右值引用，则可以传递给它任意类型的实参。</li>
<li>如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用。</li>
</ul>
<p>当代码中涉及的类型可能是普通（非引用）类型，也可能是引用类型时，编写正确的代码就变得异常困难。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t = val;     <span class="comment">// copy or binding a reference?</span></span><br><span class="line">    t = <span class="built_in">fcn</span>(t);    <span class="comment">// does the assignment change only t or val and t?</span></span><br><span class="line">    <span class="keyword">if</span> (val == t) &#123; <span class="comment">/* ... */</span> &#125;    <span class="comment">// always true if T is a reference type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际编程中，模板的右值引用参数通常用于两种情况：模板转发其实参或者模板被重载。函数模板的常用重载形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp;)</span></span>;         <span class="comment">// binds to nonconst rvalues</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;    <span class="comment">// lvalues and const rvalues</span></span><br></pre></td></tr></table></figure>
<h4 id="理解std-move（Understanding-std-move）">理解std::move（Understanding std::move）</h4>
<p><code>std::move</code>的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::move</code>的工作过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hi!&quot;</span>)</span>, s2</span>;</span><br><span class="line">s2 = std::<span class="built_in">move</span>(<span class="built_in">string</span>(<span class="string">&quot;bye!&quot;</span>));     <span class="comment">// ok: moving from an rvalue</span></span><br><span class="line">s2 = std::<span class="built_in">move</span>(s1);     <span class="comment">// ok: but after the assigment s1 has indeterminate value</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>在<code>std::move(string(&quot;bye!&quot;))</code>中传递的是右值。</p>
<ul>
<li>推断出的<code>T</code>类型为<code>string</code>。</li>
<li><code>remove_reference</code>用<code>string</code>进行实例化。</li>
<li><code>remove_reference&lt;string&gt;</code>的<code>type</code>成员是<code>string</code>。</li>
<li><code>move</code>的返回类型是<code>string&amp;&amp;</code>。</li>
<li><code>move</code>的函数参数<code>t</code>的类型为<code>string&amp;&amp;</code>。</li>
</ul>
</li>
<li>
<p>在<code>std::move(s1)</code>中传递的是左值。</p>
<ul>
<li>推断出的<code>T</code>类型为<code>string&amp;</code>。</li>
<li><code>remove_reference</code>用<code>string&amp;</code>进行实例化。</li>
<li><code>remove_reference&lt;string&amp;&gt;</code>的<code>type</code>成员是<code>string</code>。</li>
<li><code>move</code>的返回类型是<code>string&amp;&amp;</code>。</li>
<li><code>move</code>的函数参数<code>t</code>的类型为<code>string&amp; &amp;&amp;</code>，会折叠成<code>string&amp;</code>。</li>
</ul>
</li>
</ul>
<p>可以使用<code>static_cast</code>显式地将一个左值转换为一个右值引用。</p>
<h4 id="转发（Forwarding）">转发（Forwarding）</h4>
<p>某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在这种情况下，需要保持被转发实参的所有性质，包括实参的<code>const</code>属性以及左值/右值属性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template that takes a callable and two parameters</span></span><br><span class="line"><span class="comment">// and calls the given callable with the parameters &#x27;&#x27;flipped&#x27;&#x27;</span></span><br><span class="line"><span class="comment">// flip1 is an incomplete implementation: top-level const and references are lost</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(F f, T1 t1, T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> &amp;v2)</span>   <span class="comment">// note v2 is a reference</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">42</span>, i);   <span class="comment">// f changes its argument i</span></span><br><span class="line"><span class="built_in">flip1</span>(f, j, <span class="number">42</span>);    <span class="comment">// f called through flip1 leaves j unchanged</span></span><br><span class="line">                    <span class="comment">// void flip1(void(*fcn)(int, int&amp;), int t1, int t2)</span></span><br></pre></td></tr></table></figure>
<p>上例中，<code>j</code>被传递给<code>flip1</code>的参数<code>t1</code>，该参数是一个普通（非引用）类型<code>int</code>，而非<code>int&amp;</code>，因此<code>flip1(f, j, 42)</code>调用会被实例化为<code>void flip1(void(*fcn)(int, int&amp;), int t1, int t2)</code>。<code>j</code>的值被拷贝至<code>t1</code>中，<code>f</code>中的引用参数被绑定至<code>t1</code>，而非<code>j</code>，因此<code>j</code>不会被修改。</p>
<p>将函数参数定义为指向模板类型参数的右值引用（形如<code>T&amp;&amp;</code>），通过引用折叠，可以保持翻转实参的左值/右值属性。并且引用参数（无论是左值还是右值）可以保持实参的<code>const</code>属性，因为在引用类型中的<code>const</code>是底层的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(t2, t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于修改后的版本，若调用<code>flip2(f, j, 42)</code>，会传递给参数<code>t1</code>一个左值<code>j</code>，但此时推断出的<code>T1</code>类型为<code>int&amp;</code>，<code>t1</code>的类型会被折叠为<code>int&amp;</code>，从而解决了<code>flip1</code>的错误。</p>
<p>但<code>flip2</code>只能用于接受左值引用的函数，不能用于接受右值引用的函数。函数参数与其他变量一样，都是左值表达式。所以即使是指向模板类型的右值引用参数也只能传递给接受左值引用的函数，不能传递给接受右值引用的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;&amp;i, <span class="keyword">int</span>&amp; j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: can&#x27;t initialize int&amp;&amp; from an lvalue</span></span><br><span class="line"><span class="built_in">flip2</span>(g, i, <span class="number">42</span>);  <span class="comment">// flip2 passes an lvalue to g&#x27;s rvalue reference parameter</span></span><br></pre></td></tr></table></figure>
<p>C++11在头文件<code>utility</code>中定义了<code>forward</code>。与<code>move</code>不同，<code>forward</code>必须通过显式模板实参调用，返回该显式实参类型的右值引用。即<code>forward&lt;T&gt;</code>返回类型<code>T&amp;&amp;</code>。</p>
<p>通常情况下，可以使用<code>forward</code>传递定义为指向模板类型参数的右值引用函数参数。通过其返回类型上的引用折叠，<code>forward</code>可以保持给定实参的左值/右值属性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="built_in">intermediary</span>(Type &amp;&amp;arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">finalFcn</span>(std::forward&lt;Type&gt;(arg));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果实参是一个右值，则<code>Type</code>是一个普通（非引用）类型，<code>forward&lt;Type&gt;</code>返回类型<code>Type&amp;&amp;</code>。</li>
<li>如果实参是一个左值，则通过引用折叠，<code>Type</code>也是一个左值引用类型，<code>forward&lt;Type&gt;</code>返回类型<code>Type&amp;&amp; &amp;</code>，对返回类型进行引用折叠，得到<code>Type&amp;</code>。</li>
</ul>
<p>使用<code>forward</code>编写完善的转发函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与<code>std::move</code>一样，对<code>std::forward</code>也不应该使用<code>using</code>声明。</p>
<h3 id="重载与模板（Overloading-and-Templates）">重载与模板（Overloading and Templates）</h3>
<p>函数模板可以被另一个模板或普通非模板函数重载。</p>
<p>如果重载涉及函数模板，则函数匹配规则会受到一些影响：</p>
<ul>
<li>对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例。</li>
<li>候选的函数模板都是可行的，因为模板实参推断会排除任何不可行的模板。</li>
<li>和往常一样，可行函数（模板与非模板）按照类型转换（如果需要的话）来排序。但是可以用于函数模板调用的类型转换非常有限。</li>
<li>和往常一样，如果恰有一个函数提供比其他任何函数都更好的匹配，则选择此函数。但是如果多个函数都提供相同级别的匹配，则：
<ul>
<li>如果同级别的函数中只有一个是非模板函数，则选择此函数。</li>
<li>如果同级别的函数中没有非模板函数，而有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板。</li>
<li>否则该调用有歧义。</li>
</ul>
</li>
</ul>
<p>通常，如果使用了一个没有声明的函数，代码将无法编译。但对于重载函数模板的函数而言，如果编译器可以从模板实例化出与调用匹配的版本，则缺少的声明就不再重要了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span><span class="params">(T *p)</span></span>;</span><br><span class="line"><span class="comment">// the following declaration must be in scope</span></span><br><span class="line"><span class="comment">// for the definition of debug_rep(char*) to do the right thing</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// if the declaration for the version that takes a const string&amp; is not in scope</span></span><br><span class="line">    <span class="comment">// the return will call debug_rep(const T&amp;) with T instantiated to string</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">debug_rep</span>(<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义任何函数之前，应该声明所有重载的函数版本。这样编译器就不会因为未遇到你希望调用的函数而实例化一个并非你所需要的版本。</p>
<h3 id="可变参数模板（Variadic-Templates）">可变参数模板（Variadic Templates）</h3>
<p>可变参数模板指可以接受可变数量参数的模板函数或模板类。可变数量的参数被称为参数包（parameter pack），分为两种：</p>
<ul>
<li>模板参数包（template parameter pack），表示零个或多个模板参数。</li>
<li>函数参数包（function parameter pack），表示零个或多个函数参数。</li>
</ul>
<p>用一个省略号<code>…</code>来指出模板参数或函数参数表示一个包。在一个模板参数列表中，<code>class…</code>或<code>typename…</code>指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数列表。在函数参数列表中，如果一个参数的类型是模板参数包，则此参数也是函数参数包。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Args is a template parameter pack; rest is a function parameter pack</span></span><br><span class="line"><span class="comment">// Args represents zero or more template type parameters</span></span><br><span class="line"><span class="comment">// rest represents zero or more function parameters</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp; ... rest)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于一个可变参数模板，编译器会推断模板参数类型和参数数量。</p>
<p>可以使用<code>sizeof…</code>运算符获取参数包中的元素数量。类似<code>sizeof</code>，<code>sizeof…</code>也返回一个常量表达式，而且不会对其实参求值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(Args ... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; endl;    <span class="comment">// number of type parameters</span></span><br><span class="line">    cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl;    <span class="comment">// number of function parameters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编写可变参数函数模板（Writing-a-Variadic-Function-Template）">编写可变参数函数模板（Writing a Variadic Function Template）</h4>
<p>可变参数函数通常是递归的，第一步调用参数包中的第一个实参，然后用剩余实参调用自身。为了终止递归，还需要定义一个非可变参数的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function to end the recursion and print the last element</span></span><br><span class="line"><span class="comment">// this function must be declared before the variadic version of print is defined</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; t;   <span class="comment">// no separator after the last element in the pack</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this version of print will be called for all but the last element in the pack</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span>;    <span class="comment">// print the first argument</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);   <span class="comment">// recursive call; print the other arguments</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">Call</th>
<th style="text-align:center">t</th>
<th style="text-align:center">rest…</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>print(cout, i, s, 42)</code></td>
<td style="text-align:center">i</td>
<td style="text-align:center">s, 42</td>
</tr>
<tr>
<td style="text-align:center"><code>print(cout, s, 42)</code></td>
<td style="text-align:center">s</td>
<td style="text-align:center">42</td>
</tr>
<tr>
<td style="text-align:center"><code>print(cout, 42)</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="包扩展（Pack-Expansion）">包扩展（Pack Expansion）</h4>
<p>对于一个参数包，除了获取其大小外，唯一能对它做的事情就是扩展。当扩展一个包时，需要提供用于每个扩展元素的模式（pattern）。扩展一个包就是将其分解为构成的元素，对每个元素应用模式，获得扩展后的列表。通过在模式右边添加一个省略号<code>…</code>来触发扩展操作。</p>
<p>包扩展工作过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;... rest)</span>   <span class="comment">// expand Args</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);   <span class="comment">// expand rest</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>第一个扩展操作扩展模板参数包，为<code>print</code>生成函数参数列表。编译器将模式<code>const Args&amp;</code>应用到模板参数包<code>Args</code>中的每个元素上。因此该模式的扩展结果是一个以逗号分隔的零个或多个类型的列表，每个类型都形如<code>const type&amp;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(cout, i, s, <span class="number">42</span>);   <span class="comment">// two parameters in the pack</span></span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> string&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>第二个扩展操作扩展函数参数包，模式是函数参数包的名字。扩展结果是一个由包中元素组成、以逗号分隔的列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(os, s, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>扩展操作中的模式会独立地应用于包中的每个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call debug_rep on each argument in the call to print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">errorMsg</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Args&amp;... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(an)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, <span class="built_in">debug_rep</span>(rest)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// passes the pack to debug_rep; print(os, debug_rep(a1, a2, ..., an))</span></span><br><span class="line"><span class="built_in">print</span>(os, <span class="built_in">debug_rep</span>(rest...));   <span class="comment">// error: no matching function to call</span></span><br></pre></td></tr></table></figure>
<h4 id="转发参数包（Forwarding-Parameter-Packs）">转发参数包（Forwarding Parameter Packs）</h4>
<p>在C++11中，可以组合使用可变参数模板和<code>forward</code>机制来编写函数，实现将其实参不变地传递给其他函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fun has zero or more parameters each of which is</span></span><br><span class="line"><span class="comment">// an rvalue reference to a template parameter type</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Args&amp;&amp;... args)</span>    <span class="comment">// expands Args as a list of rvalue references</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// the argument to work expands both Args and args</span></span><br><span class="line">    <span class="built_in">work</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板特例化（Template-Specializations）">模板特例化（Template Specializations）</h3>
<p>在某些情况下，通用模板的定义对特定类型是不合适的，可能编译失败或者操作不正确。如果不希望或不能使用模板版本时，可以定义类或函数模板的特例化版本。一个特例化版本就是模板的一个独立定义，其中的一个或多个模板参数被指定为特定类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first version; can compare any two types</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// second version to handle string literals</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N, <span class="keyword">size_t</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[M])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p1 = <span class="string">&quot;hi&quot;</span>, *p2 = <span class="string">&quot;mom&quot;</span>;</span><br><span class="line"><span class="built_in">compare</span>(p1, p2);        <span class="comment">// calls the first template</span></span><br><span class="line"><span class="built_in">compare</span>(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;mom&quot;</span>);   <span class="comment">// calls the template with two nontype parameters</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// special version of compare to handle pointers to character arrays</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p1, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特例化一个函数模板时，必须为模板中的每个模板参数都提供实参。为了指明我们正在实例化一个模板，应该在关键字<code>template</code>后面添加一个空尖括号对<code>&lt;&gt;</code>。</p>
<p>特例化版本的参数类型必须与一个先前声明的模板中对应的类型相匹配。</p>
<p>定义特例化函数版本本质上是接管编译器的工作，为模板的一个特殊实例提供了定义。特例化并非重载，因此不影响函数匹配。</p>
<p>将一个特殊版本的函数定义为特例化模板还是独立的非模板函数会影响到重载函数匹配。</p>
<p>模板特例化遵循普通作用域规则。为了特例化一个模板，原模板的声明必须在作用域中。而使用模板实例时，也必须先包含特例化版本的声明。</p>
<p>通常，模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明放在文件开头，后面是这些模板的特例化版本。</p>
<p>类模板也可以特例化。与函数模板不同，类模板的特例化不必为所有模板参数提供实参，可以只指定一部分模板参数。一个类模板的部分特例化（partial specialization）版本本身还是一个模板，用户使用时必须为那些未指定的模板参数提供实参。</p>
<p>只能部分特例化类模板，不能部分特例化函数模板。</p>
<p>由于类模板的部分特例化版本是一个模板，所以需要定义模板参数。对于每个未完全确定类型的模板参数，在特例化版本的模板参数列表中都有一项与之对应。在类名之后，需要为特例化的模板参数指定实参，这些实参位于模板名之后的尖括号中，与原始模板中的参数按位置相对应。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分特例化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;</span>T &amp;&gt;   <span class="comment">// 左值引用</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;</span>T &amp;&amp;&gt;  <span class="comment">// 右值引用</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类模板部分特例化版本的模板参数列表是原始模板参数列表的一个子集或特例化版本。</p>
<p>可以只特例化类模板的指定成员函数，而不用特例化整个模板。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="keyword">const</span> T &amp;t = <span class="built_in">T</span>()): <span class="built_in">mem</span>(t) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    T mem;</span><br><span class="line">    <span class="comment">// other members of Foo</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;      <span class="comment">// we&#x27;re specializing a template</span></span><br><span class="line"><span class="keyword">void</span> Foo&lt;<span class="keyword">int</span>&gt;::<span class="built_in">Bar</span>()    <span class="comment">// we&#x27;re specializing the Bar member of Foo&lt;int&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do whatever specialized processing that applies to ints</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo&lt;string&gt; fs;     <span class="comment">// instantiates Foo&lt;string&gt;::Foo()</span></span><br><span class="line">fs.<span class="built_in">Bar</span>();    <span class="comment">// instantiates Foo&lt;string&gt;::Bar()</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;    <span class="comment">// instantiates Foo&lt;int&gt;::Foo()</span></span><br><span class="line">fi.<span class="built_in">Bar</span>();    <span class="comment">// uses our specialization of Foo&lt;int&gt;::Bar()</span></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">SEUGarfield</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.zgzheng.top/posts/45995/">https://blog.zgzheng.top/posts/45995/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.zgzheng.top" target="_blank">笑枕晚风の小站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031713662.jpg" data-sites="facebook,twitter,wechat,weibo,qq,qzone,douban"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/38403/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202111041949979.gif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数字三角形模型 | 动态规划</div></div></a></div><div class="next-post pull-right"><a href="/posts/12489/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202111042049048.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">由数据范围反推算法复杂度以及算法内容</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/38754/" title="C++ typedef typename 用法"><img class="cover" src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202112281104982.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-14</div><div class="title">C++ typedef typename 用法</div></div></a></div><div><a href="/posts/40197/" title="C++ 自定义比较器"><img class="cover" src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202112031934444.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-13</div><div class="title">C++ 自定义比较器</div></div></a></div><div><a href="/posts/45007/" title="C++知识点笔记"><img class="cover" src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202112281103528.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-10</div><div class="title">C++知识点笔记</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202110251550056.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">SEUGarfield</div><div class="author-info__description">欢迎乘坐猫巴士</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">93</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zgzhengSEU"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zgzhengSEU" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:DedSec@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">建个博客记录学习、生活，不定时更新ing<div class="twopeople"><div class="container" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width:200px; max-height:200px; touch-action:none;width:640px;height:640px;"></canvas></div><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js"></script><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js"></script><script id="rendered-js" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center;}canvas {display:block;margin:0 auto;cursor:move;}</style></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">CPP Primer 知识点笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E5%BC%80%E5%A7%8B"><span class="toc-text">第1章 开始</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%86%9F%E6%82%89%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">熟悉编译器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO"><span class="toc-text">IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while%E8%AF%AD%E5%8F%A5"><span class="toc-text">while语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E8%AF%AD%E5%8F%A5"><span class="toc-text">for语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">使用文件重定向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E7%AE%80"><span class="toc-text">第2章 变量和基本类型(简)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">基本内置类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%B1%BB%E5%9E%8B"><span class="toc-text">如何选择类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F"><span class="toc-text">字面值常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%EF%BC%88define%EF%BC%89"><span class="toc-text">变量定义（define）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%EF%BC%88declaration%EF%BC%89-vs-%E5%AE%9A%E4%B9%89%EF%BC%88define%EF%BC%89"><span class="toc-text">变量的声明（declaration） vs 定义（define）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="toc-text">左值和右值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">复合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-text">引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-text">指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-text">const限定符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8Cconst"><span class="toc-text">初始化和const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-text">const的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8Cconst"><span class="toc-text">指针和const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82const"><span class="toc-text">顶层const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#constexpr%E5%92%8C%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E2%96%B2%E5%8F%AF%E9%80%89%EF%BC%89"><span class="toc-text">constexpr和常量表达式（▲可选）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="toc-text">处理类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#auto%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6-c-11"><span class="toc-text">auto类型说明符 c++11</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#decltype%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-text">decltype类型指示符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">自定义数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#struct"><span class="toc-text">struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">编写自己的头文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">第2章 变量和基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%EF%BC%88Primitive-Built-in-Types%EF%BC%89"><span class="toc-text">基本内置类型（Primitive Built-in Types）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E7%B1%BB%E5%9E%8B%EF%BC%88Arithmetic-Types%EF%BC%89"><span class="toc-text">算数类型（Arithmetic Types）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88Type-Conversions%EF%BC%89"><span class="toc-text">类型转换（Type Conversions）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F%EF%BC%88Literals%EF%BC%89"><span class="toc-text">字面值常量（Literals）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%EF%BC%88Variables%EF%BC%89"><span class="toc-text">变量（Variables）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%EF%BC%88Variable-Definitions%EF%BC%89"><span class="toc-text">变量定义（Variable Definitions）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%88Variable-Declarations-and-Definitions%EF%BC%89"><span class="toc-text">变量声明和定义的关系（Variable Declarations and Definitions）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%88Identifiers%EF%BC%89"><span class="toc-text">标识符（Identifiers）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88Scope-of-a-Name%EF%BC%89"><span class="toc-text">名字的作用域（Scope of a Name）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%88Compound-Type%EF%BC%89"><span class="toc-text">复合类型（Compound Type）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%EF%BC%88References%EF%BC%89"><span class="toc-text">引用（References）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%EF%BC%88Pointer%EF%BC%89"><span class="toc-text">指针（Pointer）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E%EF%BC%88Understanding-Compound-Type-Declarations%EF%BC%89"><span class="toc-text">理解复合类型的声明（Understanding Compound Type Declarations）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%88Const-Qualifier%EF%BC%89"><span class="toc-text">const限定符（Const Qualifier）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%88References-to-const%EF%BC%89"><span class="toc-text">const的引用（References to const）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8Cconst%EF%BC%88Pointers-and-const%EF%BC%89"><span class="toc-text">指针和const（Pointers and const）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82const%EF%BC%88Top-Level-const%EF%BC%89"><span class="toc-text">顶层const（Top-Level const）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#constexpr%E5%92%8C%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88constexpr-and-Constant-Expressions%EF%BC%89"><span class="toc-text">constexpr和常量表达式（constexpr and Constant Expressions）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B%EF%BC%88Dealing-with-Types%EF%BC%89"><span class="toc-text">处理类型（Dealing with Types）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%EF%BC%88Type-Aliases%EF%BC%89"><span class="toc-text">类型别名（Type Aliases）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#auto%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6%EF%BC%88The-auto-Type-Specifier%EF%BC%89"><span class="toc-text">auto类型说明符（The auto Type Specifier）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#decltype%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6%EF%BC%88The-decltype-Type-Specifier%EF%BC%89"><span class="toc-text">decltype类型指示符（The decltype Type Specifier）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88Defining-Our-Own-Data-Structures%EF%BC%89"><span class="toc-text">自定义数据结构（Defining Our Own Data Structures）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-%E7%AE%80"><span class="toc-text">第3章 字符串、向量和数组(简)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#using%E5%A3%B0%E6%98%8E"><span class="toc-text">using声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string"><span class="toc-text">string</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96string%E5%AF%B9%E8%B1%A1"><span class="toc-text">定义和初始化string对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">string对象上的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86string%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-text">处理string对象中的字符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector"><span class="toc-text">vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96vector%E5%AF%B9%E8%B1%A1"><span class="toc-text">定义和初始化vector对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91vector%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-text">向vector对象中添加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96vector%E6%93%8D%E4%BD%9C"><span class="toc-text">其他vector操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8iterator"><span class="toc-text">迭代器iterator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">使用迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%90%E7%AE%97"><span class="toc-text">迭代器运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84"><span class="toc-text">定义和初始化内置数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-text">访问数组元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-text">数组和指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">C风格字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">多维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-text">关键字类型的要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pair"><span class="toc-text">pair</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">关联容器操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">关联容器迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-text">添加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E6%93%8D%E4%BD%9C"><span class="toc-text">下标操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-text">查找元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-text">无序容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-text">第11章 关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%EF%BC%88Using-an-Associative-Container%EF%BC%89"><span class="toc-text">使用关联容器（Using an Associative Container）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0%EF%BC%88Overview-of-the-Associative-Containers%EF%BC%89"><span class="toc-text">关联容器概述（Overview of the Associative Containers）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%EF%BC%88Defining-an-Associative-Container%EF%BC%89"><span class="toc-text">定义关联容器（Defining an Associative Container）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A6%81%E6%B1%82%EF%BC%88Requirements-on-Key-Type%EF%BC%89"><span class="toc-text">关键字类型的要求（Requirements on Key Type）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pair%E7%B1%BB%E5%9E%8B%EF%BC%88The-pair-Type%EF%BC%89"><span class="toc-text">pair类型（The pair Type）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%EF%BC%88Operations-on-Associative-Containers%EF%BC%89"><span class="toc-text">关联容器操作（Operations on Associative Containers）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88Associative-Container-Iterators%EF%BC%89"><span class="toc-text">关联容器迭代器（Associative Container Iterators）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%EF%BC%88Adding-Elements%EF%BC%89"><span class="toc-text">添加元素（Adding Elements）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%88Erasing-Elements%EF%BC%89"><span class="toc-text">删除元素（Erasing Elements）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E7%9A%84%E4%B8%8B%E6%A0%87%E6%93%8D%E4%BD%9C%EF%BC%88Subscripting-a-map%EF%BC%89"><span class="toc-text">map的下标操作（Subscripting a map）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0%EF%BC%88Accessing-Elements%EF%BC%89"><span class="toc-text">访问元素（Accessing Elements）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8%EF%BC%88The-Unordered-Containers%EF%BC%89"><span class="toc-text">无序容器（The Unordered Containers）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%EF%BC%88%E7%AE%80%EF%BC%89"><span class="toc-text">第12章 动态内存（简）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">动态内存与智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr%E7%B1%BB"><span class="toc-text">shared_ptr类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98"><span class="toc-text">直接管理内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr%E5%92%8Cnew%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-text">shared_ptr和new结合使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-text">智能指针和异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unique-ptr"><span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#weak-ptr"><span class="toc-text">weak_ptr</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">动态数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#new%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-text">new和数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#allocator%E7%B1%BB"><span class="toc-text">allocator类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="toc-text">第12章 动态内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%88Dynamic-Memory-and-Smart-Pointers%EF%BC%89"><span class="toc-text">动态内存与智能指针（Dynamic Memory and Smart Pointers）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr%E7%B1%BB%EF%BC%88The-shared-ptr-Class%EF%BC%89"><span class="toc-text">shared_ptr类（The shared_ptr Class）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%EF%BC%88Managing-Memory-Directly%EF%BC%89"><span class="toc-text">直接管理内存（Managing Memory Directly）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr%E5%92%8Cnew%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%88Using-shared-ptrs-with-new%EF%BC%89"><span class="toc-text">shared_ptr和new结合使用（Using shared_ptrs with new）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%82%E5%B8%B8%EF%BC%88Smart-Pointers-and-Exceptions%EF%BC%89"><span class="toc-text">智能指针和异常（Smart Pointers and Exceptions）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unique-ptr%EF%BC%88unique-ptr%EF%BC%89"><span class="toc-text">unique_ptr（unique_ptr）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#weak-ptr%EF%BC%88weak-ptr%EF%BC%89"><span class="toc-text">weak_ptr（weak_ptr）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%88Dynamic-Arrays%EF%BC%89"><span class="toc-text">动态数组（Dynamic Arrays）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#new%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%88new-and-Arrays%EF%BC%89"><span class="toc-text">new和数组（new and Arrays）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#allocator%E7%B1%BB%EF%BC%88The-allocator-Class%EF%BC%89"><span class="toc-text">allocator类（The allocator Class）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%EF%BC%88%E7%AE%80%EF%BC%89"><span class="toc-text">第13章 拷贝控制（简）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E5%92%8C%E9%94%80%E6%AF%81"><span class="toc-text">拷贝、赋值和销毁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">拷贝构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">拷贝赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-%E4%BA%94%E6%B3%95%E5%88%99"><span class="toc-text">三&#x2F;五法则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-default"><span class="toc-text">使用&#x3D;default</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E6%8B%B7%E8%B4%9D"><span class="toc-text">阻止拷贝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-text">拷贝控制和资源管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="toc-text">交换操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8"><span class="toc-text">对象移动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">右值引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">移动构造函数和移动赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">右值引用和成员函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="toc-text">第13章 拷贝控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E4%B8%8E%E9%94%80%E6%AF%81%EF%BC%88Copy%EF%BC%8CAssign%EF%BC%8Cand-Destroy%EF%BC%89"><span class="toc-text">拷贝、赋值与销毁（Copy，Assign，and Destroy）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88The-Copy-Constructor%EF%BC%89"><span class="toc-text">拷贝构造函数（The Copy Constructor）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88The-Copy-Assignment-Operator%EF%BC%89"><span class="toc-text">拷贝赋值运算符（The Copy-Assignment Operator）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%88The-Destructor%EF%BC%89"><span class="toc-text">析构函数（The Destructor）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-%E4%BA%94%E6%B3%95%E5%88%99%EF%BC%88The-Rule-of-Three-Five%EF%BC%89"><span class="toc-text">三&#x2F;五法则（The Rule of Three&#x2F;Five）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-default%EF%BC%88Using-default%EF%BC%89"><span class="toc-text">使用&#x3D;default（Using &#x3D;default）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E6%8B%B7%E8%B4%9D%EF%BC%88Preventing-Copies%EF%BC%89"><span class="toc-text">阻止拷贝（Preventing Copies）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%EF%BC%88Copy-Control-and-Resource-Management%EF%BC%89"><span class="toc-text">拷贝控制和资源管理（Copy Control and Resource Management）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%83%8F%E5%80%BC%E7%9A%84%E7%B1%BB%EF%BC%88Classes-That-Act-Like-Values%EF%BC%89"><span class="toc-text">行为像值的类（Classes That Act Like Values）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA%E5%83%8F%E6%8C%87%E9%92%88%E7%9A%84%E7%B1%BB%EF%BC%88Defining-Classes-That-Act-Like-Pointers%EF%BC%89"><span class="toc-text">定义行为像指针的类（Defining Classes That Act Like Pointers）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C%EF%BC%88Swap%EF%BC%89"><span class="toc-text">交换操作（Swap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E7%A4%BA%E4%BE%8B%EF%BC%88A-Copy-Control-Example%EF%BC%89"><span class="toc-text">拷贝控制示例（A Copy-Control Example）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B1%BB%EF%BC%88Classes-That-Manage-Dynamic-Memory%EF%BC%89"><span class="toc-text">动态内存管理类（Classes That Manage Dynamic Memory）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8%EF%BC%88Moving-Objects%EF%BC%89"><span class="toc-text">对象移动（Moving Objects）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%88Rvalue-Reference%EF%BC%89"><span class="toc-text">右值引用（Rvalue Reference）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88Move-Constructor-and-Move-Assignment%EF%BC%89"><span class="toc-text">移动构造函数和移动赋值运算符（Move Constructor and Move Assignment）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%88Rvalue-References-and-Member-Functions%EF%BC%89"><span class="toc-text">右值引用和成员函数（Rvalue References and Member Functions）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88%E7%AE%80%EF%BC%89"><span class="toc-text">第14章 重载运算与类型转换（简）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">输入和输出运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">重载输出运算符&lt;&lt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BE%93%E5%85%A5%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">重载输入运算符&gt;&gt;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%E3%80%81-%E3%80%81-%E3%80%81-%EF%BC%89"><span class="toc-text">算数和关系运算符（+、-、*、&#x2F;）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">相等运算符&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">关系运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">赋值运算符&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">下标运算符[]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%E3%80%81%E2%80%93%EF%BC%89"><span class="toc-text">递增和递减运算符（++、–）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%E3%80%81-%EF%BC%89"><span class="toc-text">成员访问运算符（*、-&gt;）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">函数调用运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda%E6%98%AF%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text">lambda是函数对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text">标准库定义的函数对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%B8%8Efunction"><span class="toc-text">可调用对象与function</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">重载、类型转换、运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">类型转换运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%9C%89%E4%BA%8C%E4%B9%89%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">避免有二义性的类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D%E4%B8%8E%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">函数匹配与重载运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">第14章 重载运算与类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88Basic-Concepts%EF%BC%89"><span class="toc-text">基本概念（Basic Concepts）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88Input-and-Output-Operators%EF%BC%89"><span class="toc-text">输入和输出运算符（Input and Output Operators）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6-%EF%BC%88Overloading-the-Output-Operator-%EF%BC%89"><span class="toc-text">重载输出运算符&lt;&lt;（Overloading the Output Operator &lt;&lt;）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BE%93%E5%85%A5%E8%BF%90%E7%AE%97%E7%AC%A6-%EF%BC%88Overloading-the-Input-Operator-%EF%BC%89"><span class="toc-text">重载输入运算符&gt;&gt;（Overloading the Input Operator &gt;&gt;）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88Arithmetic-and-Relational-Operators%EF%BC%89"><span class="toc-text">算术和关系运算符（Arithmetic and Relational Operators）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88Equality-Operators%EF%BC%89"><span class="toc-text">相等运算符（Equality Operators）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88Relational-Operators%EF%BC%89"><span class="toc-text">关系运算符（Relational Operators）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88Assignment-Operators%EF%BC%89"><span class="toc-text">赋值运算符（Assignment Operators）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88Subscript-Operator%EF%BC%89"><span class="toc-text">下标运算符（Subscript Operator）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88Increment-and-Decrement-Operators%EF%BC%89"><span class="toc-text">递增和递减运算符（Increment and Decrement Operators）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88Member-Access-Operators%EF%BC%89"><span class="toc-text">成员访问运算符（Member Access Operators）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88Function-Call-Operator%EF%BC%89"><span class="toc-text">函数调用运算符（Function-Call Operator）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda%E6%98%AF%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%88Lambdas-Are-Function-Objects%EF%BC%89"><span class="toc-text">lambda是函数对象（Lambdas Are Function Objects）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%88Library-Defined-Function-Objects%EF%BC%89"><span class="toc-text">标准库定义的函数对象（Library-Defined Function Objects）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%B8%8Efunction%EF%BC%88Callable-Objects-and-function%EF%BC%89"><span class="toc-text">可调用对象与function（Callable Objects and function）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88Overloading%EF%BC%8CConversions%EF%BC%8Cand-Operators%EF%BC%89"><span class="toc-text">重载、类型转换与运算符（Overloading，Conversions，and Operators）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88Conversion-Operators%EF%BC%89"><span class="toc-text">类型转换运算符（Conversion Operators）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%9C%89%E4%BA%8C%E4%B9%89%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88Avoiding-Ambiguous-Conversions%EF%BC%89"><span class="toc-text">避免有二义性的类型转换（Avoiding Ambiguous Conversions）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D%E4%B8%8E%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88Function-Matching-and-Overloaded-Operators%EF%BC%89"><span class="toc-text">函数匹配与重载运算符（Function Matching and Overloaded Operators）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AE%80%EF%BC%89"><span class="toc-text">第15章 面向对象程序设计（简）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OOP%EF%BC%9A%E6%A6%82%E8%BF%B0"><span class="toc-text">OOP：概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-text">定义基类和派生类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB"><span class="toc-text">定义基类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-text">定义派生类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-text">类型转换与继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-text">抽象基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-text">访问控制与继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">继承中的类作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="toc-text">构造函数与拷贝控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">虚析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-text">合成拷贝控制与继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98"><span class="toc-text">派生类的拷贝控制成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">继承的构造函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-text">容器与继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E7%A8%8B%E5%BA%8F%E5%86%8D%E6%8E%A2"><span class="toc-text">文本查询程序再探</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">面向对象的解决方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">第15章 面向对象程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OOP%EF%BC%9A%E6%A6%82%E8%BF%B0%EF%BC%88OOP%EF%BC%9AAn-Overview%EF%BC%89"><span class="toc-text">OOP：概述（OOP：An Overview）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%EF%BC%88Defining-Base-and-Derived-Classes%EF%BC%89"><span class="toc-text">定义基类和派生类（Defining Base and Derived Classes）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB%EF%BC%88Defining-a-Base-Class%EF%BC%89"><span class="toc-text">定义基类（Defining a Base Class）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%B4%BE%E7%94%9F%E7%B1%BB%EF%BC%88Defining-a-Derived-Class%EF%BC%89"><span class="toc-text">定义派生类（Defining a Derived Class）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%BB%A7%E6%89%BF%EF%BC%88Conversions-and-Inheritance%EF%BC%89"><span class="toc-text">类型转换与继承（Conversions and Inheritance）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%88Virtual-Functions%EF%BC%89"><span class="toc-text">虚函数（Virtual Functions）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%EF%BC%88Abstract-Base-Classes%EF%BC%89"><span class="toc-text">抽象基类（Abstract Base Classes）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF%EF%BC%88Access-Control-and-Inheritance%EF%BC%89"><span class="toc-text">访问控制与继承（Access Control and Inheritance）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88Class-Scope-under-Inheritance%EF%BC%89"><span class="toc-text">继承中的类作用域（Class Scope under Inheritance）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%EF%BC%88Constructors-and-Copy-Control%EF%BC%89"><span class="toc-text">构造函数与拷贝控制（Constructors and Copy Control）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%88Virtual-Destructors%EF%BC%89"><span class="toc-text">虚析构函数（Virtual Destructors）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF%EF%BC%88Synthesized-Copy-Control-and-Inheritance%EF%BC%89"><span class="toc-text">合成拷贝控制与继承（Synthesized Copy Control and Inheritance）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98%EF%BC%88Derived-Class-Copy-Control-Members%EF%BC%89"><span class="toc-text">派生类的拷贝控制成员（Derived-Class Copy-Control Members）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88Inherited-Constructors%EF%BC%89"><span class="toc-text">继承的构造函数（Inherited Constructors）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%8E%E7%BB%A7%E6%89%BF%EF%BC%88Containers-and-Inheritance%EF%BC%89"><span class="toc-text">容器与继承（Containers and Inheritance）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E7%AE%80%EF%BC%89"><span class="toc-text">第16章 模板和泛型编程（简）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF"><span class="toc-text">定义模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-text">函数模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-text">类模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-text">模板参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="toc-text">成员模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">控制实例化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E4%B8%8E%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="toc-text">效率与灵活性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD"><span class="toc-text">模板实参推断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-text">类型转换与模板类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%98%BE%E5%BC%8F%E5%AE%9E%E5%8F%82"><span class="toc-text">函数模板显式实参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E7%BD%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">尾置返回类型与类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD"><span class="toc-text">函数指针和实参推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-text">模板实参推断和引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3std-move"><span class="toc-text">理解std::move</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91"><span class="toc-text">转发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%A8%A1%E6%9D%BF"><span class="toc-text">重载与模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-text">可变参数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-text">编写可变参数函数模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E6%89%A9%E5%B1%95"><span class="toc-text">包扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91%E5%8F%82%E6%95%B0%E5%8C%85"><span class="toc-text">转发参数包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96%EF%BC%88Specializations%EF%BC%89"><span class="toc-text">模板特例化（Specializations）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">第16章 模板与泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%EF%BC%88Defining-a-Template%EF%BC%89"><span class="toc-text">定义模板（Defining a Template）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%EF%BC%88Function-Templates%EF%BC%89"><span class="toc-text">函数模板（Function Templates）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%EF%BC%88Class-Templates%EF%BC%89"><span class="toc-text">类模板（Class Templates）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%EF%BC%88Template-Parameters%EF%BC%89"><span class="toc-text">模板参数（Template Parameters）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF%EF%BC%88Member-Templates%EF%BC%89"><span class="toc-text">成员模板（Member Templates）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%88Controlling-Instantiations%EF%BC%89"><span class="toc-text">控制实例化（Controlling Instantiations）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E4%B8%8E%E7%81%B5%E6%B4%BB%E6%80%A7%EF%BC%88Efficiency-and-Flexibility%EF%BC%89"><span class="toc-text">效率与灵活性（Efficiency and Flexibility）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD%EF%BC%88Template-Argument-Deduction%EF%BC%89"><span class="toc-text">模板实参推断（Template Argument Deduction）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%EF%BC%88Conversions-and-Template-Type-Parameters%EF%BC%89"><span class="toc-text">类型转换与模板类型参数（Conversions and Template Type Parameters）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%98%BE%E5%BC%8F%E5%AE%9E%E5%8F%82%EF%BC%88Function-Template-Explicit-Arguments%EF%BC%89"><span class="toc-text">函数模板显式实参（Function-Template Explicit Arguments）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E7%BD%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88Trailing-Return-Types-and-Type-Transformation%EF%BC%89"><span class="toc-text">尾置返回类型与类型转换（Trailing Return Types and Type Transformation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD%EF%BC%88Function-Pointers-and-Argument-Deduction%EF%BC%89"><span class="toc-text">函数指针和实参推断（Function Pointers and Argument Deduction）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD%E5%92%8C%E5%BC%95%E7%94%A8%EF%BC%88Template-Argument-Deduction-and-References%EF%BC%89"><span class="toc-text">模板实参推断和引用（Template Argument Deduction and References）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3std-move%EF%BC%88Understanding-std-move%EF%BC%89"><span class="toc-text">理解std::move（Understanding std::move）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91%EF%BC%88Forwarding%EF%BC%89"><span class="toc-text">转发（Forwarding）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%A8%A1%E6%9D%BF%EF%BC%88Overloading-and-Templates%EF%BC%89"><span class="toc-text">重载与模板（Overloading and Templates）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%EF%BC%88Variadic-Templates%EF%BC%89"><span class="toc-text">可变参数模板（Variadic Templates）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%EF%BC%88Writing-a-Variadic-Function-Template%EF%BC%89"><span class="toc-text">编写可变参数函数模板（Writing a Variadic Function Template）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E6%89%A9%E5%B1%95%EF%BC%88Pack-Expansion%EF%BC%89"><span class="toc-text">包扩展（Pack Expansion）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91%E5%8F%82%E6%95%B0%E5%8C%85%EF%BC%88Forwarding-Parameter-Packs%EF%BC%89"><span class="toc-text">转发参数包（Forwarding Parameter Packs）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96%EF%BC%88Template-Specializations%EF%BC%89"><span class="toc-text">模板特例化（Template Specializations）</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/43615/" title="C++11 新特性相关知识"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203122040654.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++11 新特性相关知识"/></a><div class="content"><a class="title" href="/posts/43615/" title="C++11 新特性相关知识">C++11 新特性相关知识</a><time datetime="2022-03-12T11:56:44.000Z" title="发表于 2022-03-12 19:56:44">2022-03-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/28622/" title="C++ 虚函数表"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203122041145.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ 虚函数表"/></a><div class="content"><a class="title" href="/posts/28622/" title="C++ 虚函数表">C++ 虚函数表</a><time datetime="2022-02-22T05:12:09.000Z" title="发表于 2022-02-22 13:12:09">2022-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/59570/" title="Typora 破解教程"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202111041917080.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Typora 破解教程"/></a><div class="content"><a class="title" href="/posts/59570/" title="Typora 破解教程">Typora 破解教程</a><time datetime="2022-02-16T08:04:53.000Z" title="发表于 2022-02-16 16:04:53">2022-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/63259/" title="多模式串匹配 | AC自动机、Trie图"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203122045912.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="多模式串匹配 | AC自动机、Trie图"/></a><div class="content"><a class="title" href="/posts/63259/" title="多模式串匹配 | AC自动机、Trie图">多模式串匹配 | AC自动机、Trie图</a><time datetime="2022-02-04T05:04:38.000Z" title="发表于 2022-02-04 13:04:38">2022-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/33182/" title="数学知识 | 博弈论之SG函数"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203122047697.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数学知识 | 博弈论之SG函数"/></a><div class="content"><a class="title" href="/posts/33182/" title="数学知识 | 博弈论之SG函数">数学知识 | 博弈论之SG函数</a><time datetime="2022-01-31T06:35:53.000Z" title="发表于 2022-01-31 14:35:53">2022-01-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By SEUGarfield</div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadWaline () {
  function initWaline () {
    const waline = new Waline(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-api-one.vercel.app/',
      avatar: 'monsterid',
      avatarCDN: 'https://sdn.geekzu.org/avatar/',
      path: location.pathname,
      visitor: false,
      dark: 'html[data-theme="dark"]'
    }, null))
  }

  if (typeof Waline === 'function') initWaline() 
  else getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js').then(initWaline)
}

if ('Waline' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/f3334bcb.js","daovoice")
</script><script>var isChatBtn = true
daovoice('init', {
  app_id: 'f3334bcb',},{
  launcher: { 
     disableLauncherIcon: isChatBtn // 悬浮 ICON 是否显示
  },
});
daovoice('update');

if (isChatBtn) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      daovoice('show')
    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: true // 悬浮 ICON 是否显示
        },
      });
    }
    function chatBtnShow () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: false // 悬浮 ICON 是否显示
        },
      });
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>