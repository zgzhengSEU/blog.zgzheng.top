<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统知识点笔记 | 笑枕晚风の小站</title><meta name="keywords" content="操作系统"><meta name="author" content="SEUGarfield"><meta name="copyright" content="SEUGarfield"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统知识点总结 TopK 1、进程和线程之间有什么区别？ TopK   CS-Notes Ⅰ 拥有资源  进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。  Ⅱ 调度  线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。  Ⅲ 系统开销  由于创建或撤销进程时，系统都要为之分配或回收资源，">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统知识点笔记">
<meta property="og:url" content="https://blog.zgzheng.top/posts/64104/index.html">
<meta property="og:site_name" content="笑枕晚风の小站">
<meta property="og:description" content="操作系统知识点总结 TopK 1、进程和线程之间有什么区别？ TopK   CS-Notes Ⅰ 拥有资源  进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。  Ⅱ 调度  线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。  Ⅲ 系统开销  由于创建或撤销进程时，系统都要为之分配或回收资源，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203122101249.jpg">
<meta property="article:published_time" content="2022-01-12T12:54:26.000Z">
<meta property="article:modified_time" content="2022-03-12T13:05:53.997Z">
<meta property="article:author" content="SEUGarfield">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203122101249.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202201121022530.png"><link rel="canonical" href="https://blog.zgzheng.top/posts/64104/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="jHeEqmxcY5gJhgQXHPVzNF9LSawljE99iQNENuIPBp4"/><meta name="baidu-site-verification" content="code-PCT1t1AN4f"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?fd347c67a4aa89bb0cfbfa45cf3b7a98";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-2FF9T1FD5L"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2FF9T1FD5L');
</script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "9ds0zhvaq8");</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统知识点笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-12 21:05:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="笑枕晚风の小站" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202110251550056.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">93</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/steamgames/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203122101249.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">笑枕晚风の小站</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/steamgames/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统知识点笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-12T12:54:26.000Z" title="发表于 2022-01-12 20:54:26">2022-01-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-12T13:05:53.997Z" title="更新于 2022-03-12 21:05:53">2022-03-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">87.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>270分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统知识点笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>操作系统知识点总结</h1>
<h2 id="TopK">TopK</h2>
<h3 id="1、进程和线程之间有什么区别？">1、进程和线程之间有什么区别？</h3>
<h4 id="TopK-2">TopK</h4>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081954620.png" alt="image-20220308195418522"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081954199.png" alt="image-20220308195455064"></p>
<h4 id="CS-Notes">CS-Notes</h4>
<p>Ⅰ 拥有资源</p>
<ul>
<li>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</li>
</ul>
<p>Ⅱ 调度</p>
<ul>
<li>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
</ul>
<p>Ⅲ 系统开销</p>
<ul>
<li>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li>
</ul>
<p>Ⅳ 通信方面</p>
<ul>
<li>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</li>
</ul>
<h4 id="阿秀">阿秀</h4>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">进程</th>
<th style="text-align:center">线程</th>
<th style="text-align:center">协程</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">定义</td>
<td style="text-align:center">资源分配和拥有的基本单位</td>
<td style="text-align:center">程序执行（CPU调度）的基本单位</td>
<td style="text-align:center">用户态的轻量级线程，线程内部调度的基本单位</td>
</tr>
<tr>
<td style="text-align:center">切换情况</td>
<td style="text-align:center">进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td>
<td style="text-align:center">保存和设置程序计数器、少量寄存器和栈的内容</td>
<td style="text-align:center">先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td>
</tr>
<tr>
<td style="text-align:center">切换者</td>
<td style="text-align:center">操作系统</td>
<td style="text-align:center">操作系统</td>
<td style="text-align:center">用户</td>
</tr>
<tr>
<td style="text-align:center">切换过程</td>
<td style="text-align:center">用户态-&gt;内核态-&gt;用户态</td>
<td style="text-align:center">用户态-&gt;内核态-&gt;用户态</td>
<td style="text-align:center">用户态(没有陷入内核)</td>
</tr>
<tr>
<td style="text-align:center">调用栈</td>
<td style="text-align:center">内核栈</td>
<td style="text-align:center">内核栈</td>
<td style="text-align:center">用户栈</td>
</tr>
<tr>
<td style="text-align:center">拥有资源</td>
<td style="text-align:center">CPU资源、内存资源、文件资源和句柄等</td>
<td style="text-align:center">程序计数器、寄存器、栈和状态字</td>
<td style="text-align:center">拥有自己的寄存器上下文和栈</td>
</tr>
<tr>
<td style="text-align:center">并发性</td>
<td style="text-align:center">不同进程之间切换实现并发，各自占有CPU实现并行</td>
<td style="text-align:center">一个进程内部的多个线程并发执行</td>
<td style="text-align:center">同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td>
</tr>
<tr>
<td style="text-align:center">系统开销</td>
<td style="text-align:center">切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td>
<td style="text-align:center">切换时只需保存和设置少量寄存器内容，因此开销很小</td>
<td style="text-align:center">直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td>
</tr>
<tr>
<td style="text-align:center">通信方面</td>
<td style="text-align:center">进程间通信需要借助操作系统</td>
<td style="text-align:center">线程间可以直接读写进程数据段(如全局变量)来进行通信</td>
<td style="text-align:center">共享内存、消息队列</td>
</tr>
</tbody>
</table>
<ol>
<li>进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序</li>
<li>线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束</li>
<li>多提一句：协程是用户态的轻量级线程，线程内部调度的基本单位</li>
</ol>
<p  id="线程与进程的比较"></p>
<ol>
<li>线程启动速度快，轻量级</li>
<li>线程的系统开销小</li>
<li>线程使用有一定难度，需要处理数据一致性问题</li>
<li>同一线程共享的有堆、全局变量、静态变量、指针，引用、文件等，而独自占有栈</li>
</ol>
<h4 id="牛客">牛客</h4>
<ol>
<li>
<p><strong>进程</strong>：程序是指令、数据及其组织形式的描述，而进程则是程序的运行实例，包括程序计数器、寄存器和变量的当前值。</p>
</li>
<li>
<p><strong>线程</strong>：微进程，一个进程里更小粒度的执行单元。一个进程里包含多个线程并发执行任务。</p>
</li>
<li>
<p><strong>协程</strong>：协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行。</p>
</li>
</ol>
<p><strong>区别</strong>：</p>
<ol>
<li>
<p><strong>线程与进程的区别</strong>：</p>
<p>（1）一个线程从属于一个进程；一个进程可以包含多个线程。</p>
<p>（2）一个线程挂掉，对应的进程挂掉；一个进程挂掉，不会影响其他进程。</p>
<p>（3）进程是系统资源调度的最小单位；线程CPU调度的最小单位。</p>
<p>（4）进程系统开销显著大于线程开销；线程需要的系统资源更少。</p>
<p>（5）进程在执行时拥有独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。</p>
<p>（6）进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈。</p>
<p>（7）通信方式不一样。</p>
<p>（8）进程适应于多核、多机分布；线程适用于多核</p>
</li>
<li>
<p><strong>线程与协程的区别：</strong></p>
<p>（1）协程执行效率极高。协程直接操作栈基本没有内核切换的开销，所以上下文的切换非常快，切换开销比线程更小。</p>
<p>（2）协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高。</p>
<p>（3）一个线程可以有多个协程。</p>
</li>
</ol>
<h3 id="2、进程间有哪些通信方式？">2、进程间有哪些通信方式？</h3>
<h4 id="牛客-2">牛客</h4>
<p>进程间通信主要包括<strong>管道</strong>、<strong>系统IPC</strong>（包括消息队列、信号量、信号、共享内存）、<strong>套接字socket</strong>。</p>
<ol>
<li>
<p><strong>管道</strong>：包括无名管道和命名管道，无名管道半双工，只能用于具有亲缘关系的进程直接的通信（父子进程或者兄弟进程），可以看作一种特殊的文件；命名管道可以允许无亲缘关系进程间的通信。</p>
</li>
<li>
<p><strong>系统IPC</strong></p>
<p><strong>消息队列</strong>：消息的链接表，放在内核中。消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除；消息队列可以实现消息的随机查询，可以按照消息的类型读取。</p>
<p><strong>信号量semaphore</strong>：是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步。</p>
<p><strong>信号</strong>：用于通知接收进程某个事件的发生。</p>
<p><strong>内存共享</strong>：使多个进程访问同一块内存空间。</p>
</li>
<li>
<p><strong>套接字socket</strong>：用于不同主机直接的通信。</p>
</li>
</ol>
<h4 id="阿秀-2">阿秀</h4>
<ul>
<li>
<p>管道：</p>
<ul>
<li>
<p>无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。</p>
</li>
<li>
<p>有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。</p>
</li>
</ul>
</li>
<li>
<p>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。<strong>共享内存是最快的 IPC 方式</strong>，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。</p>
</li>
<li>
<p>消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
</li>
<li>
<p>信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</p>
</li>
<li>
<p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。</p>
</li>
<li>
<p>套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。</p>
</li>
</ul>
<h4 id="huihut">huihut</h4>
<p><strong>管道</strong>（PIPE）</p>
<ul>
<li><strong>有名管道 FIFO</strong>：一种半双工的通信方式，它允许无亲缘关系进程间的通信
<ul>
<li>优点：可以实现任意关系的进程间的通信</li>
<li>缺点：
<ol>
<li>长期存于系统中，使用不当容易出错</li>
<li>缓冲区有限</li>
</ol>
</li>
</ul>
</li>
<li><strong>无名管道</strong>：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）
<ul>
<li>优点：简单方便</li>
<li>缺点：
<ol>
<li>局限于单向通信</li>
<li>只能创建在它的进程以及其有亲缘关系的进程之间</li>
<li>缓冲区有限</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>消息队列</strong>（Message Queue）</p>
<ul>
<li>是消息的链表，存放在内核中并由消息队列标识符标识</li>
</ul>
<ul>
<li>优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便</li>
<li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li>
</ul>
<p><strong>共享内存</strong>（Shared Memory）</p>
<ul>
<li>映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问</li>
</ul>
<ul>
<li>优点：无须复制，快捷，信息量大</li>
<li>缺点：
<ol>
<li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此需要考虑进程间的读写操作的同步问题</li>
<li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li>
</ol>
</li>
</ul>
<p><strong>信号量</strong>（Semaphore）</p>
<ul>
<li>一个计数器，可以用来控制多个线程对共享资源的访问</li>
</ul>
<ul>
<li>优点：可以同步进程</li>
<li>缺点：信号量有限</li>
</ul>
<p><strong>信号</strong>（Signal）</p>
<ul>
<li>一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li>
</ul>
<p><strong>套接字</strong>（Socket）</p>
<ul>
<li>可用于不同计算机间的进程通信</li>
</ul>
<ul>
<li>优点：
<ol>
<li>传输数据为字节级，传输数据可自定义，数据量小效率高</li>
<li>传输数据时间短，性能高</li>
<li>适合于客户端和服务器端之间信息实时交互</li>
<li>可以加密,数据安全性强</li>
</ol>
</li>
<li>缺点：需对传输的数据进行解析，转化成应用级的数据。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LUO77/p/5816326.html">进程间通信的方式——信号、管道、消息队列、共享内存 - 0giant - 博客园 (cnblogs.com)</a></p>
<h3 id="3、简述-select-poll-epoll-的使用场景以及区别，epoll-中水平触发以及边缘触发有什么不同？">3、简述 select, poll, epoll 的使用场景以及区别，epoll 中水平触发以及边缘触发有什么不同？</h3>
<h4 id="从阻塞-I-O-到-I-O-多路复用">从阻塞 I/O 到 I/O 多路复用</h4>
<p>阻塞 I/O，是指进程发起调用后，会被挂起（阻塞），直到收到数据再返回。如果调用一直不返回，进程就会一直被挂起。因此，当使用阻塞 I/O 时，需要使用<strong>多线程</strong>来处理多个文件描述符。</p>
<p>多线程切换有一定的开销，因此引入非阻塞 I/O。非阻塞 I/O 不会将进程挂起，调用时会立即返回成功或错误，因此可以在<strong>一个线程</strong>里_轮询_多个文件描述符是否就绪。</p>
<p>但是非阻塞 I/O 的缺点是：每次发起系统调用，只能检查<strong>一个</strong>文件描述符是否就绪。当文件描述符很多时，系统调用的成本很高。</p>
<p>因此引入了 I/O 多路复用，可以<strong>通过一次系统调用，检查多个文件描述符的状态</strong>。这是 I/O 多路复用的主要优点，相比于非阻塞 I/O，在文件描述符较多的场景下，避免了频繁的用户态和内核态的切换，减少了系统调用的开销。</p>
<blockquote>
<p>I/O 多路复用相当于将「遍历所有文件描述符、通过非阻塞 I/O 查看其是否就绪」的过程从用户线程移到了内核中，由内核来负责轮询。</p>
</blockquote>
<p>进程可以通过 select、poll、epoll 发起 I/O 多路复用的系统调用，这些系统调用都是同步阻塞的：<strong>如果传入的多个文件描述符中，有描述符就绪，则返回就绪的描述符；否则如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞时长超过设置的 timeout 后，再返回</strong>。I/O 多路复用内部使用_非阻塞 I/O_ 检查每个描述符的就绪状态。</p>
<p>如果 <code>timeout</code> 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 <code>timeout</code> 参数设为 0，会立即返回，不阻塞。</p>
<p>I/O 多路复用引入了一些额外的操作和开销，性能更差。但是好处是用户可以在一个线程内同时处理多个 I/O 请求。如果不采用 I/O 多路复用，则必须通过多线程的方式，每个线程处理一个 I/O 请求。后者线程切换也是有一定的开销的。</p>
<h4 id="为什么-I-O-多路复用内部需要使用非阻塞-I-O">为什么 I/O 多路复用内部需要使用非阻塞 I/O</h4>
<p>I/O 多路复用<strong>内部</strong>会遍历集合中的每个文件描述符，判断其是否就绪：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> fd in read_set</span><br><span class="line">    <span class="keyword">if</span>（ readable(fd) ) <span class="comment">// 判断 fd 是否就绪</span></span><br><span class="line">        count++</span><br><span class="line">        FDSET(fd, &amp;res_rset) <span class="comment">// 将 fd 添加到就绪集合中</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<p>这里的 <code>readable(fd)</code> 就是一个非阻塞 I/O 调用。试想，如果这里使用阻塞 I/O，那么 <code>fd</code> 未就绪时，<code>select</code> 会阻塞在这个文件描述符上，无法检查下个文件描述符。</p>
<p>注意：这里说的是 I/O 多路复用的内部实现，而不是说，使用 I/O 多路复用就必须使用非阻塞 I/O，见下文为什么边缘触发必须使用非阻塞 I/O。</p>
<h4 id="select">select</h4>
<h5 id="函数签名与参数">函数签名与参数</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *<span class="keyword">restrict</span> readfds, fd_set *<span class="keyword">restrict</span> writefds, fd_set *<span class="keyword">restrict</span> errorfds, struct timeval *<span class="keyword">restrict</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>readfds</code>、<code>writefds</code>、<code>errorfds</code> 是三个文件描述符集合。<code>select</code> 会遍历每个集合的前 <code>nfds</code> 个描述符，分别找到可以读取、可以写入、发生错误的描述符，统称为“就绪”的描述符。然后用找到的子集替换参数中的对应集合，返回所有就绪描述符的总数。</p>
<p><code>timeout</code> 参数表示调用 <code>select</code> 时的阻塞时长。如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞超过设置的 timeout 后，返回。如果 <code>timeout</code> 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 <code>timeout</code> 参数设为 0，会立即返回，不阻塞。</p>
<h5 id="什么是文件描述符-fd">什么是文件描述符 fd</h5>
<p>文件描述符（file descriptor）是一个非负整数，从 0 开始。进程使用文件描述符来标识一个打开的文件。</p>
<p>系统为每一个进程维护了一个文件描述符表，表示该进程打开文件的记录表，而<strong>文件描述符实际上就是这张表的索引</strong>。当进程打开（<code>open</code>）或者新建（<code>create</code>）文件时，内核会在该进程的文件列表中新增一个表项，同时返回一个文件描述符 —— 也就是新增表项的下标。</p>
<p>一般来说，每个进程最多可以打开 64 个文件，<code>fd ∈ 0~63</code>。在不同系统上，最多允许打开的文件个数不同，Linux 2.4.22 强制规定最多不能超过 1,048,576。</p>
<p>每个进程默认都有 3 个文件描述符：0 (stdin)、1 (stdout)、2 (stderr)。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/labuladong/fucking-algorithm/blob/master/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B.md">这篇文章</a>以图示的方式对文件描述符作了深入地讲解，可以进一步阅读。</p>
<h5 id="socket-与-fd-的关系">socket 与 fd 的关系</h5>
<p>socket 是 Unix 中的术语。socket 可以用于同一台主机的不同进程间的通信，也可以用于不同主机间的通信。一个 socket 包含地址、类型和通信协议等信息，通过 <code>socket()</code> 函数创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br></pre></td></tr></table></figure>
<p>返回的就是这个 socket 对应的文件描述符 <code>fd</code>。操作系统将 socket 映射到进程的一个文件描述符上，进程就可以通过读写这个文件描述符来和远程主机通信。</p>
<p>可以这样理解：socket 是进程间通信规则的高层抽象，而 fd 提供的是底层的具体实现。socket 与 fd 是一一对应的。通过 socket 通信，实际上就是通过文件描述符 <code>fd</code> 读写文件。这也符合 Unix“一切皆文件”的哲学。</p>
<p>后面可以将 socket 和 fd 视为同义词。</p>
<h5 id="fd-set-文件描述符集合">fd_set 文件描述符集合</h5>
<p>参数中的 <code>fd_set</code> 类型表示文件描述符的集合。</p>
<p>由于文件描述符 <code>fd</code> 是一个从 0 开始的无符号整数，所以可以使用 <code>fd_set</code> 的<strong>二进制每一位</strong>来表示一个文件描述符。某一位为 1，表示对应的文件描述符已就绪。比如比如设 <code>fd_set</code> 长度为 1 字节，则一个 <code>fd_set</code> 变量最大可以表示 8 个文件描述符。当 <code>select</code> 返回 <code>fd_set = 00010011</code> 时，表示文件描述符 <code>1</code>、<code>2</code>、<code>5</code> 已经就绪。</p>
<p><code>fd_set</code> 的使用涉及以下几个 API：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/select.h&gt;   </span><br><span class="line">int FD_ZERO(int fd, fd_set *fdset);  // 将 fd_set 所有位置 0</span><br><span class="line">int FD_CLR(int fd, fd_set *fdset);   // 将 fd_set 某一位置 0</span><br><span class="line">int FD_SET(int fd, fd_set *fd_set);  // 将 fd_set 某一位置 1</span><br><span class="line">int FD_ISSET(int fd, fd_set *fdset); // 检测 fd_set 某一位是否为 1</span><br></pre></td></tr></table></figure>
<h5 id="select-使用示例">select 使用示例</h5>
<p>下图的代码说明：</p>
<ol>
<li>先声明一个 <code>fd_set</code> 类型的变量 <code>readFDs</code></li>
<li>调用 <code>FD_ZERO</code>，将 <code>readFDs</code> 所有位置 0</li>
<li>调用 <code>FD_SET</code>，将 <code>readFDs</code> 感兴趣的位置 1，表示要监听这几个文件描述符</li>
<li>将 <code>readFDs</code> 传给 <code>select</code>，调用 <code>select</code></li>
<li><code>select</code> 会将 <code>readFDs</code> 中就绪的位置 1，未就绪的位置 0，返回就绪的文件描述符的数量</li>
<li>当 <code>select</code> 返回后，调用 <code>FD_ISSET</code> 检测给定位是否为 1，表示对应文件描述符是否就绪</li>
</ol>
<p>比如进程想监听 1、2、5 这三个文件描述符，就将 <code>readFDs</code> 设置为 <code>00010011</code>，然后调用 <code>select</code>。</p>
<p>如果 <code>fd=1</code>、<code>fd=2</code> 就绪，而 <code>fd=5</code> 未就绪，<code>select</code> 会将 <code>readFDs</code> 设置为 <code>00000011</code> 并返回 2。</p>
<p>如果每个文件描述符都未就绪，<code>select</code> 会阻塞 <code>timeout</code> 时长，再返回。这期间，如果 <code>readFDs</code> 监听的某个文件描述符上发生可读事件，则 <code>select</code> 会将对应位置 1，并立即返回。</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091542416.jpeg" alt="15732186159520" style="zoom:50%;" />
<h5 id="select-的缺点">select 的缺点</h5>
<ol>
<li>性能开销大
<ol>
<li>调用 <code>select</code> 时会陷入内核，这时需要将参数中的 <code>fd_set</code> 从用户空间拷贝到内核空间</li>
<li>内核需要遍历传递进来的所有 <code>fd_set</code> 的每一位，不管它们是否就绪</li>
</ol>
</li>
<li>同时能够监听的文件描述符数量太少。受限于 <code>sizeof(fd_set)</code> 的大小，在编译内核时就确定了且无法更改。一般是 1024，不同的操作系统不相同</li>
</ol>
<h4 id="poll">poll</h4>
<p>poll 和 select 几乎没有区别。poll 在用户态通过<strong>数组</strong>方式<strong>传递</strong>文件描述符，在内核会转为<strong>链表</strong>方式<strong>存储</strong>，没有最大数量的限制。</p>
<p>poll 的函数签名如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中 <code>fds</code> 是一个 <code>pollfd</code> 结构体类型的数组，调用 <code>poll()</code> 时必须通过 <code>nfds</code> 指出数组 <code>fds</code> 的大小，即文件描述符的数量。详细描述见 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/poll.2.html">manpage - poll(2)</a>。</p>
<p>从性能开销上看，poll 和 select 的差别不大。</p>
<h4 id="epoll">epoll</h4>
<p>epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。</p>
<p>简而言之，epoll 有以下几个特点：</p>
<ul>
<li>使用<strong>红黑树</strong>存储文件描述符集合</li>
<li>使用<strong>链表</strong>存储就绪的文件描述符</li>
<li>每个文件描述符只需在添加时传入一次；通过事件更改文件描述符状态</li>
</ul>
<p>select、poll 模型都只使用一个函数，而 epoll 模型使用三个函数：<code>epoll_create</code>、<code>epoll_ctl</code> 和 <code>epoll_wait</code>。</p>
<h5 id="epoll-create">epoll_create</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>epoll_create</code> 会创建一个 <code>epoll</code> 实例，同时返回一个引用该实例的文件描述符。</p>
<p>返回的文件描述符仅仅指向对应的 <code>epoll</code> 实例，并不表示真实的磁盘文件节点。其他 API 如 <code>epoll_ctl</code>、<code>epoll_wait</code> 会使用这个文件描述符来操作相应的 <code>epoll</code> 实例。</p>
<p>当创建好 epoll 句柄后，它会占用一个 fd 值，在 linux 下查看 <code>/proc/进程id/fd/</code>，就能够看到这个 fd。所以在使用完 epoll 后，必须调用 <code>close(epfd)</code> 关闭对应的文件描述符，否则可能导致 fd 被耗尽。当指向同一个 <code>epoll</code> 实例的所有文件描述符都被关闭后，操作系统会销毁这个 <code>epoll</code> 实例。</p>
<p><code>epoll</code> 实例内部存储：</p>
<ul>
<li>监听列表：所有要监听的文件描述符，使用红黑树</li>
<li>就绪列表：所有就绪的文件描述符，使用链表</li>
</ul>
<h5 id="epoll-ctl">epoll_ctl</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>epoll_ctl</code> 会监听文件描述符 <code>fd</code> 上发生的 <code>event</code> 事件。</p>
<p>参数说明：</p>
<ul>
<li><code>epfd</code> 即 <code>epoll_create</code> 返回的文件描述符，指向一个 <code>epoll</code> 实例</li>
<li><code>fd</code> 表示要监听的目标文件描述符</li>
<li><code>event</code> 表示要监听的事件（可读、可写、发送错误…）</li>
<li><code>op</code> 表示要对 <code>fd</code> 执行的操作，有以下几种：
<ul>
<li><code>EPOLL_CTL_ADD</code>：为 <code>fd</code> 添加一个监听事件 <code>event</code></li>
<li><code>EPOLL_CTL_MOD</code>：Change the event event associated with the target file descriptor fd（<code>event</code> 是一个结构体变量，这相当于变量 <code>event</code> 本身没变，但是更改了其内部字段的值）</li>
<li><code>EPOLL_CTL_DEL</code>：删除 <code>fd</code> 的所有监听事件，这种情况下 <code>event</code> 参数没用</li>
</ul>
</li>
</ul>
<p>返回值 0 或 -1，表示上述操作成功与否。</p>
<p><code>epoll_ctl</code> 会将文件描述符 <code>fd</code> 添加到 <code>epoll</code> 实例的监听列表里，同时为 <code>fd</code> 设置一个回调函数，并监听事件 <code>event</code>。当 <code>fd</code> 上发生相应事件时，会调用回调函数，将 <code>fd</code> 添加到 <code>epoll</code> 实例的就绪队列上。</p>
<h5 id="epoll-wait">epoll_wait</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这是 epoll 模型的主要函数，功能相当于 <code>select</code>。</p>
<p>参数说明：</p>
<ul>
<li><code>epfd</code> 即 <code>epoll_create</code> 返回的文件描述符，指向一个 <code>epoll</code> 实例</li>
<li><code>events</code> 是一个数组，保存就绪状态的文件描述符，其空间由调用者负责申请</li>
<li><code>maxevents</code> 指定 <code>events</code> 的大小</li>
<li><code>timeout</code> 类似于 <code>select</code> 中的 timeout。如果没有文件描述符就绪，即就绪队列为空，则 <code>epoll_wait</code> 会阻塞 timeout 毫秒。如果 timeout 设为 -1，则 <code>epoll_wait</code> 会一直阻塞，直到有文件描述符就绪；如果 timeout 设为 0，则 <code>epoll_wait</code> 会立即返回</li>
</ul>
<p>返回值表示 <code>events</code> 中存储的就绪描述符个数，最大不超过 <code>maxevents</code>。</p>
<h5 id="epoll-的优点">epoll 的优点</h5>
<p>一开始说，epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。</p>
<p>对于“文件描述符数量少”，select 使用整型数组存储文件描述符集合，而 epoll 使用红黑树存储，数量较大。</p>
<p>对于“性能开销大”，<code>epoll_ctl</code> 中为每个文件描述符指定了回调函数，并在就绪时将其加入到就绪列表，因此 epoll 不需要像 <code>select</code> 那样遍历检测每个文件描述符，只需要判断就绪列表是否为空即可。这样，在没有描述符就绪时，epoll 能更早地让出系统资源。</p>
<blockquote>
<p>相当于时间复杂度从 O(n) 降为 O(1)</p>
</blockquote>
<p>此外，每次调用 <code>select</code> 时都需要向内核拷贝所有要监听的描述符集合，而 epoll 对于每个描述符，只需要在 <code>epoll_ctl</code> 传递一次，之后 <code>epoll_wait</code> 不需要再次传递。这也大大提高了效率。</p>
<h4 id="水平触发、边缘触发">水平触发、边缘触发</h4>
<p><code>select</code> 只支持水平触发，<code>epoll</code> 支持水平触发和边缘触发。</p>
<p>水平触发（LT，Level Trigger）：当文件描述符就绪时，会触发通知，如果用户程序没有一次性把数据读/写完，下次还会发出可读/可写信号进行通知。</p>
<p>边缘触发（ET，Edge Trigger）：仅当描述符从未就绪变为就绪时，通知一次，之后不会再通知。</p>
<p>区别：边缘触发效率更高，<strong>减少了事件被重复触发的次数</strong>，函数不会返回大量用户程序可能不需要的文件描述符。</p>
<blockquote>
<p>水平触发、边缘触发的名称来源：数字电路当中的电位水平，高低电平切换瞬间的触发动作叫边缘触发，而处于高电平的触发动作叫做水平触发。</p>
</blockquote>
<h4 id="为什么边缘触发必须使用非阻塞-I-O？">为什么边缘触发必须使用非阻塞 I/O？</h4>
<p>关于这个问题的解答，强烈建议阅读<a target="_blank" rel="noopener" href="https://eklitzke.org/blocking-io-nonblocking-io-and-epoll">这篇文章</a>。下面是一些关键摘要：</p>
<ul>
<li>每次通过 <code>read</code> 系统调用读取数据时，最多只能读取缓冲区大小的字节数；如果某个文件描述符一次性收到的数据超过了缓冲区的大小，那么需要对其 <code>read</code> 多次才能全部读取完毕</li>
<li><strong><code>select</code> 可以使用阻塞 I/O</strong>。通过 <code>select</code> 获取到所有可读的文件描述符后，遍历每个文件描述符，<code>read</code> <strong>一次</strong>数据（见上文 <a target="_blank" rel="noopener" href="https://imageslr.com/2020/02/27/select-poll-epoll.html#selectdemo">select 示例</a>）
<ul>
<li>这些文件描述符都是可读的，因此即使 <code>read</code> 是阻塞 I/O，也一定可以读到数据，不会一直阻塞下去</li>
<li><code>select</code> 采用水平触发模式，因此如果第一次 <code>read</code> 没有读取完全部数据，那么下次调用 <code>select</code> 时依然会返回这个文件描述符，可以再次 <code>read</code></li>
<li><strong><code>select</code> 也可以使用非阻塞 I/O</strong>。当遍历某个可读文件描述符时，使用 <code>for</code> 循环调用 <code>read</code> <strong>多次</strong>，直到读取完所有数据为止（返回 <code>EWOULDBLOCK</code>）。这样做会多一次 <code>read</code> 调用，但可以减少调用 <code>select</code> 的次数</li>
</ul>
</li>
<li>在 <code>epoll</code> 的边缘触发模式下，只会在文件描述符的可读/可写状态发生切换时，才会收到操作系统的通知
<ul>
<li>因此，如果使用 <code>epoll</code> 的<strong>边缘触发模式</strong>，在收到通知时，<strong>必须使用非阻塞 I/O，并且必须循环调用 <code>read</code> 或 <code>write</code> 多次，直到返回 <code>EWOULDBLOCK</code> 为止</strong>，然后再调用 <code>epoll_wait</code> 等待操作系统的下一次通知</li>
<li>如果没有一次性读/写完所有数据，那么在操作系统看来这个文件描述符的状态没有发生改变，将不会再发起通知，调用 <code>epoll_wait</code> 会使得该文件描述符一直等待下去，服务端也会一直等待客户端的响应，业务流程无法走完</li>
<li>这样做的好处是每次调用 <code>epoll_wait</code> 都是<strong>有效</strong>的——保证数据全部读写完毕了，等待下次通知。在水平触发模式下，如果调用 <code>epoll_wait</code> 时数据没有读/写完毕，会直接返回，再次通知。因此边缘触发能显著减少事件被触发的次数</li>
<li>为什么 <code>epoll</code> 的<strong>边缘触发模式不能使用阻塞 I/O</strong>？很显然，边缘触发模式需要循环读/写一个文件描述符的所有数据。如果使用阻塞 I/O，那么一定会在最后一次调用（没有数据可读/写）时阻塞，导致无法正常结束</li>
</ul>
</li>
</ul>
<h4 id="三者对比">三者对比</h4>
<ul>
<li><code>select</code>：调用开销大（需要复制集合）；集合大小有限制；需要遍历整个集合找到就绪的描述符</li>
<li><code>poll</code>：poll 采用数组的方式存储文件描述符，没有最大存储数量的限制，其他方面和 select 没有区别</li>
<li><code>epoll</code>：调用开销小（不需要复制）；集合大小无限制；采用回调机制，不需要遍历整个集合</li>
</ul>
<p><code>select</code>、<code>poll</code> 都是在用户态维护文件描述符集合，因此每次需要将完整集合传给内核；<code>epoll</code> 由操作系统在内核中维护文件描述符集合，因此只需要在创建的时候传入文件描述符。</p>
<p>此外 <code>select</code> 只支持水平触发，<code>epoll</code> 支持边缘触发。</p>
<h4 id="适用场景">适用场景</h4>
<p><strong>当连接数较多并且有很多的不活跃连接时，epoll 的效率比其它两者高很多。当连接数较少并且都十分活跃的情况下，由于 epoll 需要很多回调，因此性能可能低于其它两者。</strong></p>
<hr>
<h4 id="Linux-高性能服务器编程中的解释">Linux 高性能服务器编程中的解释</h4>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091530241.png" alt="image-20220309153008119" style="zoom: 67%;" />
<p>事件集合：这3组函数都通过某种结构体变量来告诉内核监听哪些文件描述符上的哪些事件，并使用该结构体类型的参数来获取内核处理的结果。</p>
<ol>
<li>select的参数类型fd_set没有将文件描述符和事件绑定，它仅仅是一个文件描述符集合，因此select需要提供3个这种类型的参数来分别传入和输出可读、可写及异常等事件。这一方面使得select不能处理更多类型的事件，另一方面由于内核对fd_set集合的在线修改，应用程序下次调用select前不得不重置这3个fd_set集合。</li>
<li>poll的参数类型pollfd则多少“聪明”一些。它把文件描述符和事件都定义其中，任何事件都被统一处理，从而使得编程接口简洁得多。并且内核每次修改的是pollfd结构体的revents成员，而events成员保持不变，因此下次调用poll时应用程序无须重置pollfd类型的事件集参数。由于每次select和poll调用都返回整个用户注册的事件集合（其中包括就绪的和未就绪的），所以应用程序索引就绪文件描述符的时间复杂度为O（n）。</li>
<li>epoll则采用与select和poll完全不同的方式来管理用户注册的事件。它在内核中维护一个事件表，并提供了一个独立的系统调用epoll_ctl来控制往其中添加、删除、修改事件。这样，每次epoll_wait调用都直接从该内核事件表中取得用户注册的事件，而无须反复从用户空间读入这些事件。epoll_wait系统调用的events参数仅用来返回就绪的事件，这使得应用程序索引就绪文件描述符的时间复杂度达到O（1）。</li>
</ol>
<p>最大支持文件描述符数：</p>
<ol>
<li>poll和epoll_wait分别用nfds和maxevents参数指定最多监听多少个文件描述符和事件。这两个数值都能达到系统允许打开的最大文件描述符数目，即65 535（cat/proc/sys/fs/file-max）。</li>
<li>而select允许监听的最大文件描述符数量通常有限制。虽然用户可以修改这个限制，但这可能导致不可预期的后果。</li>
</ol>
<p>工作模式：select和poll都只能工作在相对低效的LT模式，而epoll则可以工作在ET高效模式。并且epoll还支持EPOLLONESHOT事件。该事件能进一步减少可读、可写和异常等事件被触发的次数。</p>
<p>具体实现：</p>
<ol>
<li>从实现原理上来说，select和poll采用的都是轮询的方式，即每次调用都要扫描整个注册文件描述符集合，并将其中就绪的文件描述符返回给用户程序，因此它们检测就绪事件的算法的时间复杂度是O（n）。</li>
<li>epoll_wait则不同，它采用的是回调的方式。内核检测到就绪的文件描述符时，将触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪事件队列。内核最后在适当的时机将该就绪事件队列中的内容拷贝到用户空间。因此epoll_wait无须轮询整个文件描述符集合来检测哪些事件已经就绪，其算法时间复杂度是O（1）。</li>
<li>但是，当活动连接比较多的时候，epoll_wait的效率未必比select和poll高，因为此时回调函数被触发得过于频繁。所以epoll_wait适用于连接数量多，但活动连接较少的情况。</li>
</ol>
<hr>
<p>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。</p>
<p>与多进程和多线程技术相比，<code>I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程</code>，也不必维护这些进程/线程，从而大大减小了系统的开销。</p>
<p>目前支持I/O多路复用的系统调用有 <code>select，pselect，poll，epoll</code>，I/O多路复用就是<code>通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作</code>。<code>但select，pselect，poll，epoll本质上都是同步I/O</code>，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
<p>对于IO多路复用机制不理解的同学，可以先行参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/486b0965c296">《聊聊Linux 五种IO模型》</a>，来了解Linux五种IO模型。</p>
<h4 id="1、select、poll、epoll简介">1、select、poll、epoll简介</h4>
<p>epoll 跟 select都能提供多路 I/O 复用的解决方案。在现在的 Linux 内核里有都能够支持，<code>其中epoll是Linux所特有，而select则应该是POSIX所规定</code>，一般操作系统均有实现。</p>
<h5 id="1-1-select">1.1 select</h5>
<p><strong>基本原理：</strong></p>
<blockquote>
<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>
</blockquote>
<p>select目前几乎在所有的平台上支持，<code>其良好跨平台支持也是它的一个优点</code>。<code>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制</code>，在Linux上一般为1024，<code>可以通过修改宏定义甚至重新编译内核的方式提升这一限制</code>，但是这样也会造成效率的降低。</p>
<p><code>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理</code>。这样所带来的缺点是：</p>
<ol>
<li>
<p><strong>select 最大的缺陷就是单个进程所打开的 FD 是有一定限制的，它由FD_SETSIZE设置，默认值是1024。</strong></p>
<ul>
<li>一般来说这个数目和系统内存关系很大，<code>具体数目可以cat /proc/sys/fs/file-max察看</code>。32位机默认是1024个。64位机默认是2048.</li>
</ul>
</li>
<li>
<p><strong>对 socket 进行扫描时是线性扫描，即采用轮询的方法，效率较低。</strong></p>
<ul>
<li>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。<code>如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询</code>，这正是 epoll 与 kqueue 做的。</li>
</ul>
</li>
<li>
<p><strong>需要维护一个用来存放大量 fd 的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</strong></p>
</li>
</ol>
<h5 id="1-2-poll">1.2 poll</h5>
<p><strong>基本原理：</strong><br>
<code>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间</code>，然后查询每个 fd 对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有 fd 后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历 fd。这个过程经历了多次无谓的遍历。</p>
<p><strong>它没有最大连接数的限制，<code>原因是它是基于链表来存储的</code>，但是同样有一个缺点：</strong></p>
<ol>
<li>
<p><code>大量的fd的数组被整体复制于用户态和内核地址空间之间</code>，而不管这样的复制是不是有意义。</p>
</li>
<li>
<p><code>poll还有一个特点是“水平触发”</code>，如果报告了 fd 后，没有被处理，那么下次 poll 时会再次报告该 fd。</p>
</li>
</ol>
<p>**注意：**从上面看，select和poll都需要在返回后，<code>通过遍历文件描述符来获取已经就绪的socket</code>。事实上，<code>同时连接的大量客户端在一时刻可能只有很少的处于就绪状态</code>，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
<h5 id="1-3-epoll">1.3 epoll</h5>
<p>epoll 是在2.6内核中提出的，是之前的 select 和 poll 的增强版本。相对于 select 和 poll 来说，epoll 更加灵活，没有描述符限制。<code>epoll 使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次</code>。</p>
<p><strong>基本原理：</strong></p>
<ul>
<li><code>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些 fd 刚刚变为就绪态，并且只会通知一次</code>。还有一个特点是，<code>epoll使用“事件”的就绪通知方式</code>，通过 epoll_ctl 注册 fd，<code>一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd</code>，epoll_wait 便可以收到通知。</li>
</ul>
<p><strong>epoll的优点：</strong></p>
<ul>
<li><code>没有最大并发连接的限制</code>，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</li>
<li><code>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降</code>。只有活跃可用的FD才会调用callback函数；<code>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关</code>，因此在实际的网络环境中，Epoll 的效率就会远远高于select和poll。</li>
<li><code>内存拷贝</code>，利用 mmap() 文件映射内存加速与内核空间的消息传递；<code>即epoll使用mmap减少复制开销</code>。</li>
</ul>
<p><strong>epoll对文件描述符的操作有两种模式：<code>LT（level trigger）和ET（edge trigger）</code>。LT模式是默认模式，LT模式与ET模式的区别如下：</strong></p>
<ul>
<li>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li>
<li>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</li>
</ul>
<ol>
<li>
<p><strong>LT模式</strong><br>
<code>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket</code>。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。<code>如果你不作任何操作，内核还是会继续通知你的</code>。</p>
</li>
<li>
<p><strong>ET模式</strong><br>
<code>ET(edge-triggered)是高速工作方式，只支持no-block socket</code>。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。<code>但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</code>。</p>
<p><code>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高</code>。epoll工作在ET模式的时候，<code>必须使用非阻塞套接口</code>，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
</li>
<li>
<p>在select/poll中，<code>进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描</code>，而epoll事先通过epoll_ctl()来注册一个文件描述符，<code>一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制</code>，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。(<code>此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。</code>)</p>
</li>
</ol>
<h4 id="2、select、poll、epoll区别">2、select、poll、epoll区别</h4>
<ol>
<li>
<p><strong>支持一个进程所能打开的最大连接数</strong><br>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091523918.webp" alt="img" style="zoom:50%;" /></p>
</li>
<li>
<p><strong>FD剧增后带来的IO效率问题</strong><br>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091524739.webp" alt="img" style="zoom: 50%;" /></p>
</li>
<li>
<p><strong>消息传递方式</strong><br>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091524532.webp" alt="img" style="zoom:50%;" /></p>
</li>
</ol>
<p><strong>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：</strong></p>
<blockquote>
<ol>
<li>
<p>表面上看 epoll 的性能最好，<code>但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好</code>，毕竟 epoll 的通知机制需要很多函数回调。</p>
</li>
<li>
<p><code>select低效是因为每次它都需要轮询</code>。但低效也是相对的，视情况而定，也可通过良好的设计改善。</p>
</li>
</ol>
</blockquote>
<h3 id="4、简述-Linux-进程调度的算法">4、简述 Linux  进程调度的算法</h3>
<ol>
<li>先来先服务调度算法</li>
<li>短作业(进程)优先调度算法</li>
<li>高优先级优先调度算法</li>
<li>时间片轮转法</li>
<li>多级反馈队列调度算法</li>
</ol>
<p><strong>解析</strong></p>
<ol>
<li>先来先服务调度算法：每次调度都是从后备作业（进程）队列中选择一个或多个最先进入该队列的作业（进程），将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。</li>
<li>短作业(进程)优先调度算法：短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业（进程），将它们调入内存运行。</li>
<li>高优先级优先调度算法：当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程</li>
<li>时间片轮转法：每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。</li>
<li>多级反馈队列调度算法：综合前面多种调度算法。</li>
</ol>
<p>在这些调度算法中，有抢占式和非抢占式的区别。</p>
<ol>
<li>非抢占式优先权算法<br>
在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</li>
<li>抢占式优先权调度算法<br>
在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i 时，就将其优先权Pi与正在执行的进程j 的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi&gt;Pj，则立即停止Pj的执行，做进程切换，使i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</li>
</ol>
<p>区别：</p>
<p>非抢占式（Nonpreemptive）：让进程运行直到结束或阻塞的调度方式，容易实现，适合专用系统，不适合通用系统。<br>
抢占式（Preemptive）：允许将逻辑上可继续运行的在运行过程暂停的调度方式可防止单一进程长时间独占，CPU系统开销大（降低途径：硬件实现进程切换，或扩充主存以贮存大部分程序）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203082049612.jpg" alt="调度"></p>
<h3 id="5、简述几个常用的-Linux-命令以及他们的功能">5、简述几个常用的  Linux 命令以及他们的功能</h3>
<ol>
<li>
<p>cd命令：用于切换当前目录</p>
</li>
<li>
<p>ls命令：查看当前文件与目录</p>
</li>
<li>
<p>grep命令：该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工。</p>
</li>
<li>
<p>cp命令：复制命令</p>
</li>
<li>
<p>mv命令：移动文件或文件夹命令</p>
</li>
<li>
<p>rm命令：删除文件或文件夹命令</p>
</li>
<li>
<p>ps命令：查看进程情况</p>
</li>
<li>
<p>kill命令：向进程发送终止信号</p>
</li>
<li>
<p>tar命令：对文件进行打包，调用gzip或bzip对文件进行压缩或解压</p>
</li>
<li>
<p>cat命令：查看文件内容，与less、more功能相似</p>
</li>
<li>
<p>top命令：可以查看操作系统的信息，如进程、CPU占用率、内存信息等</p>
</li>
<li>
<p>pwd命令：命令用于显示工作目录。</p>
</li>
</ol>
<h3 id="6、简述操作系统如何进行内存管理">6、简述操作系统如何进行内存管理</h3>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091620471.png" alt="image-20220309162009316"></p>
<h3 id="7、线程有多少种状态，状态之间如何转换">7、线程有多少种状态，状态之间如何转换</h3>
<p>类似进程，有以下五种状态：</p>
<ol>
<li>
<p><strong>新建状态(New)</strong></p>
</li>
<li>
<p><strong>就绪状态(Runnable)</strong></p>
</li>
<li>
<p><strong>运行状态(Running)</strong></p>
</li>
<li>
<p><strong>阻塞状态(Blocked)</strong></p>
</li>
<li>
<p><strong>死亡状态(Dead)</strong></p>
</li>
</ol>
<p><strong>转换方式如下</strong>：</p>
<p><strong>创建状态</strong><br>
一个应用程序从系统上启动，首先就是进入<strong>创建状态</strong>，获取系统资源。</p>
<p><strong>就绪状态</strong><br>
在<strong>创建状态</strong>完成之后，线程已经准备好，处于<strong>就绪状态</strong>，但是还未获得处理器资源，无法运行。</p>
<p><strong>运行状态</strong><br>
获取处理器资源，被系统调度，当具有时间片开始进入<strong>运行状态</strong>。如果线程的时间片用完了就进入<strong>就绪状态</strong>。</p>
<p><strong>阻塞状态</strong><br>
在<strong>运行状态</strong>期间，如果进行了阻塞的操作，如耗时的I/O操作，此时线程暂时无法操作就进入到了<strong>阻塞状态</strong>，在这些操作完成后就进入<strong>就绪状态</strong>。等待再次获取处理器资源，被系统调度，当具有时间片就进入<strong>运行状态</strong>。</p>
<p><strong>终止状态</strong><br>
线程结束或者被系统终止，进入<strong>终止状态</strong></p>
<p>相互转换如图：</p>
<img src="https://uploadfiles.nowcoder.com/images/20210519/59_1621415889970/F1B3E414CB7B8F254EBDAED60E3BF80E" alt="image-20201221105446608" style="zoom:33%;" />
<h3 id="8、线程间有哪些通信方式？">8、线程间有哪些通信方式？</h3>
<p>线程间的同步方式包括<strong>互斥锁、信号量、条件变量、读写锁</strong>：</p>
<ol>
<li><strong>互斥锁</strong>：采用互斥对象机制，只有拥有互斥对象的线程才可以访问。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</li>
<li><strong>信号量</strong>：计数器，允许多个线程同时访问同一个资源。</li>
<li><strong>条件变量</strong>：通过条件变量通知操作的方式来保持多线程同步。</li>
<li><strong>读写锁</strong>：读写锁与互斥量类似。但互斥量要么是锁住状态，要么就是不加锁状态。读写锁一次只允许一个线程写，但允许一次多个线程读，这样效率就比互斥锁要高。</li>
</ol>
<h3 id="9、简述操作系统中的缺页中断">9、简述操作系统中的缺页中断</h3>
<ol>
<li>
<p><strong>缺页异常</strong>：malloc和mmap函数在分配内存时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个<strong>缺页异常，引发缺页中断</strong>。</p>
</li>
<li>
<p><strong>缺页中断</strong>：缺页异常后将产生一个缺页中断，此时操作系统会根据页表中的<strong>外存地址</strong>在外存中找到所缺的一页，将其调入<strong>内存</strong>。</p>
</li>
</ol>
<p>缺页中断与一般中断一样，需要经历四个步骤：保护CPU现场、分析中断原因、转入缺页中断处理程序、恢复CPU现场，继续执行。<br>
缺页中断与一般中断区别：<br>
（1）在指令执行期间产生和处理缺页中断信号<br>
（2）一条指令在执行期间，可能产生多次缺页中断<br>
（3）缺页中断返回的是执行产生中断的一条指令，而一般中断返回的是执行下一条指令。</p>
<ol>
<li>
<p>概念</p>
<p>缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。当图访问已映射在虚拟地址空间中，但是并未被加载在物理内存中的一个分页时，由中央处理器的内存管理单元所发出的中断。通常情况下，用于处理此中断的程序是操作系统的一部分。如果操作系统判断此次访问是有效的，那么操作系统会尝试将相关的分页从硬盘上的虚拟内存文件中调入内存。而如果访问是不被允许的，那么操作系统通常会结束相关的进程。</p>
</li>
<li>
<p>分类</p>
<ul>
<li>软性页缺失：指页缺失发生时，相关的页已经被加载进内存，但是没有向 MMU 注册的情况。操作系统只需要在 MMU 中注册相关页对应的物理地址即可。</li>
<li>硬性页缺失：硬性页缺失是指相关的页在页缺失发生时未被加载进内存的情况。</li>
<li>无效页缺失：当程序访问的虚拟地址是不存在于虚拟地址空间内的时候，则发生无效页缺失。</li>
</ul>
</li>
<li>
<p>中断</p>
<p>中断是指计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回现行程序的间断处，继续执行原程序。</p>
</li>
</ol>
<p>缺页中断发生时的事件顺序：</p>
<ul>
<li>硬件陷入内核，在堆栈中保存程序计数器，将当前指令的各种状态信息保存在特殊的 CPU 寄存器中；</li>
<li>保存通用寄存器和其他易失的信息，以免被操作系统破坏；</li>
<li>当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面。通常一个硬件寄存器包含了这一信息，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析这条指令，看看它在缺页中断时正在做什么；</li>
<li>一旦知道了发生缺页中断的虚拟地址，操作系统检查这个地址是否有效，并检查存取与保护是否一致。如果不一致，向进程发出一个信号或杀掉该进程。如果地址有效且没有保护错误发生，系统则检查是否有空闲页框。如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰；</li>
<li>如果选择的页框“脏”了，安排该页写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输结束。无论如何，该页框被标记为忙，以免因为其他原因而被其他进程占用；</li>
<li>一旦页框“干净”后，操作系统查找所需页面在磁盘上的地址，通过磁盘操作将其装入。该页面被装入后，产生缺页中断的进程仍然被挂起，并且如果有其他可运行的用户进程，则选择另一个用户进程运行；</li>
<li>当磁盘中断发生时，表明该页已经被装入，页表已经更新可以反映它的位置，页框也被标记为正常状态；</li>
<li>恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令；</li>
<li>调度引发缺页中断的进程，操作系统返回调用它的汇编语言程序；</li>
<li>该程序恢复寄存器和其他状态信息，返回到用户空间继续执行。</li>
</ul>
<h3 id="10、什么时候会由用户态陷入内核态？">10、什么时候会由用户态陷入内核态？</h3>
<p>a、<strong>系统调用</strong>。b、<strong>异常</strong>。c、<strong>设备中断</strong>。其中，系统调用是主动的，另外两种是被动的。</p>
<h3 id="11、进程有多少种状态？">11、进程有多少种状态？</h3>
<p>进程有五种状态：<strong>创建、就绪、执行、阻塞、终止</strong>。一个进程创建后，被放入队列处于就绪状态，等待操作系统调度执行，执行过程中可能切换到阻塞状态（并发），任务完成后，进程销毁终止。</p>
<p><strong>创建状态</strong><br>
一个应用程序从系统上启动，首先就是进入<strong>创建状态</strong>，需要获取系统资源创建进程管理块（PCB：Process Control Block）完成资源分配。</p>
<p><strong>就绪状态</strong><br>
在<strong>创建状态</strong>完成之后，进程已经准备好，处于<strong>就绪状态</strong>，但是还未获得处理器资源，无法运行。</p>
<p><strong>运行状态</strong><br>
获取处理器资源，被系统调度，<strong>当具有时间片</strong>开始进入<strong>运行状态</strong>。如果进程的时间片用完了就进入<strong>就绪状态</strong>。</p>
<p><strong>阻塞状态</strong><br>
在<strong>运行状态</strong>期间，如果进行了阻塞的操作，如耗时的I/O操作，此时进程暂时无法操作就进入到了<strong>阻塞状态</strong>，在这些操作完成后就进入<strong>就绪状态</strong>。等待再次获取处理器资源，被系统调度，<strong>当具有时间片</strong>就进入<strong>运行状态</strong>。</p>
<p><strong>终止状态</strong><br>
进程结束或者被系统终止，进入<strong>终止状态</strong></p>
<p><strong>相互转换如图</strong>：</p>
<img src="https://uploadfiles.nowcoder.com/images/20210519/59_1621415581213/5BFD28FE4117D38D3292FFF7644D2DB8" alt="image-20201221105446608" style="zoom: 33%;" />
<h3 id="12、Linux-下如何查看端口被哪个进程占用？">12、Linux  下如何查看端口被哪个进程占用？</h3>
<p>本文介绍linux如何查看端口被哪个进程占用的方法：</p>
<p>1、lsof -i:端口号</p>
<p>2、netstat -tunlp|grep 端口号</p>
<p>都可以查看指定端口被哪个进程占用的情况</p>
<p><strong>【步骤一】lsof -i</strong></p>
<p>lsof -i 用以显示符合条件的进程情况，lsof(list open files)是一个列出当前系统打开文件的工具。<strong>以root用户来执行lsof -i命令</strong>，如下图</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091639114.png" style="zoom: 80%;" />
<p><strong>【步骤二】lsof -i:端口号</strong></p>
<p>lsof -i:端口号，用于查看某一端口的占用情况，比如查看22号端口使用情况，lsof -i:22，如下图</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091640294.png" style="zoom:67%;" />
<p><strong>【步骤三】netstat -tunlp</strong></p>
<p>netstat -tunlp用于显示tcp，udp的端口和进程等相关情况，如下图</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091640252.png" style="zoom:67%;" />
<p><strong>【步骤四】netstat -tunlp|grep 端口号</strong></p>
<p>netstat -tunlp|grep 端口号，用于查看指定端口号的进程情况，如查看22端口的情况，netstat -tunlp|grep 22，如下图</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091639109.png" style="zoom:67%;" />
<h3 id="13、操作系统中，虚拟地址与物理地址之间如何映射？">13、操作系统中，虚拟地址与物理地址之间如何映射？</h3>
<p><strong>操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表。</strong> 页表中的每一项都记录了这个页的基地址。</p>
<p><strong>三级页表转换方法：（两步）</strong></p>
<ol>
<li>
<p>逻辑地址转线性地址：段起始地址+段内偏移地址=线性地址</p>
</li>
<li>
<p>线性地址转物理地址：</p>
<p>（1）每一个32位的线性地址被划分为三部分：页目录索引（DIRECTORY，10位）、页表索引（TABLE，10位）、页内偏移（OFFSET，12位）<br>
（2）从<strong>cr3</strong>中取出进程的页目录地址（操作系统调用进程时，这个地址被装入寄存器中）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">页目录地址 + 页目录索引 = 页表地址</span><br><span class="line">页表地址 + 页表索引 = 页地址</span><br><span class="line">页地址 + 页内偏移 = 物理地址</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://static.nowcoder.com/images/activity/2021jxy/c/assert/5.png" alt="IMG_256"></p>
<p>按照以上两步法，就完成了一个三级页表从虚拟地址到物理地址的转换。</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091643940.png" alt="image-20220309164357801" style="zoom: 67%;" />
<h3 id="14、简述-Linux-系统态与用户态，什么时候会进入系统态？">14、简述 Linux 系统态与用户态，什么时候会进入系统态？</h3>
<ol>
<li>
<p><strong>内核态与用户态</strong>：<strong>内核态</strong>（系统态）与<strong>用户态</strong>是操作系统的两种运行级别。内核态拥有最高权限，可以访问所有系统指令；用户态则只能访问一部分指令。</p>
</li>
<li>
<p><strong>什么时候进入内核态</strong>：共有三种方式：a、<strong>系统调用</strong>。b、<strong>异常</strong>。c、<strong>设备中断</strong>。其中，系统调用是主动的，另外两种是被动的。</p>
</li>
<li>
<p><strong>为什么区分内核态与用户态</strong>：是为了区别执行 特权指令 与非特权指令，出于安全的考虑</p>
<p>在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。</p>
</li>
</ol>
<p>一、用户态和核心态的概念</p>
<p>用户态：</p>
<blockquote>
<p>内核态与用户态是操作系统的两种运行级别,当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；</p>
</blockquote>
<p>核心态：</p>
<blockquote>
<p>当程序运行在0级特权级上时，就可以称之为运行在内核态。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。</p>
</blockquote>
<p>两种状态的主要区别</p>
<blockquote>
<p>处于用户态执行时，进程所能访问的<strong>内存空间和对象</strong>受到限制，其所处于占有的处理机是可被抢占的 ； 而处于核心态执行中的进程，则能访问所有的内存空间和对象，且所占有的处理机是不允许被抢占的。</p>
</blockquote>
<p>为啥要区别</p>
<blockquote>
<p>是为了区别执行 <strong>特权指令 与非特权指令</strong></p>
<p>在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：<strong>清内存、设置时钟</strong>等。如果所有的程序都能使用这些指令，那么你的系统一天死机n回就不足为奇了。所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。</p>
</blockquote>
<p>二、两者之间如何切换</p>
<p>系统调用</p>
<blockquote>
<p>这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
</blockquote>
<p>中断</p>
<blockquote>
<p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
</blockquote>
<p>异常</p>
<blockquote>
<p>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091654105.png" alt="image-20220309165456011"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091653965.jpg" alt="未标题-1"></p>
<h3 id="15、简述同步与异步的区别，阻塞与非阻塞的区别">15、简述同步与异步的区别，阻塞与非阻塞的区别</h3>
<h4 id="IO操作">IO操作</h4>
<p>IO分两阶段（一旦拿到数据后就变成了数据操作，不再是IO）：</p>
<ol>
<li>数据准备阶段</li>
<li>内核空间复制数据到用户进程缓冲区（用户空间）阶段</li>
</ol>
<p>在操作系统中，程序运行的空间分为内核空间和用户空间。应用程序都是运行在用户空间的，所以它们能操作的数据也都在用户空间。</p>
<p>阻塞IO和非阻塞IO的区别在于第一步发起IO请求是否会被阻塞：</p>
<ul>
<li>如果阻塞直到完成那么就是传统的阻塞IO</li>
<li>如果不阻塞，那么就是非阻塞IO</li>
</ul>
<p>一般来讲：阻塞IO模型、非阻塞IO模型、IO复用模型(select/poll/epoll)、信号驱动IO模型都属于同步IO，因为阶段2是阻塞的(尽管时间很短)。</p>
<p>同步IO和异步IO的区别就在于第二个步骤是否阻塞：<br>
如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO</p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/1748170/201909/1748170-20190906210650873-272348693.png"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091837257.png" style="zoom: 67%;" /></a></p>
<h4 id="同步和异步IO-阻塞和非阻塞IO">同步和异步IO 阻塞和非阻塞IO</h4>
<p>同步和异步IO的概念：</p>
<ul>
<li>同步是用户线程发起I/O请求后需要等待或者轮询内核I/O操作完成后才能继续执行</li>
<li>异步是用户线程发起I/O请求后仍需要继续执行，当内核I/O操作完成后会通知用户线程，或者调用用户线程注册的回调函数</li>
</ul>
<p>阻塞和非阻塞IO的概念：</p>
<ul>
<li>阻塞是指I/O操作需要彻底完成后才能返回用户空间</li>
<li>非阻塞是指I/O操作被调用后立即返回一个状态值，无需等I/O操作彻底完成</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/1748170/201909/1748170-20190906211421376-2097741161.png"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091716530.png" style="zoom: 67%;" /></a></p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/1748170/201909/1748170-20190906211429619-939802087.png"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091716345.png" style="zoom:67%;" /></a></p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/1748170/201909/1748170-20190906211436023-1996044746.png"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091716961.png" style="zoom:67%;" /></a></p>
<h4 id="同步与异步（线程间调用）">同步与异步（线程间调用）</h4>
<p>同步与异步是对应于调用者与被调用者，它们是线程之间的关系，两个线程之间要么是同步的，要么是异步的</p>
<p>同步操作时，调用者需要等待被调用者返回结果，才会进行下一步操作</p>
<p>而异步则相反，调用者不需要等待被调用者返回调用，即可进行下一步操作，被调用者通常依靠事件、回调等机制来通知调用者结果</p>
<h4 id="阻塞与非阻塞（线程内调用）">阻塞与非阻塞（线程内调用）</h4>
<p>阻塞与非阻塞是对同一个线程来说的，在某个时刻，线程要么处于阻塞，要么处于非阻塞</p>
<p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态：</p>
<ul>
<li>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</li>
<li>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li>
</ul>
<h4 id="同步与异步调用-线程-通信">同步与异步调用/线程/通信</h4>
<p>同步就是两种东西通过一种机制实现步调一致，异步是两种东西不必步调一致</p>
<p>一、同步调用与异步调用：</p>
<p>在用在调用场景中，无非是对调用结果的不同处理。</p>
<p>同步调用就是调用一但返回，就能知道结果，而异步是返回时不一定知道结果，还得通过其他机制来获知结果，如：</p>
<p>a. 状态 b. 通知 c. 回调函数</p>
<p>二、同步线程与异步线程：</p>
<ul>
<li>同步线程：即两个线程步调要一致，其中一个线程可能要阻塞等待另外一个线程的运行，要相互协商。快的阻塞一下等到慢的步调一致。</li>
<li>异步线程：步调不用一致，各自按各自的步调运行，不受另一个线程的影响。</li>
</ul>
<p>三、同步通信与异步通信：</p>
<p>同步和异步是指：发送方和接收方是否协调步调一致</p>
<p>同步通信是指：发送方和接收方通过一定机制，实现收发步调协调。<br>
如：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式</p>
<p>异步通信是指：发送方的发送不管接收方的接收状态。<br>
如：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</p>
<p>阻塞可以是实现同步的一种手段！例如两个东西需要同步，一旦出现不同步情况，我就阻塞快的一方，使双方达到同步。</p>
<p>同步是两个对象之间的关系，而阻塞是一个对象的状态。</p>
<h4 id="四种组合方式">四种组合方式</h4>
<p>同步阻塞方式：</p>
<ul>
<li>发送方发送请求之后一直等待响应。</li>
<li>接收方处理请求时进行的IO操作如果不能马上等到返回结果，就一直等到返回结果后，才响应发送方，期间不能进行其他工作。</li>
</ul>
<p>同步非阻塞方式：</p>
<ul>
<li>发送方发送请求之后，一直等待响应。</li>
<li>接受方处理请求时进行的IO操作如果不能马上的得到结果，就立即返回，取做其他事情。</li>
<li>但是由于没有得到请求处理结果，不响应发送方，发送方一直等待。</li>
<li>当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方，发送方才进入下一次请求过程。（实际不应用）</li>
</ul>
<p>异步阻塞方式：</p>
<ul>
<li>发送方向接收方请求后，不等待响应，可以继续其他工作。</li>
<li>接收方处理请求时进行IO操作如果不能马上得到结果，就一直等到返回结果后，才响应发送方，期间不能进行其他操作。 （实际不应用）</li>
</ul>
<p>异步非阻塞方式：</p>
<ul>
<li>发送方向接收方请求后，不等待响应，可以继续其他工作。</li>
<li>接收方处理请求时进行IO操作如果不能马上得到结果，也不等待，而是马上返回去做其他事情。</li>
<li>当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方。（效率最高）</li>
</ul>
<h3 id="16、Linux-中虚拟内存和物理内存有什么区别？有什么优点？">16、Linux 中虚拟内存和物理内存有什么区别？有什么优点？</h3>
<ol>
<li>
<p><strong>物理内存</strong>：物理内存有四个层次，分别是寄存器、高速缓存、主存、磁盘。</p>
<p>寄存器：速度最快、量少、价格贵。</p>
<p>高速缓存：次之。</p>
<p>主存：再次之。</p>
<p>磁盘：速度最慢、量多、价格便宜。</p>
<p><img src="https://static.nowcoder.com/images/activity/2021jxy/c/assert/1.png" alt="image-20201219105446608"></p>
<p>操作系统会对物理内存进行管理，有一个部分称为<strong>内存管理器(memory manager)</strong>，它的主要工作是有效的管理内存，记录哪些内存是正在使用的，在进程需要时分配内存以及在进程完成时回收内存。</p>
</li>
<li>
<p><strong>虚拟内存</strong>：操作系统为每一个进程分配一个独立的地址空间，但是虚拟内存。虚拟内存与物理内存存在映射关系，通过页表寻址完成虚拟地址和物理地址的转换。</p>
</li>
<li>
<p><strong>为什么要用虚拟内存</strong>：因为早期的内存分配方法存在以下问题：</p>
<p>（1）进程地址空间不隔离。会导致数据被随意修改。</p>
<p>（2）内存使用效率低。</p>
<p>（3）程序运行的地址不确定。操作系统随机为进程分配内存空间，所以程序运行的地址是不确定的。</p>
</li>
<li>
<p><strong>使用虚拟内存的好处</strong>：</p>
<p>（1）<strong>扩大地址空间</strong>。每个进程独占一个4G空间，虽然真实物理内存没那么多。</p>
<p>（2）<strong>内存保护</strong>：防止不同进程对物理内存的争夺和践踏，可以对特定内存地址提供写保护，防止恶意篡改。每个进程有独立的地址空间 (进程间的安全)</p>
<p>（3）可以实现<strong>内存共享</strong>，方便进程通信。</p>
<p>（4）可以<strong>避免内存碎片</strong>，虽然物理内存可能不连续，但映射到虚拟内存上可以连续。</p>
</li>
<li>
<p><strong>使用虚拟内存的缺点</strong>：</p>
<p>（1）虚拟内存需要额外构建数据结构，占用空间。</p>
<p>（2）虚拟地址到物理地址的转换，增加了执行时间。</p>
<p>（3）页面换入换出耗时。</p>
<p>（4）一页如果只有一部分数据，浪费内存。</p>
</li>
</ol>
<h3 id="17、简述-Linux-零拷贝的原理">17、简述 Linux 零拷贝的原理</h3>
<ol>
<li>
<p><strong>什么是零拷贝</strong>：</p>
<p>所谓「零拷贝」描述的是计算机操作系统当中，CPU不执行将数据从一个内存区域，拷贝到另外一个内存区域的任务。通过网络传输文件时，这样通常可以节省 CPU 周期和内存带宽。</p>
</li>
<li>
<p><strong>零拷贝的好处</strong>：</p>
<p>（1）节省了 CPU 周期，空出的 CPU 可以完成更多其他的任务</p>
<p>（2）减少了内存区域之间数据拷贝，节省内存带宽</p>
<p>（3）减少用户态和内核态之间数据拷贝，提升数据传输效率</p>
<p>（4）应用零拷贝技术，减少用户态和内核态之间的上下文切换</p>
</li>
<li>
<p><strong>零拷贝原理</strong>：</p>
<p>在传统 IO 中，用户态空间与内核态空间之间的复制是完全不必要的，因为用户态空间仅仅起到了一种数据转存媒介的作用，除此之外没有做任何事情。</p>
<p><strong>（1）Linux 提供了 sendfile() 用来减少我们的数据拷贝和上下文切换次数。</strong></p>
<p>过程如图：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202281122653.png" alt="image-20201221105446608" style="zoom: 33%;" />
<p>a. 发起 sendfile() 系统调用，操作系统由用户态空间切换到内核态空间（第一次上下文切换）</p>
<p>b. 通过 DMA 引擎将数据从磁盘拷贝到内核态空间的输入的 socket 缓冲区中（第一次拷贝）</p>
<p>c. 将数据从内核空间拷贝到与之关联的 socket 缓冲区（第二次拷贝）</p>
<p>d. 将 socket 缓冲区的数据拷贝到协议引擎中（第三次拷贝）</p>
<p>e. sendfile() 系统调用结束，操作系统由用户态空间切换到内核态空间（第二次上下文切换）</p>
<p>根据以上过程，一共有 2 次的上下文切换，3 次的 I/O 拷贝。我们看到从用户空间到内核空间并没有出现数据拷贝，<strong>从操作系统角度来看，这个就是零拷贝</strong>。内核空间出现了复制的原因: 通常的硬件在通过DMA访问时期望的是连续的内存空间。</p>
<p>（2）<strong>mmap 数据零拷贝原理</strong></p>
<p><strong>如果需要对数据做操作，Linux 提供了 mmap 零拷贝来实现。</strong></p>
</li>
</ol>
<h3 id="19、多线程和多进程的区别是什么？">19、多线程和多进程的区别是什么？</h3>
<p>多进程和多线程的主要区别是：</p>
<ol>
<li>线程是进程的子集，一个进程可能由多个线程组成；</li>
<li>多进程的数据是分开的，共享复杂，需要用IPC，但同步简单；</li>
<li>多线程共享进程数据，共享简单，但同步复杂。</li>
</ol>
<p><strong>对比</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">对比维度</th>
<th style="text-align:center">多进程</th>
<th style="text-align:center">多线程</th>
<th>总结</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数据共享、同步</td>
<td style="text-align:center">数据共享复杂，需要用 IPC；数据是分开的，同步简单</td>
<td style="text-align:center">因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td>
<td>各有优势</td>
</tr>
<tr>
<td style="text-align:center">内存、CPU</td>
<td style="text-align:center">占用内存多，切换复杂，CPU 利用率低</td>
<td style="text-align:center">占用内存少，切换简单，CPU 利用率高</td>
<td>线程占优</td>
</tr>
<tr>
<td style="text-align:center">创建销毁、切换</td>
<td style="text-align:center">创建销毁、切换复杂，速度慢</td>
<td style="text-align:center">创建销毁、切换简单，速度很快</td>
<td>线程占优</td>
</tr>
<tr>
<td style="text-align:center">编程、调试</td>
<td style="text-align:center">编程简单，调试简单</td>
<td style="text-align:center">编程复杂，调试复杂</td>
<td>进程占优</td>
</tr>
<tr>
<td style="text-align:center">可靠性</td>
<td style="text-align:center">进程间不会互相影响</td>
<td style="text-align:center">一个线程挂掉将导致整个进程挂掉</td>
<td>进程占优</td>
</tr>
<tr>
<td style="text-align:center">分布式</td>
<td style="text-align:center">适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td>
<td style="text-align:center">适应于多核分布式</td>
<td>进程占优</td>
</tr>
</tbody>
</table>
<p><strong>优劣</strong></p>
<table>
<thead>
<tr>
<th>优劣</th>
<th>多进程</th>
<th>多线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>编程、调试简单，可靠性较高</td>
<td>创建、销毁、切换速度快，内存、资源占用小</td>
</tr>
<tr>
<td>缺点</td>
<td>创建、销毁、切换速度慢，内存、资源占用大</td>
<td>编程、调试复杂，可靠性较差</td>
</tr>
</tbody>
</table>
<p><strong>选择</strong></p>
<ul>
<li>需要频繁创建销毁的优先用线程</li>
<li>需要进行大量计算的优先使用线程</li>
<li>强相关的处理用线程，弱相关的处理用进程</li>
<li>可能要扩展到多机分布的用进程，多核分布的用线程</li>
</ul>
<h3 id="20、BIO、NIO-有什么区别？怎么判断写文件时-Buffer-已经写满？简述-Linux-的-IO-模型">20、BIO、NIO 有什么区别？怎么判断写文件时 Buffer 已经写满？简述 Linux 的 IO 模型</h3>
<p><strong>BIO（Blocking I/O）</strong>：<strong>阻塞IO</strong>。调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。</p>
<p><strong>NIO（New I/O）</strong>：<strong>同时支持阻塞与非阻塞模式</strong>，NIO的做法是叫一个线程不断的轮询每个IO的状态，看看是否有IO的状态发生了改变，从而进行下一步的操作。</p>
<p>阻塞型：阻塞</p>
<p>非阻塞：返回 EWOULBLOCK</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091837627.png" style="zoom: 67%;" />
<ol>
<li>阻塞IO：调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。</li>
<li>非阻塞IO：非阻塞等待，每隔一段时间就去检查IO事件是否就绪。没有就绪就可以做其他事情。</li>
<li>信号驱动IO：Linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO信号，然后处理IO事件。</li>
<li>IO多路复用：Linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检查。知道有数据可读或可写时，才真正调用IO操作函数。</li>
<li>异步IO：Linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。用户可以直接去使用数据。</li>
</ol>
<p><strong>解析</strong></p>
<p>前四种模型–阻塞IO、非阻塞IO、多路复用IO和信号驱动IO都属于<strong>同步模式</strong>，因为其中真正的IO操作(函数)都将会阻塞进程，只有<strong>异步IO模型</strong>真正实现了IO操作的异步性。</p>
<p><strong>异步和同步的区别就在于</strong>，异步是内核将数据拷贝到用户区，不需要用户再自己接收数据，直接使用就可以了，而同步是内核通知用户数据到了，然后用户自己调用相应函数去接收数据。</p>
<h3 id="21、简述自旋锁与互斥锁的使用场景">21、简述自旋锁与互斥锁的使用场景</h3>
<ol>
<li>
<p><strong>互斥锁</strong>用于临界区持锁时间比较长的操作，比如下面这些情况都可以考虑</p>
<ul>
<li>临界区有IO操作</li>
<li>临界区代码复杂或者循环量大</li>
<li>临界区竞争非常激烈</li>
<li>单核处理器</li>
</ul>
</li>
<li>
<p><strong>自旋锁就</strong>主要用在临界区持锁时间非常短且CPU资源不紧张的情况下。</p>
</li>
</ol>
<h3 id="22、简述-mmap-的使用场景以及原理">22、简述 mmap 的使用场景以及原理</h3>
<p><strong>原理</strong>：<strong>mmap是一种内存映射文件的方法</strong>，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read, write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图：</p>
<img src="https://uploadfiles.nowcoder.com/images/20210519/59_1621415737288/7F7B2DE3C7D83F7F31D18D49C8BBCF01" alt="image-20201221105446608" style="zoom:50%;" />
<p><strong>使用场景</strong>：</p>
<ol>
<li>对同一块区域频繁读写操作；</li>
<li>可用于实现用户空间和内核空间的高效交互</li>
<li>可提供进程间共享内存及相互通信</li>
<li>可实现高效的大规模数据传输。</li>
</ol>
<h3 id="23、简述操作系统中-malloc-的实现原理">23、简述操作系统中 malloc 的实现原理</h3>
<p>**malloc底层实现：**当开辟的空间小于 128K 时，调用 brk() 函数；当开辟的空间大于 128K 时，调用 mmap()。</p>
<p>malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。</p>
<h4 id="结论">结论</h4>
<p>1）当开辟的空间小于 128K 时，调用 brk（）函数，malloc 的底层实现是系统调用函数 brk（），其主要移动指针 _enddata(此时的 _enddata 指的是 Linux 地址空间中堆段的末尾地址，不是数据段的末尾地址)</p>
<p>2）当开辟的空间大于 128K 时，mmap（）系统调用函数来在虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空间来开辟。</p>
<h4 id="具体内容">具体内容</h4>
<p>当一个进程发生缺页中断的时候，进程会陷入核心态，执行以下操作：</p>
<p>1）检查要访问的虚拟地址是否合法</p>
<p>2）查找/分配一个物理页</p>
<p>3）填充物理页内容（读取磁盘，或者直接置0，或者什么都不做）</p>
<p>4）建立映射关系（虚拟地址到物理地址的映射关系）</p>
<p>5）重复执行发生缺页中断的那条指令</p>
<p>如果第3布，需要读取磁盘，那么这次缺页就是 majfit(major fault：大错误),否则就是 minflt(minor fault：小错误)</p>
<h4 id="内存分配的原理">内存分配的原理</h4>
<p>从操作系统角度看，进程分配内存有两种方式，分别由两个系统调用完成：brk 和 mmap (不考虑共享内存)</p>
<p>1）brk 是将数据段（.data）的最高地址指针 _edata 往高地址推</p>
<p>2）mmap 是在进程的虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空闲的虚拟内存。</p>
<p>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</p>
<h4 id="具体分配过程">具体分配过程</h4>
<h5 id="情况一：malloc-小于-128K-的内存，使用-brk-分配">情况一：malloc 小于 128K 的内存，使用 brk 分配</h5>
<p>将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：</p>
<img src="https://img2018.cnblogs.com/blog/1370746/201905/1370746-20190504160831623-27874302.png" style="zoom: 67%;" />
<p>1，进程启动的时候，其（虚拟）内存空间的初始布局如图1所示</p>
<p>2，进程调用A=malloc(30K)以后，内存空间如图2：</p>
<p>malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配</p>
<p><strong>你可能会问</strong>：难道这样就完成内存分配了？</p>
<p>事实是：_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。<strong>也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。</strong></p>
<p>3，进程调用B=malloc(40K)以后，内存空间如图3</p>
<h5 id="情况二：malloc-大于-128K-的内存，使用-mmap-分配（munmap-释放）">情况二：malloc 大于 128K 的内存，使用 mmap 分配（munmap 释放）</h5>
<img src="https://img2018.cnblogs.com/blog/1370746/201905/1370746-20190504161429805-1373672610.png" style="zoom:67%;" />
<p>4，进程调用C=malloc(200K)以后，内存空间如图4</p>
<p>默认情况下，<strong>malloc函数分配内存，如果请求内存大于128K（可由M_MMAP_THRESHOLD选项调节），那就不是去推_edata指针了，而是利用mmap系统调用，从堆和栈的中间分配一块虚拟内存</strong></p>
<p>这样子做主要是因为:</p>
<p><strong>brk分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，因为只有一个_edata 指针，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放。</strong></p>
<p>当然，还有其它的好处，也有坏处，再具体下去，有兴趣的同学可以去看glibc里面malloc的代码了。</p>
<p>5，进程调用D=malloc(100K)以后，内存空间如图5</p>
<p>6，进程调用free©以后，C对应的虚拟内存和物理内存一起释放</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091855880.png" style="zoom:67%;" />
<p>7，进程调用free(B)以后，如图7所示</p>
<p><strong>B对应的虚拟内存和物理内存都没有释放，因为只有一个_edata指针，如果往回推，那么D这块内存怎么办呢？当然，B这块内存，是可以重用的，如果这个时候再来一个40K的请求，那么malloc很可能就把B这块内存返回回去了</strong></p>
<p>8，进程调用free(D)以后，如图8所示</p>
<p><strong>B和D连接起来，变成一块140K的空闲内存</strong></p>
<p>9，默认情况下：</p>
<p>**当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。**在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩，变成图9所示</p>
<h3 id="24、Linux-下如何排查-CPU-以及内存占用过多？">24、Linux 下如何排查 CPU 以及内存占用过多？</h3>
<ul>
<li>使用 <code>top</code> 命令定位异常进程</li>
<li>使用 <code>top -H -p 进程号</code> 查看异常线程</li>
</ul>
<p><strong>top 指令定位CPU/内存使用率过高</strong></p>
<p>执行 top 命令后按 <strong>M</strong>，根据驻留内存大小进行排序，查看 “RES” 及 “SHR” 列是否有进程占用内存过高。按 P，以 CPU 占用率大小的顺序排列进程列表，查看是否有进程占用cpu过高。</p>
<p>如果有异常进程占用了大量 CPU 或内存资源，记录需要终止的进程 PID，输入k，再输入需要终止进程的 PID ，按 Enter。</p>
<p>另外说明一下，top 运行中可以通过 top 的内部命令对进程的显示方式进行控制，最常用的是M和P。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203091903898.webp" alt="img"></p>
<h3 id="25、两个线程交替打印一个共享变量">25、两个线程交替打印一个共享变量</h3>
<h3 id="26、进程通信中的管道实现原理是什么？">26、进程通信中的管道实现原理是什么？</h3>
<p>操作系统在内核中开辟一块<strong>缓冲区</strong>（称为<strong>管道</strong>）用于通信。<strong>管道</strong>是一种两个进程间进行<strong>单向通信</strong>的机制。因为这种单向性，管道又称为半双工管道，所以其使用是有一定的局限性的。半双工是指数据只能由一个进程流向另一个进程（一个管道负责读，一个管道负责写）；如果是全双工通信，需要建立两个管道。管道分为无名管道和命名管道，无名管道只能用于具有亲缘关系的进程直接的通信（父子进程或者兄弟进程），可以看作一种特殊的文件，<strong>管道本质是一种文件</strong>；命名管道可以允许无亲缘关系进程间的通信。</p>
<p>管道原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">＃include &lt;unistd.h&gt;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;  </span><br></pre></td></tr></table></figure>
<p>pipe()函数创建的管道处于一个进程中间，因此一个进程在由 pipe()创建管道后，一般再使用fork() 建立一个子进程，然后通过管道实现父子进程间的通信。管道两端可分别用描述字fd[0]以及fd[1]来描述。注意管道的两端的任务是固定的，即一端只能用于读，由描述字fd[0]表示，称其为管道读端；另 一端则只能用于写，由描述字fd[1]来表示，称其为管道写端。如果试图从管道写端读取数据，或者向管道读端写入数据都将发生错误。一般文件的 I/O 函数都可以用于管道，如close()、read()、write()等。</p>
<p><strong>具体步骤</strong>如下：</p>
<ol>
<li>父进程调用pipe开辟管道,得到两个文件描述符指向管道的两端。</li>
<li>父进程调用fork创建子进程,那么子进程也有两个文件描述符指向同一管道。</li>
<li>父进程关闭管道读端,子进程关闭管道写端。父进程可以往管道里写,子进程可以从管道里读,管道是用环形队列实现的,数据从写端流入从读端流出,这样就实现了进程间通信。</li>
</ol>
<p>给出实现的代码，实现父子进程间的管道通信</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT  0     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTPUT 1    </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    <span class="comment">//创建管道    </span></span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];    </span><br><span class="line">    <span class="built_in">pipe</span>(fd);    </span><br><span class="line">    <span class="comment">//创建子进程    </span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();    </span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error!\n&quot;</span>);    </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;<span class="comment">//执行子进程  </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process is starting...\n&quot;</span>);  </span><br><span class="line">        <span class="comment">//子进程向父进程写数据，关闭管道的读端   </span></span><br><span class="line">        <span class="built_in">close</span>(fd[INPUT]);  </span><br><span class="line">        <span class="built_in">write</span>(fd[OUTPUT], <span class="string">&quot;hello douya!&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;hello douya!&quot;</span>));  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//执行父进程  </span></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Parent process is starting......\n&quot;</span>);  </span><br><span class="line">        <span class="comment">//父进程从管道读取子进程写的数据 ，关闭管道的写端    </span></span><br><span class="line">        <span class="built_in">close</span>(fd[OUTPUT]);    </span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">255</span>];  </span><br><span class="line">        <span class="keyword">int</span> output = <span class="built_in">read</span>(fd[INPUT], buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf));  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d bytes of data from child process: %s\n&quot;</span>, output, buf);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<h3 id="27、Linux-下如何查看-CPU-荷载，正在运行的进程？">27、Linux 下如何查看 CPU 荷载，正在运行的进程？</h3>
<ol>
<li>查看进程运行状态的指令**：ps命令。“<strong>ps -aux | grep PID</strong>”，用来查看某PID进程状态</li>
<li><strong>查看内存使用情况的指令</strong>：free命令。“<strong>free -m</strong>”，命令查看内存使用情况。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//ps使用示例</span><br><span class="line">//显示当前所有进程  </span><br><span class="line">ps -A  </span><br><span class="line">//与grep联用查找某进程  </span><br><span class="line">ps -aux | grep apache  </span><br><span class="line"></span><br><span class="line">//查看进程运行状态、查看内存使用情况的指令均可使用top指令。</span><br><span class="line">top</span><br></pre></td></tr></table></figure>
<h3 id="28、共享内存是如何实现的？">28、共享内存是如何实现的？</h3>
<h3 id="29、如何调试服务器内存占用过高的问题？">29、如何调试服务器内存占用过高的问题？</h3>
<h3 id="30、Linux-如何查看实时的滚动日志？">30、Linux 如何查看实时的滚动日志？</h3>
<h3 id="31、为什么进程切换慢，线程切换快？">31、为什么进程切换慢，线程切换快？</h3>
<h3 id="32、简述创建进程的流程">32、简述创建进程的流程</h3>
<h3 id="33、简述-Linux-虚拟内存的页面置换算法">33、简述 Linux 虚拟内存的页面置换算法</h3>
<h3 id="34、简述-CPU-L1-L2-L3-多级缓存的基本作用">34、简述 CPU  L1, L2, L3 多级缓存的基本作用</h3>
<h3 id="35、malloc-创建的对象在堆还是栈中？">35、malloc 创建的对象在堆还是栈中？</h3>
<h3 id="36、进程空间从高位到低位都有些什么？">36、进程空间从高位到低位都有些什么？</h3>
<h3 id="37、什么情况下，进程会进行切换？">37、什么情况下，进程会进行切换？</h3>
<h3 id="39、简述-traceroute-命令的原理">39、简述 traceroute 命令的原理</h3>
<h3 id="40、Linux-页大小是多少？">40、Linux 页大小是多少？</h3>
<h3 id="41、信号量是如何实现的？">41、信号量是如何实现的？</h3>
<h2 id="牛客-3">牛客</h2>
<h3 id="1、Linux中查看进程运行状态的指令、查看内存使用情况的指令、tar解压文件的参数。">1、Linux中查看进程运行状态的指令、查看内存使用情况的指令、tar解压文件的参数。</h3>
<ol>
<li>
<p><strong>查看进程运行状态的指令</strong>：ps命令。“<strong>ps -aux | grep PID</strong>”，用来查看某PID进程状态</p>
</li>
<li>
<p><strong>查看内存使用情况的指令</strong>：free命令。“<strong>free -m</strong>”，命令查看内存使用情况。</p>
</li>
<li>
<p><strong>tar解压文件的参数</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">五个命令中必选一个</span><br><span class="line">     -c: 建立压缩档案</span><br><span class="line">     -x：解压</span><br><span class="line">     -t：查看内容</span><br><span class="line">     -r：向压缩归档文件末尾追加文件</span><br><span class="line">     -u：更新原压缩包中的文件</span><br><span class="line">这几个参数是可选的</span><br><span class="line">     -z：有gzip属性的</span><br><span class="line">     -j：有bz2属性的</span><br><span class="line">     -Z：有compress属性的</span><br><span class="line">     -v：显示所有过程</span><br><span class="line">     -O：将文件解开到标准输出</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//ps使用示例</span><br><span class="line">//显示当前所有进程  </span><br><span class="line">ps -A  </span><br><span class="line">//与grep联用查找某进程  </span><br><span class="line">ps -aux | grep apache  </span><br><span class="line"></span><br><span class="line">//查看进程运行状态、查看内存使用情况的指令均可使用top指令。</span><br><span class="line">top</span><br></pre></td></tr></table></figure>
<h3 id="2、文件权限怎么修改">2、文件权限怎么修改</h3>
<p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限</p>
<p>修改权限指令：<strong>chmod</strong></p>
<p><strong>解析</strong></p>
<p>举例：文件的权限字符为 -rwxrwxrwx 时，这九个权限是三个三个一组。其中，我们可以使用数字来代表各个权限。</p>
<p>各权限的分数对照如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">r</th>
<th style="text-align:center">w</th>
<th style="text-align:center">x</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，</p>
<p>例如当权限为： [-rwxrwx—] ，则分数是：</p>
<p>owner = rwx = 4+2+1 = 7</p>
<p>group = rwx = 4+2+1 = 7</p>
<p>others= — = 0+0+0 = 0</p>
<p>所以我们设定权限的变更时，该文件的权限数字就是770！变更权限的指令chmod的语法是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># chmod [-R] xyz 文件或目录 </span></span><br><span class="line">选项与参数： </span><br><span class="line">xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。 </span><br><span class="line">-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</span><br><span class="line"></span><br><span class="line"><span class="comment"># chmod 770 douya.c //即修改douya.c文件的权限为770</span></span><br></pre></td></tr></table></figure>
<h3 id="3、常用的Linux命令">3、常用的Linux命令</h3>
<ol>
<li>
<p>cd命令：用于切换当前目录</p>
</li>
<li>
<p>ls命令：查看当前文件与目录</p>
</li>
<li>
<p>grep命令：该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工。</p>
</li>
<li>
<p>cp命令：复制命令</p>
</li>
<li>
<p>mv命令：移动文件或文件夹命令</p>
</li>
<li>
<p>rm命令：删除文件或文件夹命令</p>
</li>
<li>
<p>ps命令：查看进程情况</p>
</li>
<li>
<p>kill命令：向进程发送终止信号</p>
</li>
<li>
<p>tar命令：对文件进行打包，调用gzip或bzip对文件进行压缩或解压</p>
</li>
<li>
<p>cat命令：查看文件内容，与less、more功能相似</p>
</li>
<li>
<p>top命令：可以查看操作系统的信息，如进程、CPU占用率、内存信息等</p>
</li>
<li>
<p>pwd命令：命令用于显示工作目录。</p>
</li>
</ol>
<h3 id="4、如何以root权限运行某个程序。">4、如何以root权限运行某个程序。</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chown root app（文件名）</span><br><span class="line">sudo chmod u+s app（文件名）</span><br></pre></td></tr></table></figure>
<h3 id="5、软链接和硬链接的区别。">5、软链接和硬链接的区别。</h3>
<ol>
<li>
<p><strong>定义不同</strong></p>
<p>软链接又叫符号链接，这个文件包含了另一个文件的路径名。可以是任意文件或目录，可以链接不同文件系统的文件。</p>
<p>硬链接就是一个文件的一个或多个文件名。把文件名和计算机文件系统使用的节点号链接起来。因此我们可以用多个文件名与同一个文件进行链接，这些文件名可以在同一目录或不同目录。</p>
</li>
<li>
<p><strong>限制不同</strong></p>
<p>硬链接只能对已存在的文件进行创建，不能交叉文件系统进行硬链接的创建；</p>
<p>软链接可对不存在的文件或目录创建软链接；可交叉文件系统；</p>
</li>
<li>
<p><strong>创建方式不同</strong></p>
<p>硬链接不能对目录进行创建，只可对文件创建；</p>
<p>软链接可对文件或目录创建；</p>
</li>
<li>
<p><strong>影响不同</strong></p>
<p>删除一个硬链接文件并不影响其他有相同 inode 号的文件。</p>
<p>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。</p>
</li>
</ol>
<h3 id="6、静态库和动态库怎么制作及如何使用，区别是什么。">6、静态库和动态库怎么制作及如何使用，区别是什么。</h3>
<p><strong>静态库的制作：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc  hello.c  -c //这样就生成hello.o目标文件</span><br><span class="line"></span><br><span class="line">ar rcs libhello.a  hello.o//生成libhello.a静态库</span><br></pre></td></tr></table></figure>
<p><strong>静态库的使用：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -lhello -o staticLibrary//main.c和hello静态库链接，生成staticLibrary执行文件</span><br><span class="line">/*</span><br><span class="line">main.c：  是指main主函数</span><br><span class="line">-lhello： 是我们生成的.a 文件砍头去尾（lib不要 .a也不要）前面加-l</span><br><span class="line">-L：      是指告诉gcc编译器先从-L指定的路径去找静态库，默认是从/usr/lib/ 或者  /usr/<span class="built_in">local</span>/lib/ 去找。</span><br><span class="line">./：      是指当前路径的意思</span><br><span class="line">staticLibrary： 是最后想生成的文件名（这里可随意起名字）</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p><strong>动态库的制作：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fpic hello.c -o libhello.so</span><br><span class="line">-shared 指定生成动态库</span><br><span class="line">-fpic ：fPIC选项作用于编译阶段，在生成目标文件时就得使用该选项，以生成位置无关的代码。</span><br></pre></td></tr></table></figure>
<p><strong>动态库的使用：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -lhello -L ./ -o dynamicDepot</span><br><span class="line">/*</span><br><span class="line">main.c：  是指main主函数</span><br><span class="line">-lhello： 是我们生成的.so 文件砍头去尾（lib不要 .so也不要）前面加-l</span><br><span class="line">-L：      是指告诉gcc编译器先从-L指定的路径去找静态库，默认是从/usr/lib/ 或者 /usr/<span class="built_in">local</span>/lib/ 去找。</span><br><span class="line">./：      是指当前路径的意思</span><br><span class="line">dynamicDepot： 是最后想生成的文件名（这里可随意起名字）</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p><strong>区别：</strong></p>
<ol>
<li>静态库代码装载的速度快，执行速度略比动态库快。</li>
<li>动态库更加节省内存，可执行文件体积比静态库小很多。</li>
<li>静态库是在编译时加载，动态库是在运行时加载。</li>
<li>生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。</li>
</ol>
<h3 id="7、GDB常见的调试命令，什么是条件断点，多进程下如何调试。">7、GDB常见的调试命令，什么是条件断点，多进程下如何调试。</h3>
<p><strong>GDB调试</strong>：gdb调试的是可执行文件，在gcc编译时加入 -g ，告诉gcc在编译时加入调试信息，这样gdb才能调试这个被编译的文件 gcc -g tesst.c -o test</p>
<p><strong>GDB命令格式：</strong></p>
<ol>
<li>
<p>quit：退出gdb，结束调试</p>
</li>
<li>
<p>list：查看程序源代码</p>
<p>list 5，10：显示5到10行的代码</p>
<p>list test.c:5, 10: 显示源文件5到10行的代码，在调试多个文件时使用</p>
<p>list get_sum: 显示get_sum函数周围的代码</p>
<p>list test,c get_sum: 显示源文件get_sum函数周围的代码，在调试多个文件时使用</p>
</li>
<li>
<p>reverse-search：字符串用来从当前行向前查找第一个匹配的字符串</p>
</li>
<li>
<p>run：程序开始执行</p>
</li>
<li>
<p>help list/all：查看帮助信息</p>
</li>
<li>
<p>break：设置断点</p>
<p>break 7：在第七行设置断点</p>
<p>break get_sum：以函数名设置断点</p>
<p>break 行号或者函数名 if 条件：以条件表达式设置断点</p>
</li>
<li>
<p>watch 条件表达式：条件表达式发生改变时程序就会停下来</p>
</li>
<li>
<p>next：继续执行下一条语句 ，会把函数当作一条语句执行</p>
</li>
<li>
<p>step：继续执行下一条语句，会跟踪进入函数，一次一条的执行函数内的代码</p>
</li>
</ol>
<p>**条件断点：**break if 条件 以条件表达式设置断点</p>
<p>**多进程下如何调试：**用set follow-fork-mode child 调试子进程</p>
<p>或者set follow-fork-mode parent 调试父进程</p>
<h3 id="8、什么是大端小端，如何判断大端小端？">8、什么是大端小端，如何判断大端小端？</h3>
<p><strong>小端模式</strong>：<strong>低</strong>的有效字节存储在<strong>低的</strong>存储器地址。小端一般为主机字节序；常用的X86结构是小端模式。很多的ARM，DSP都为小端模式。</p>
<p><strong>大端模式</strong>：<strong>高</strong>的有效字节存储在<strong>低的</strong>存储器地址。大端为网络字节序；KEIL C51则为大端模式。</p>
<p>有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。</p>
<p>如何判断：我们可以根据<strong>联合体</strong>来判断系统是大端还是小端。因为联合体变量总是从<strong>低地址</strong>存储。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">test</span>&#123;</span>   </span><br><span class="line">        <span class="keyword">char</span> c;   </span><br><span class="line">        <span class="keyword">int</span> i; </span><br><span class="line">    &#125;;  </span><br><span class="line">    test t; t.i = <span class="number">1</span>;  </span><br><span class="line">    <span class="comment">//如果是大端，则t.c为0x00，则t.c != 1，反之是小端  </span></span><br><span class="line">    <span class="keyword">return</span> (t.c == <span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><strong>解析</strong></p>
<ol>
<li>
<p><strong>在进行网络通信时是否需要进行字节序转换？</strong></p>
<p>相同字节序的平台在进行网络通信时可以不进行字节序转换，但是跨平台进行网络数据通信时必须进行字节序转换。</p>
<p>原因如下：网络协议规定接收到得第一个字节是高字节，存放到低地址，所以发送时会首先去低地址取数据的高字节。小端模式的多字节数据在存放时，低地址存放的是低字节，而被发送方网络协议函数发送时会首先去低地址取数据（想要取高字节，真正取得是低字节），接收方网络协议函数接收时会将接收到的第一个字节存放到低地址（想要接收高字节，真正接收的是低字节），所以最后双方都正确的收发了数据。而相同平台进行通信时，如果双方都进行转换最后虽然能够正确收发数据，但是所做的转换是没有意义的，造成资源的浪费。而不同平台进行通信时必须进行转换，不转换会造成错误的收发数据，字节序转换函数会根据当前平台的存储模式做出相应正确的转换，如果当前平台是大端，则直接返回不进行转换，如果当前平台是小端，会将接收到得网络字节序进行转换。</p>
</li>
<li>
<p><strong>网络字节序</strong></p>
<p>网络上传输的数据都是字节流,对于一个多字节数值,在进行网络传输的时候,先传递哪个字节?也就是说,当接收端收到第一个字节的时候,它将这个字节作为高位字节还是低位字节处理,是一个比较有意义的问题; UDP/TCP/IP协议规定:把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节;而在发送端发送数据时,发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);由此可见,多字节数值在发送之前,在内存中因该是以大端法存放的; 所以说,网络字节序是大端字节序; 比如,我们经过网络发送整型数值0x12345678时,在80X86平台中,它是以小端发存放的,在发送之前需要使用系统提供的字节序转换函数htonl()将其转换成大端法存放的数值;</p>
</li>
</ol>
<h3 id="9、进程调度算法有哪些？">9、进程调度算法有哪些？</h3>
<ol>
<li>先来先服务调度算法</li>
<li>短作业(进程)优先调度算法</li>
<li>高优先级优先调度算法</li>
<li>时间片轮转法</li>
<li>多级反馈队列调度算法</li>
</ol>
<p><strong>解析</strong></p>
<ol>
<li>先来先服务调度算法：每次调度都是从后备作业（进程）队列中选择一个或多个最先进入该队列的作业（进程），将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。</li>
<li>短作业(进程)优先调度算法：短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业（进程），将它们调入内存运行。</li>
<li>高优先级优先调度算法：当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程</li>
<li>时间片轮转法：每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。</li>
<li>多级反馈队列调度算法：综合前面多种调度算法。</li>
</ol>
<p>在这些调度算法中，有抢占式和非抢占式的区别。</p>
<ol>
<li>非抢占式优先权算法<br>
在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</li>
<li>抢占式优先权调度算法<br>
在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i 时，就将其优先权Pi与正在执行的进程j 的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi&gt;Pj，则立即停止Pj的执行，做进程切换，使i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</li>
</ol>
<p>区别：</p>
<p>非抢占式（Nonpreemptive）：让进程运行直到结束或阻塞的调度方式，容易实现，适合专用系统，不适合通用系统。<br>
抢占式（Preemptive）：允许将逻辑上可继续运行的在运行过程暂停的调度方式可防止单一进程长时间独占，CPU系统开销大（降低途径：硬件实现进程切换，或扩充主存以贮存大部分程序）</p>
<h3 id="10、操作系统如何申请以及管理内存的？">10、操作系统如何申请以及管理内存的？</h3>
<p><strong>操作系统如何管理内存：</strong></p>
<ol>
<li>
<p><strong>物理内存</strong>：物理内存有四个层次，分别是寄存器、高速缓存、主存、磁盘。</p>
<p>寄存器：速度最快、量少、价格贵。</p>
<p>高速缓存：次之。</p>
<p>主存：再次之。</p>
<p>磁盘：速度最慢、量多、价格便宜。</p>
<p><img src="https://static.nowcoder.com/images/activity/2021jxy/c/assert/1.png" alt="image-20201219105446608"></p>
<p>操作系统会对物理内存进行管理，有一个部分称为<strong>内存管理器(memory manager)</strong>，它的主要工作是有效的管理内存，记录哪些内存是正在使用的，在进程需要时分配内存以及在进程完成时回收内存。</p>
</li>
<li>
<p><strong>虚拟内存</strong>：操作系统为每一个进程分配一个独立的地址空间，但是虚拟内存。虚拟内存与物理内存存在映射关系，通过页表寻址完成虚拟地址和物理地址的转换。</p>
</li>
</ol>
<p><strong>操作系统如何申请内存：</strong></p>
<p>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：<em>*brk和mmap</em></p>
<h3 id="11、Linux系统态与用户态，什么时候会进入系统态？">11、Linux系统态与用户态，什么时候会进入系统态？</h3>
<ol>
<li>
<p><strong>内核态与用户态</strong>：<strong>内核态</strong>（系统态）与<strong>用户态</strong>是操作系统的两种运行级别。内核态拥有最高权限，可以访问所有系统指令；用户态则只能访问一部分指令。</p>
</li>
<li>
<p><strong>什么时候进入内核态</strong>：共有三种方式：a、<strong>系统调用</strong>。b、<strong>异常</strong>。c、<strong>设备中断</strong>。其中，系统调用是主动的，另外两种是被动的。</p>
</li>
<li>
<p><strong>为什么区分内核态与用户态</strong>：在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。所以区分内核态与用户态主要是出于安全的考虑。</p>
</li>
</ol>
<h3 id="12、LRU-算法及其实现方式。">12、LRU 算法及其实现方式。</h3>
<ol>
<li>
<p><strong>LRU算法</strong>：LRU算法用于缓存淘汰。思路是将缓存中最近最少使用的对象删除掉</p>
</li>
<li>
<p><strong>实现方式</strong>：利用<strong>链表和hashmap</strong>。</p>
<p>当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。</p>
<p>在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。</p>
</li>
</ol>
<p><strong>解析</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line">    list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; cache;<span class="comment">//创建双向链表</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; map;<span class="comment">//创建哈希表</span></span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">count</span>(key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = *map[key];</span><br><span class="line">            cache.<span class="built_in">erase</span>(map[key]);</span><br><span class="line">            map.<span class="built_in">erase</span>(key);</span><br><span class="line">            cache.<span class="built_in">push_front</span>(temp);</span><br><span class="line">            map[key] = cache.<span class="built_in">begin</span>();<span class="comment">//映射头部</span></span><br><span class="line">            <span class="keyword">return</span> temp.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">count</span>(key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            cache.<span class="built_in">erase</span>(map[key]);</span><br><span class="line">            map.<span class="built_in">erase</span>(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cap == cache.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = cache.<span class="built_in">back</span>();</span><br><span class="line">            map.<span class="built_in">erase</span>(temp.first);</span><br><span class="line">            cache.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cache.<span class="built_in">push_front</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(key, value));</span><br><span class="line">        map[key] = cache.<span class="built_in">begin</span>();<span class="comment">//映射头部</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="13、一个线程占多大内存？">13、一个线程占多大内存？</h3>
<p>一个linux的线程大概占8M内存。</p>
<p><strong>解析</strong></p>
<p>linux的栈是通过缺页来分配内存的，不是所有栈地址空间都分配了内存。因此，8M是最大消耗，实际的内存消耗只会略大于实际需要的内存(内部损耗，每个在4k以内)。</p>
<h3 id="14、什么是页表，为什么要有？">14、什么是页表，为什么要有？</h3>
<p>页表是虚拟内存的概念。<strong>操作系统虚拟内存到物理内存的映射表，就被称为页表。</strong></p>
<p><strong>原因</strong>：不可能每一个虚拟内存的 Byte 都对应到物理内存的地址。这张表将大得真正的物理地址也放不下，于是操作系统引入了页（Page）的概念。进行分页，这样可以减小虚拟内存页对应物理内存页的映射表大小。</p>
<p><strong>解析</strong></p>
<p>如果将每一个虚拟内存的 Byte 都对应到物理内存的地址，每个条目最少需要 8字节（32位虚拟地址-&gt;32位物理地址），在 4G 内存的情况下，就需要 32GB 的空间来存放对照表，那么这张表就大得真正的物理地址也放不下了，于是操作系统引入了页（Page）的概念。</p>
<p>在系统启动时，操作系统将整个物理内存以 4K 为单位，划分为各个页。之后进行内存分配时，都以页为单位，那么虚拟内存页对应物理内存页的映射表就大大减小了，4G 内存，只需要 8M 的映射表即可，一些进程没有使用到的虚拟内存，也并不需要保存映射关系，而且Linux 还为大内存设计了多级页表，可以进一页减少了内存消耗。</p>
<h3 id="15、操作系统中的缺页中断。">15、操作系统中的缺页中断。</h3>
<ol>
<li>
<p><strong>缺页异常</strong>：malloc和mmap函数在分配内存时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个<strong>缺页异常，引发缺页中断</strong>。</p>
</li>
<li>
<p><strong>缺页中断</strong>：缺页异常后将产生一个缺页中断，此时操作系统会根据页表中的<strong>外存地址</strong>在外存中找到所缺的一页，将其调入<strong>内存</strong>。</p>
</li>
</ol>
<p><strong>解析</strong></p>
<p>两者区别。</p>
<p>缺页中断与一般中断一样，需要经历四个步骤：保护CPU现场、分析中断原因、转入缺页中断处理程序、恢复CPU现场，继续执行。<br>
缺页中断与一般中断区别：<br>
（1）在指令执行期间产生和处理缺页中断信号<br>
（2）一条指令在执行期间，可能产生多次缺页中断<br>
（3）缺页中断返回的是执行产生中断的一条指令，而一般中断返回的是执行下一条指令。</p>
<h3 id="16、虚拟内存分布，什么时候会由用户态陷入内核态？">16、虚拟内存分布，什么时候会由用户态陷入内核态？</h3>
<ol>
<li><strong>虚拟内存分布</strong>：</li>
</ol>
<p><img src="https://static.nowcoder.com/images/activity/2021jxy/c/assert/2.png" alt="image-20201219142536149"></p>
<p><strong>用户空间</strong>：</p>
<p>（1）**代码段.text：**存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。</p>
<p>（2）**数据段.data：**存放程序中已初始化的全局变量和静态变量的一块内存区域。</p>
<p>（3）<strong>BSS 段.bss</strong>：存放程序中未初始化的全局变量和静态变量的一块内存区域。</p>
<p>（4）可执行程序在运行时又会多出两个区域：<strong>堆区和栈区</strong>。</p>
<p>**堆区：**动态申请内存用。堆从低地址向高地址增长。</p>
<p>**栈区：**存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。</p>
<p>（5）最后还有一个<strong>文件映射区</strong>，位于堆和栈之间。</p>
<p><strong>内核空间</strong>：DMA区、常规区、高位区。</p>
<ol start="2">
<li><strong>什么时候进入内核态</strong>：共有三种方式：a、<strong>系统调用</strong>。b、<strong>异常</strong>。c、<strong>设备中断</strong>。其中，系统调用是主动的，另外两种是被动的。</li>
</ol>
<h3 id="17、虚拟内存和物理内存，为什么要用虚拟内存，好处是什么？">17、虚拟内存和物理内存，为什么要用虚拟内存，好处是什么？</h3>
<ol>
<li>
<p><strong>物理内存</strong>：物理内存有四个层次，分别是寄存器、高速缓存、主存、磁盘。</p>
<p>寄存器：速度最快、量少、价格贵。</p>
<p>高速缓存：次之。</p>
<p>主存：再次之。</p>
<p>磁盘：速度最慢、量多、价格便宜。</p>
<p><img src="https://static.nowcoder.com/images/activity/2021jxy/c/assert/1.png" alt="image-20201219105446608"></p>
<p>操作系统会对物理内存进行管理，有一个部分称为<strong>内存管理器(memory manager)</strong>，它的主要工作是有效的管理内存，记录哪些内存是正在使用的，在进程需要时分配内存以及在进程完成时回收内存。</p>
</li>
<li>
<p><strong>虚拟内存</strong>：操作系统为每一个进程分配一个独立的地址空间，但是虚拟内存。虚拟内存与物理内存存在映射关系，通过页表寻址完成虚拟地址和物理地址的转换。</p>
</li>
<li>
<p><strong>为什么要用虚拟内存</strong>：因为早期的内存分配方法存在以下问题：</p>
<p>（1）进程地址空间不隔离。会导致数据被随意修改。</p>
<p>（2）内存使用效率低。</p>
<p>（3）程序运行的地址不确定。操作系统随机为进程分配内存空间，所以程序运行的地址是不确定的。</p>
</li>
<li>
<p><strong>使用虚拟内存的好处</strong>：</p>
<p>（1）扩大地址空间。每个进程独占一个4G空间，虽然真实物理内存没那么多。</p>
<p>（2）内存保护：防止不同进程对物理内存的争夺和践踏，可以对特定内存地址提供写保护，防止恶意篡改。</p>
<p>（3）可以实现内存共享，方便进程通信。</p>
<p>（4）可以避免内存碎片，虽然物理内存可能不连续，但映射到虚拟内存上可以连续。</p>
</li>
<li>
<p><strong>使用虚拟内存的缺点</strong>：</p>
<p>（1）虚拟内存需要额外构建数据结构，占用空间。</p>
<p>（2）虚拟地址到物理地址的转换，增加了执行时间。</p>
<p>（3）页面换入换出耗时。</p>
<p>（4）一页如果只有一部分数据，浪费内存。</p>
</li>
</ol>
<h3 id="18、虚拟地址到物理地址怎么映射的？">18、虚拟地址到物理地址怎么映射的？</h3>
<p><strong>操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表。</strong> 页表中的每一项都记录了这个页的基地址。</p>
<p><strong>三级页表转换方法：（两步）</strong></p>
<ol>
<li>
<p>逻辑地址转线性地址：段起始地址+段内偏移地址=线性地址</p>
</li>
<li>
<p>线性地址转物理地址：</p>
<p>（1）每一个32位的线性地址被划分为三部分：页目录索引（DIRECTORY，10位）、页表索引（TABLE，10位）、页内偏移（OFFSET，12位）<br>
（2）从<strong>cr3</strong>中取出进程的页目录地址（操作系统调用进程时，这个地址被装入寄存器中）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">页目录地址 + 页目录索引 = 页表地址</span><br><span class="line">页表地址 + 页表索引 = 页地址</span><br><span class="line">页地址 + 页内偏移 = 物理地址</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://static.nowcoder.com/images/activity/2021jxy/c/assert/5.png" alt="IMG_256"></p>
<p>按照以上两步法，就完成了一个三级页表从虚拟地址到物理地址的转换。</p>
<h3 id="19、堆栈溢出是什么，会怎么样？">19、堆栈溢出是什么，会怎么样？</h3>
<p>堆栈溢出就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界。常指调用堆栈溢出，本质上一种数据结构的满溢情况。堆栈溢出可以理解为两个方面：<strong>堆溢出和栈溢出。</strong></p>
<ol>
<li>堆溢出：比如不断的new 一个对象，一直创建新的对象，而不进行释放，最终导致内存不足。将会报错：OutOfMemory Error。</li>
<li>栈溢出：一次函数调用中，栈中将被依次压入：参数，返回地址等，而方法如果递归比较深或进去死循环，就会导致栈溢出。将会报错：StackOverflow Error。</li>
</ol>
<h3 id="20、操作系统中malloc的实现原理">20、操作系统中malloc的实现原理</h3>
<p>**malloc底层实现：**当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。</p>
<h3 id="21、进程空间从高位到低位都有些什么？">21、进程空间从高位到低位都有些什么？</h3>
<p><img src="https://static.nowcoder.com/images/activity/2021jxy/c/assert/2.png" alt="image-20201219142935577"></p>
<p>如上图，<strong>从高地址到低地址，一个程序由命令行参数和环境变量、栈、文件映射区、堆、BSS段、数据段、代码段组成。</strong></p>
<ol>
<li><strong>命令行参数和环境变量</strong></li>
<li>**栈区：**存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。</li>
<li><strong>文件映射区</strong>，位于堆和栈之间。</li>
<li>**堆区：**动态申请内存用。堆从低地址向高地址增长。</li>
<li><strong>BSS 段</strong>：存放程序中未初始化的全局变量和静态变量的一块内存区域。</li>
<li><strong>数据段</strong>：存放程序中已初始化的全局变量和静态变量的一块内存区域。</li>
<li>**代码段：**存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。</li>
</ol>
<h3 id="22、32位系统能访问4GB以上的内存吗？">22、32位系统能访问4GB以上的内存吗？</h3>
<p><strong>正常情况下是不可以的</strong>。原因是计算机使用二进制，每位数只有0或1两个状态，32位正好是2的32次方，正好是4G，所以大于4G就没办法表示了，而在32位的系统中，因其它原因还需要占用一部分空间，所以内存只能识别3G多。要使用4G以上就只能换64位的操作系统了。</p>
<p>但是使用<strong>PAE技术</strong>就可以实现 32位系统能访问4GB以上的内存。</p>
<p><strong>解析</strong></p>
<p>Physical Address Extension（PAE）技术最初是为了弥补32位地址在PC服务器应用上的不足而推出的。我们知道，传统的IA32架构只有32位地址总线，只能让系统容纳不超过4GB的内存，这么大的内存，对于普通的桌面应用应该说是足够用了。可是，对于服务器应用来说，还是显得不足，因为服务器上可能承载了很多同时运行的应用。PAE技术将地址扩展到了36位，这样，系统就能够容纳2^36=64GB的内存。</p>
<h3 id="23、并发和并行">23、并发和并行</h3>
<ol>
<li>
<p><strong>并发</strong>：对于单个CPU，在一个时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级，多个任务不停来回快速切换。</p>
</li>
<li>
<p><strong>并行</strong>：对于多个CPU，多个进程同时运行。</p>
</li>
<li>
<p><strong>区别</strong>。通俗来讲，它们虽然都说是&quot;多个进程同时运行&quot;，但是它们的&quot;同时&quot;不是一个概念。并行的&quot;同时&quot;是同一时刻可以多个任务在运行(处于running)，并发的&quot;同时&quot;是经过不同线程快速切换，使得看上去多个任务同时都在运行的现象。</p>
</li>
</ol>
<h3 id="24、进程、线程、协程是什么，区别是什么？">24、进程、线程、协程是什么，区别是什么？</h3>
<ol>
<li>
<p><strong>进程</strong>：程序是指令、数据及其组织形式的描述，而进程则是程序的运行实例，包括程序计数器、寄存器和变量的当前值。</p>
</li>
<li>
<p><strong>线程</strong>：微进程，一个进程里更小粒度的执行单元。一个进程里包含多个线程并发执行任务。</p>
</li>
<li>
<p><strong>协程</strong>：协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行。</p>
</li>
</ol>
<p><strong>区别</strong>：</p>
<ol>
<li>
<p><strong>线程与进程的区别</strong>：</p>
<p>（1）一个线程从属于一个进程；一个进程可以包含多个线程。</p>
<p>（2）一个线程挂掉，对应的进程挂掉；一个进程挂掉，不会影响其他进程。</p>
<p>（3）进程是系统资源调度的最小单位；线程CPU调度的最小单位。</p>
<p>（4）进程系统开销显著大于线程开销；线程需要的系统资源更少。</p>
<p>（5）进程在执行时拥有独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。</p>
<p>（6）进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈。</p>
<p>（7）通信方式不一样。</p>
<p>（8）进程适应于多核、多机分布；线程适用于多核</p>
</li>
<li>
<p><strong>线程与协程的区别：</strong></p>
<p>（1）协程执行效率极高。协程直接操作栈基本没有内核切换的开销，所以上下文的切换非常快，切换开销比线程更小。</p>
<p>（2）协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高。</p>
<p>（3）一个线程可以有多个协程。</p>
</li>
</ol>
<h3 id="25、Linux的fork的作用">25、Linux的fork的作用</h3>
<p>fork函数用来创建一个子进程。对于父进程，fork()函数返回新创建的子进程的PID。对于子进程，fork()函数调用成功会返回0。如果创建出错，fork()函数返回-1。</p>
<p>fork()函数，其原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;  </span><br></pre></td></tr></table></figure>
<p>fork()函数不需要参数，返回值是一个进程标识符PID。返回值有以下三种情况：</p>
<p>（1） 对于父进程，fork()函数返回新创建的子进程的PID。<br>
（2） 对于子进程，fork()函数调用成功会返回0。<br>
（3） 如果创建出错，fork()函数返回-1。</p>
<p>fork()函数创建一个新进程后，会为这个新进程分配进程空间，将父进程的进程空间中的内容复制到子进程的进程空间中，包括父进程的数据段和堆栈段，并且和父进程共享代码段。这时候，子进程和父进程一模一样，都接受系统的调度。因为两个进程都停留在fork()函数中，最后fork()函数会返回两次，一次在父进程中返回，一次在子进程中返回，两次返回的值不一样，如上面的三种情况。</p>
<h3 id="26、什么是孤儿进程，什么是僵尸进程，如何解决僵尸进程">26、什么是孤儿进程，什么是僵尸进程，如何解决僵尸进程</h3>
<ol>
<li>
<p><strong>孤儿进程</strong>：是指一个父进程退出后，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并且由init进程对它们完整状态收集工作。</p>
</li>
<li>
<p><strong>僵尸进程</strong>：是指一个进程使用fork函数创建子进程，如果子进程退出，而父进程并没有调用wait()或者waitpid()系统调用取得子进程的终止状态，那么子进程的进程描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程。</p>
</li>
<li>
<p><strong>如何解决僵尸进程</strong>：</p>
<p>（1）一般，为了防止产生僵尸进程，在fork子进程之后我们都要及时使用<strong>wait系统调用</strong>；同时，当子进程退出的时候，内核都会给父进程一个SIGCHLD信号，所以我们可以建立一个捕获SIGCHLD信号的信号处理函数，在函数体中调用wait（或waitpid），就可以清理退出的子进程以达到防止僵尸进程的目的。</p>
<p>（2）<strong>使用kill命令</strong>。</p>
<p>打开终端并输入下面命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep Z</span><br></pre></td></tr></table></figure>
<p>会列出进程表中所有僵尸进程的详细内容。</p>
<p>然后输入命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -s SIGCHLD pid(父进程pid)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="27、什么是守护进程，如何实现？">27、什么是守护进程，如何实现？</h3>
<ol>
<li>
<p><strong>守护进程</strong>：守护进程是运行在后台的一种生存期长的特殊进程。它独立于控制终端，处理一些系统级别任务。</p>
</li>
<li>
<p><strong>如何实现</strong>：</p>
<p>（1）创建子进程，终止父进程。方法是调用fork() 产生一个子进程，然后使父进程退出。</p>
<p>（2）调用setsid() 创建一个新会话。</p>
<p>（3）将当前目录更改为根目录。使用fork() 创建的子进程也继承了父进程的当前工作目录。</p>
<p>（4）重设文件权限掩码。文件权限掩码是指屏蔽掉文件权限中的对应位。</p>
<p>（5）关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符。</p>
</li>
</ol>
<p>实现代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXFILE 65535  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="comment">//第一步:创建进程   </span></span><br><span class="line">    <span class="keyword">int</span> pid = fork();  </span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//结束父进程   </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error!\n&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//fork失败，退出   </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//第二步:子进程成为新的会话组长和进程组长,并与控制终端分离   </span></span><br><span class="line">    <span class="built_in">setsid</span>();  </span><br><span class="line">    <span class="comment">//第三步:改变工作目录到  </span></span><br><span class="line">    <span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>);  </span><br><span class="line">    <span class="comment">//第四步:重设文件创建掩模   </span></span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0</span>);  </span><br><span class="line">    <span class="comment">//第五步:关闭打开的文件描述符  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXFILE; ++i)   </span><br><span class="line">        <span class="built_in">close</span>(i); </span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="28、进程通信的方式有哪些？">28、进程通信的方式有哪些？</h3>
<p>进程间通信主要包括<strong>管道</strong>、<strong>系统IPC</strong>（包括消息队列、信号量、信号、共享内存）、<strong>套接字socket</strong>。</p>
<ol>
<li>
<p><strong>管道</strong>：包括无名管道和命名管道，无名管道半双工，只能用于具有亲缘关系的进程直接的通信（父子进程或者兄弟进程），可以看作一种特殊的文件；命名管道可以允许无亲缘关系进程间的通信。</p>
</li>
<li>
<p><strong>系统IPC</strong></p>
<p><strong>消息队列</strong>：消息的链接表，放在内核中。消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除；消息队列可以实现消息的随机查询，可以按照消息的类型读取。</p>
<p><strong>信号量semaphore</strong>：是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步。</p>
<p><strong>信号</strong>：用于通知接收进程某个事件的发生。</p>
<p><strong>内存共享</strong>：使多个进程访问同一块内存空间。</p>
</li>
<li>
<p><strong>套接字socket</strong>：用于不同主机直接的通信。</p>
</li>
</ol>
<h3 id="29、进程同步的方式？">29、进程同步的方式？</h3>
<ol>
<li><strong>信号量semaphore</strong>：是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步。P操作(递减操作)可以用于阻塞一个进程，V操作(增加操作)可以用于解除阻塞一个进程。</li>
<li><strong>管道</strong>：一个进程通过调用管程的一个过程进入管程。在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。</li>
<li><strong>消息队列</strong>：消息的链接表，放在内核中。消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除；消息队列可以实现消息的随机查询，可以按照消息的类型读取。</li>
</ol>
<h3 id="30、Linux进程调度算法及策略有哪些？">30、Linux进程调度算法及策略有哪些？</h3>
<ol>
<li>先来先服务调度算法</li>
<li>短作业(进程)优先调度算法</li>
<li>高优先级优先调度算法</li>
<li>时间片轮转法</li>
<li>多级反馈队列调度算法</li>
</ol>
<p><strong>解析</strong></p>
<ol>
<li>先来先服务调度算法：每次调度都是从后备作业（进程）队列中选择一个或多个最先进入该队列的作业（进程），将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。</li>
<li>短作业(进程)优先调度算法：短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业（进程），将它们调入内存运行。</li>
<li>高优先级优先调度算法：当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程</li>
<li>时间片轮转法：每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。</li>
<li>多级反馈队列调度算法：综合前面多种调度算法。</li>
</ol>
<p>在这些调度算法中，有抢占式和非抢占式的区别。</p>
<ol>
<li>非抢占式优先权算法<br>
在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</li>
<li>抢占式优先权调度算法<br>
在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i 时，就将其优先权Pi与正在执行的进程j 的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi&gt;Pj，则立即停止Pj的执行，做进程切换，使i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</li>
</ol>
<p>区别：</p>
<p>非抢占式（Nonpreemptive）：让进程运行直到结束或阻塞的调度方式，容易实现，适合专用系统，不适合通用系统。<br>
抢占式（Preemptive）：允许将逻辑上可继续运行的在运行过程暂停的调度方式可防止单一进程长时间独占，CPU系统开销大（降低途径：硬件实现进程切换，或扩充主存以贮存大部分程序）</p>
<h3 id="31、进程有多少种状态？">31、进程有多少种状态？</h3>
<p>进程有五种状态：<strong>创建、就绪、执行、阻塞、终止</strong>。一个进程创建后，被放入队列处于就绪状态，等待操作系统调度执行，执行过程中可能切换到阻塞状态（并发），任务完成后，进程销毁终止。</p>
<p><strong>创建状态</strong><br>
一个应用程序从系统上启动，首先就是进入<strong>创建状态</strong>，需要获取系统资源创建进程管理块（PCB：Process Control Block）完成资源分配。</p>
<p><strong>就绪状态</strong><br>
在<strong>创建状态</strong>完成之后，进程已经准备好，处于<strong>就绪状态</strong>，但是还未获得处理器资源，无法运行。</p>
<p><strong>运行状态</strong><br>
获取处理器资源，被系统调度，<strong>当具有时间片</strong>开始进入<strong>运行状态</strong>。如果进程的时间片用完了就进入<strong>就绪状态</strong>。</p>
<p><strong>阻塞状态</strong><br>
在<strong>运行状态</strong>期间，如果进行了阻塞的操作，如耗时的I/O操作，此时进程暂时无法操作就进入到了<strong>阻塞状态</strong>，在这些操作完成后就进入<strong>就绪状态</strong>。等待再次获取处理器资源，被系统调度，<strong>当具有时间片</strong>就进入<strong>运行状态</strong>。</p>
<p><strong>终止状态</strong><br>
进程结束或者被系统终止，进入<strong>终止状态</strong></p>
<p><strong>相互转换如图</strong>：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210519/59_1621415581213/5BFD28FE4117D38D3292FFF7644D2DB8" alt="image-20201221105446608"></p>
<h3 id="32、进程通信中的管道实现原理是什么？">32、进程通信中的管道实现原理是什么？</h3>
<p>操作系统在内核中开辟一块<strong>缓冲区</strong>（称为<strong>管道</strong>）用于通信。<strong>管道</strong>是一种两个进程间进行<strong>单向通信</strong>的机制。因为这种单向性，管道又称为半双工管道，所以其使用是有一定的局限性的。半双工是指数据只能由一个进程流向另一个进程（一个管道负责读，一个管道负责写）；如果是全双工通信，需要建立两个管道。管道分为无名管道和命名管道，无名管道只能用于具有亲缘关系的进程直接的通信（父子进程或者兄弟进程），可以看作一种特殊的文件，<strong>管道本质是一种文件</strong>；命名管道可以允许无亲缘关系进程间的通信。</p>
<p>管道原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">＃include &lt;unistd.h&gt;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;  </span><br></pre></td></tr></table></figure>
<p>pipe()函数创建的管道处于一个进程中间，因此一个进程在由 pipe()创建管道后，一般再使用fork() 建立一个子进程，然后通过管道实现父子进程间的通信。管道两端可分别用描述字fd[0]以及fd[1]来描述。注意管道的两端的任务是固定的，即一端只能用于读，由描述字fd[0]表示，称其为管道读端；另 一端则只能用于写，由描述字fd[1]来表示，称其为管道写端。如果试图从管道写端读取数据，或者向管道读端写入数据都将发生错误。一般文件的 I/O 函数都可以用于管道，如close()、read()、write()等。</p>
<p><strong>具体步骤</strong>如下：</p>
<ol>
<li>父进程调用pipe开辟管道,得到两个文件描述符指向管道的两端。</li>
<li>父进程调用fork创建子进程,那么子进程也有两个文件描述符指向同一管道。</li>
<li>父进程关闭管道读端,子进程关闭管道写端。父进程可以往管道里写,子进程可以从管道里读,管道是用环形队列实现的,数据从写端流入从读端流出,这样就实现了进程间通信。</li>
</ol>
<p>给出实现的代码，实现父子进程间的管道通信</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT  0     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTPUT 1    </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    <span class="comment">//创建管道    </span></span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];    </span><br><span class="line">    <span class="built_in">pipe</span>(fd);    </span><br><span class="line">    <span class="comment">//创建子进程    </span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();    </span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error!\n&quot;</span>);    </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;<span class="comment">//执行子进程  </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process is starting...\n&quot;</span>);  </span><br><span class="line">        <span class="comment">//子进程向父进程写数据，关闭管道的读端   </span></span><br><span class="line">        <span class="built_in">close</span>(fd[INPUT]);  </span><br><span class="line">        <span class="built_in">write</span>(fd[OUTPUT], <span class="string">&quot;hello douya!&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;hello douya!&quot;</span>));  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//执行父进程  </span></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Parent process is starting......\n&quot;</span>);  </span><br><span class="line">        <span class="comment">//父进程从管道读取子进程写的数据 ，关闭管道的写端    </span></span><br><span class="line">        <span class="built_in">close</span>(fd[OUTPUT]);    </span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">255</span>];  </span><br><span class="line">        <span class="keyword">int</span> output = <span class="built_in">read</span>(fd[INPUT], buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf));  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d bytes of data from child process: %s\n&quot;</span>, output, buf);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<h3 id="33、mmap的原理和使用场景">33、mmap的原理和使用场景</h3>
<p><strong>原理</strong>：<strong>mmap是一种内存映射文件的方法</strong>，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read, write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图：</p>
<img src="https://uploadfiles.nowcoder.com/images/20210519/59_1621415737288/7F7B2DE3C7D83F7F31D18D49C8BBCF01" alt="image-20201221105446608" style="zoom:50%;" />
<p><strong>使用场景</strong>：</p>
<ol>
<li>对同一块区域频繁读写操作；</li>
<li>可用于实现用户空间和内核空间的高效交互</li>
<li>可提供进程间共享内存及相互通信</li>
<li>可实现高效的大规模数据传输。</li>
</ol>
<h3 id="34、互斥量能不能在进程中使用？">34、互斥量能不能在进程中使用？</h3>
<p><strong>能</strong>。</p>
<p>不同的进程之间，存在资源竞争或并发使用的问题，所以需要<strong>互斥量</strong>。</p>
<p>进程中也需要<strong>互斥量</strong>，因为一个进程中可以包含多个线程，线程与线程之间需要通过互斥的手段进行同步，避免导致共享数据修改引起冲突。可以使用<strong>互斥锁</strong>，属于互斥量的一种。</p>
<h3 id="35、协程是轻量级线程，轻量级表现在哪里？">35、协程是轻量级线程，轻量级表现在哪里？</h3>
<ol>
<li><strong>协程调用跟切换比线程效率高</strong>：协程执行效率极高。协程不需要多线程的锁机制，可以不加锁的访问全局变量，所以上下文的切换非常快。</li>
<li><strong>协程占用内存少</strong>：执行协程只需要极少的栈内存（大概是4～5KB），而默认情况下，线程栈的大小为1MB。</li>
<li><strong>切换开销更少</strong>：协程直接操作栈基本没有内核切换的开销，所以切换开销比线程少。</li>
</ol>
<h3 id="36、常见信号有哪些，表示什么含义？">36、常见信号有哪些，表示什么含义？</h3>
<p>编号为1 ~ 31的信号为传统UNIX支持的信号，是不可靠信号(非实时的)。不可靠信号和可靠信号的区别在于前者不支持排队，可能会造成信号丢失，而后者不会。编号为1 ~ 31的信号如下：</p>
<table>
<thead>
<tr>
<th>信号代号</th>
<th>信号名称</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SIGHUP</td>
<td>该信号让进程立即关闭.然后重新读取配置文件之后重启</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>程序中止信号，用于中止前台进程。相当于输出 Ctrl+C 快捷键</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>和SIGINT类似, 但由QUIT字符(通常是Ctrl-/)来控制. 进程在因收到SIGQUIT退出时会产生core文件, 在这个意义上类似于一个程序错误信号。</td>
</tr>
<tr>
<td>4</td>
<td>SIGILL</td>
<td>执行了非法指令. 通常是因为可执行文件本身出现错误, 或者试图执行数据段. 堆栈溢出时也有可能产生这个信号。</td>
</tr>
<tr>
<td>5</td>
<td>SIGTRAP</td>
<td>由断点指令或其它trap指令产生. 由debugger使用。</td>
</tr>
<tr>
<td>6</td>
<td>SIGABRT</td>
<td>调用abort函数生成的信号。</td>
</tr>
<tr>
<td>7</td>
<td>SIGBUS</td>
<td>非法地址, 包括内存地址对齐(alignment)出错。</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>在发生致命的算术运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为 0 等其他所有的算术运算错误</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>用来立即结束程序的运行。本信号不能被阻塞、处理和忽略。般用于强制中止进程</td>
</tr>
<tr>
<td>10</td>
<td>SIGUSR1</td>
<td>留给用户使用</td>
</tr>
<tr>
<td>11</td>
<td>SIGSEGV</td>
<td>试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据.</td>
</tr>
<tr>
<td>12</td>
<td>SIGUSR2</td>
<td>留给用户使用</td>
</tr>
<tr>
<td>13</td>
<td>SIGPIPE</td>
<td>管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>时钟定时信号，计算的是实际的时间或时钟时间。alarm 函数使用该信号</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>正常结束进程的信号，kill 命令的默认信号。如果进程已经发生了问题，那么这 个信号是无法正常中止进程的，这时我们才会尝试 SIGKILL 信号，也就是信号 9</td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>子进程结束时, 父进程会收到这个信号。</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>该信号可以让暂停的进程恢复执行。本信号不能被阻断</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>该信号可以暂停前台进程，相当于输入 Ctrl+Z 快捷键。本信号不能被阻断</td>
</tr>
<tr>
<td>20</td>
<td>SIGTSTP</td>
<td>停止进程的运行, 但该信号可以被处理和忽略. 用户键入SUSP字符时(通常是Ctrl-Z)发出这个信号</td>
</tr>
<tr>
<td>21</td>
<td>SIGTTIN</td>
<td>当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号. 缺省时这些进程会停止执行.</td>
</tr>
<tr>
<td>22</td>
<td>SIGTTOU</td>
<td>类似于SIGTTIN, 但在写终端(或修改终端模式)时收到.</td>
</tr>
<tr>
<td>23</td>
<td>SIGURG</td>
<td>有&quot;紧急&quot;数据或out-of-band数据到达socket时产生.</td>
</tr>
<tr>
<td>24</td>
<td>SIGXCPU</td>
<td>超过CPU时间资源限制. 这个限制可以由getrlimit/setrlimit来读取/改变。</td>
</tr>
<tr>
<td>25</td>
<td>SIGXFSZ</td>
<td>当进程企图扩大文件以至于超过文件大小资源限制。</td>
</tr>
<tr>
<td>26</td>
<td>SIGVTALRM</td>
<td>虚拟时钟信号. 类似于SIGALRM, 但是计算的是该进程占用的CPU时间.</td>
</tr>
<tr>
<td>27</td>
<td>SIGPROF</td>
<td>类似于SIGALRM/SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间.</td>
</tr>
<tr>
<td>28</td>
<td>SIGWINCH</td>
<td>窗口大小改变时发出.</td>
</tr>
<tr>
<td>29</td>
<td>SIGIO</td>
<td>文件描述符准备就绪, 可以开始进行输入/输出操作.</td>
</tr>
<tr>
<td>30</td>
<td>SIGPWR</td>
<td>Power failure</td>
</tr>
<tr>
<td>31</td>
<td>SIGSYS</td>
<td>非法的系统调用。</td>
</tr>
</tbody>
</table>
<p><strong>而常见信号如下</strong>：</p>
<table>
<thead>
<tr>
<th>信号代号</th>
<th>信号名称</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SIGHUP</td>
<td>该信号让进程立即关闭.然后重新读取配置文件之后重启</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>程序中止信号，用于中止前台进程。相当于输出 Ctrl+C 快捷键</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>在发生致命的算术运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为 0 等其他所有的算术运算错误</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>用来立即结束程序的运行。本信号不能被阻塞、处理和忽略。般用于强制中止进程</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>时钟定时信号，计算的是实际的时间或时钟时间。alarm 函数使用该信号</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>正常结束进程的信号，kill 命令的默认信号。如果进程已经发生了问题，那么这 个信号是无法正常中止进程的，这时我们才会尝试 SIGKILL 信号，也就是信号 9</td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>子进程结束时, 父进程会收到这个信号。</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>该信号可以让暂停的进程恢复执行。本信号不能被阻断</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>该信号可以暂停前台进程，相当于输入 Ctrl+Z 快捷键。本信号不能被阻断</td>
</tr>
</tbody>
</table>
<p>其中最重要的就是 “1”、“9”、“15”、&quot;17&quot;这几个信号。</p>
<h3 id="37、线程间通信的方式有哪些？">37、线程间通信的方式有哪些？</h3>
<p>线程间的通信方式包括<strong>临界区、互斥量、信号量、条件变量、读写锁</strong>：</p>
<ol>
<li>临界区：每个线程中访问临界资源的那段代码称为临界区（Critical Section）（临界资源是一次仅允许一个线程使用的共享资源）。每次只准许一个线程进入临界区，进入后不允许其他线程进入。不论是硬件临界资源，还是软件临界资源，多个线程必须互斥地对它进行访问。</li>
<li>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才可以访问。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</li>
<li>信号量：计数器，允许多个线程同时访问同一个资源。</li>
<li>条件变量：通过条件变量通知操作的方式来保持多线程同步。</li>
<li>读写锁：读写锁与互斥量类似。但互斥量要么是锁住状态，要么就是不加锁状态。读写锁一次只允许一个线程写，但允许一次多个线程读，这样效率就比互斥锁要高。</li>
</ol>
<h3 id="38、线程同步方式有哪些？">38、线程同步方式有哪些？</h3>
<p>线程间的同步方式包括<strong>互斥锁、信号量、条件变量、读写锁</strong>：</p>
<ol>
<li><strong>互斥锁</strong>：采用互斥对象机制，只有拥有互斥对象的线程才可以访问。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</li>
<li><strong>信号量</strong>：计数器，允许多个线程同时访问同一个资源。</li>
<li><strong>条件变量</strong>：通过条件变量通知操作的方式来保持多线程同步。</li>
<li><strong>读写锁</strong>：读写锁与互斥量类似。但互斥量要么是锁住状态，要么就是不加锁状态。读写锁一次只允许一个线程写，但允许一次多个线程读，这样效率就比互斥锁要高。</li>
</ol>
<h3 id="39、什么是死锁，产生的条件，如何解决？">39、什么是死锁，产生的条件，如何解决？</h3>
<ol>
<li>
<p><strong>死锁</strong>: 是指多个进程在执行过程中，因争夺资源而造成了互相等待。此时系统产生了死锁。比如两只羊过独木桥，若两只羊互不相让，争着过桥，就产生死锁。</p>
</li>
<li>
<p><strong>产生的条件</strong>：死锁发生有<strong>四个必要条件</strong>：<br>
（1）<strong>互斥条件</strong>：进程对所分配到的资源不允许其他进程访问，若其他进程访问，只能等待，直到进程使用完成后释放该资源；</p>
<p>（2）<strong>请求保持条件</strong>：进程获得一定资源后，又对其他资源发出请求，但该资源被其他进程占有，此时请求阻塞，而且该进程不会释放自己已经占有的资源；</p>
<p>（3）<strong>不可剥夺条件</strong>：进程已获得的资源，只能自己释放，不可剥夺；</p>
<p>（4）<strong>环路等待条件</strong>：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
</li>
<li>
<p><strong>如何解决</strong>：</p>
<p>（1）资源一次性分配，从而解决请求保持的问题</p>
<p>（2）可剥夺资源：当进程新的资源未得到满足时，释放已有的资源；</p>
<p>（3）资源有序分配：资源按序号递增，进程请求按递增请求，释放则相反。</p>
</li>
</ol>
<p><strong>解析</strong></p>
<p>举个例子，比如：如果此时有两个线程T1和T2，它们分别占有R1和R2资源</p>
<p>此时，T1请求R2资源的同时，T2请求R1资源。</p>
<p>这个时候T2说：你把R1给我，我就给你R2</p>
<p>T1说：不行，你要先给我R2，我才能给你R1</p>
<p>那么就这样，死锁产生了。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202281118600.png" alt="image-20201221105446608"></p>
<h3 id="40、有了进程，为什么还要有线程？">40、有了进程，为什么还要有线程？</h3>
<ol>
<li>
<p><strong>原因</strong></p>
<p>进程在早期的多任务操作系统中是基本的<strong>执行单元</strong>。每次进程切换，都要先保存进程资源然后再恢复，这称为上下文切换。<strong>但是进程频繁切换将引起额外开销，从而严重影响系统的性能。<strong>为了减少进程切换的开销，人们把两个任务放到一个进程中，每个任务用一个更小</strong>粒度</strong>的执行单元来实现并发执行，这就是<strong>线程</strong>。</p>
</li>
<li>
<p><strong>线程与进程对比</strong></p>
<p>（1）**进程间的信息难以共享。**由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换。</p>
<p>但<strong>多个线程共享</strong>进程的内存，如代码段、数据段、扩展段，线程间进行信息交换十分方便。</p>
<p>（2）调用 fork() 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销依然不菲。</p>
<p>**但创建线程比创建进程通常要快 10 倍甚至更多。**线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表。</p>
</li>
</ol>
<h3 id="41、单核机器上写多线程程序，是否要考虑加锁，为什么？">41、单核机器上写多线程程序，是否要考虑加锁，为什么？</h3>
<p>在单核机器上写多线程程序，仍然需要线程锁。</p>
<p><strong>原因</strong>：因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，<strong>不使用线程锁的前提下，可能会导致共享数据修改引起冲突。</strong></p>
<h3 id="42、多线程和多进程的不同？">42、多线程和多进程的不同？</h3>
<p>（1）一个线程从属于一个进程；一个进程可以包含多个线程。</p>
<p>（2）一个线程挂掉，对应的进程挂掉，多线程也挂掉；一个进程挂掉，不会影响其他进程，多进程稳定。</p>
<p>（3）进程系统开销显著大于线程开销；线程需要的系统资源更少。</p>
<p>（4）多个进程在执行时拥有各自独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。</p>
<p>（5）多进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈；多线程切换时只需要切换硬件上下文和内核栈。</p>
<p>（6）通信方式不一样。</p>
<p>（7）多进程适应于多核、多机分布；多线程适用于多核</p>
<h3 id="43、互斥锁的机制，互斥锁与读写的区别？">43、互斥锁的机制，互斥锁与读写的区别？</h3>
<ol>
<li>
<p><strong>互斥锁机制</strong>：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</p>
</li>
<li>
<p><strong>互斥锁和读写锁</strong>：</p>
<p>（1） 读写锁区分读者和写者，而互斥锁不区分</p>
<p>（2）互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。</p>
</li>
</ol>
<p><strong>原理详解</strong>：</p>
<p>互斥锁其实就是一个bool型变量，为true时表示锁可获取，为false时表示已上锁。这里说的是<strong>互斥锁</strong>，其实是泛指linux中所有的锁机制。</p>
<p>我们采用互斥锁保护临界区，从而防止竞争条件。也就是说，一个线程在进入临界区时应得到锁；它在退出临界区时释放锁。函数 acquire() 获取锁，而函数 release() 释放锁，如图 ：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202281120160.png" alt="image-20201221105446608"></p>
<p>每个互斥锁有一个布尔变量 available，它的值表示锁是否可用。如果锁是可用的，那么调用 acquire() 会成功，并且锁不再可用。当一个线程试图获取不可用的锁时，它会阻塞，直到锁被释放。</p>
<p>按如下定义 acquire()：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">acquire() &#123;</span><br><span class="line">    <span class="keyword">while</span> (!available);</span><br><span class="line">    <span class="comment">/* busy wait */</span></span><br><span class="line">    available = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按如下定义release()：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">release() &#123;</span><br><span class="line">    available = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="44、什么是信号量，有什么作用？">44、什么是信号量，有什么作用？</h3>
<ol>
<li>
<p><strong>概念</strong>：信号量本质上是一个计数器，用于多进程对共享数据对象的读取，它主要是用来保护共享资源（信号量也属于临界资源），使得资源在一个时刻只有一个进程独享。</p>
</li>
<li>
<p><strong>原理</strong>：由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv)，具体的行为如下：</p>
<p>（1）P(sv)操作：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行（信号量的值为正，进程获得该资源的使用权，进程将信号量减1，表示它使用了一个资源单位）。</p>
<p>（2）V(sv)操作：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1（若此时信号量的值为0，则进程进入挂起状态，直到信号量的值大于0，若进程被唤醒则返回至第一步）。</p>
</li>
<li>
<p><strong>作用</strong>：用于多进程对共享数据对象的读取，它主要是用来保护共享资源（信号量也属于临界资源），使得资源在一个时刻只有一个进程独享。</p>
</li>
</ol>
<h3 id="45、进程、线程的中断切换的过程是怎样的？">45、进程、线程的中断切换的过程是怎样的？</h3>
<p>上下文切换指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换。</p>
<ol>
<li>
<p><strong>进程上下文切换</strong></p>
<p>（1）保护被中断进程的处理器现场信息</p>
<p>（2）修改被中断进程的进程控制块有关信息，如进程状态等</p>
<p>（3）把被中断进程的进程控制块加入有关队列</p>
<p>（4）选择下一个占有处理器运行的进程</p>
<p>（5）根据被选中进程设置操作系统用到的地址转换和存储保护信息</p>
<p><strong>切换页目录以使用新的地址空间</strong></p>
<p><strong>切换内核栈和硬件上下文（包括分配的内存，数据段，堆栈段等）</strong></p>
<p>（6）根据被选中进程恢复处理器现场</p>
</li>
<li>
<p><strong>线程上下文切换</strong></p>
<p>（1）保护被中断线程的处理器现场信息</p>
<p>（2）修改被中断线程的线程控制块有关信息，如线程状态等</p>
<p>（3）把被中断线程的线程控制块加入有关队列</p>
<p>（4）选择下一个占有处理器运行的线程</p>
<p>（5）根据被选中线程设置操作系统用到的存储保护信息</p>
<p><strong>切换内核栈和硬件上下文（切换堆栈，以及各寄存器）</strong></p>
<p>（6）根据被选中线程恢复处理器现场</p>
</li>
</ol>
<h3 id="46、自旋锁和互斥锁的使用场景">46、自旋锁和互斥锁的使用场景</h3>
<ol>
<li><strong>互斥锁</strong>用于临界区持锁时间比较长的操作，比如下面这些情况都可以考虑</li>
</ol>
<p>（1）临界区有IO操作</p>
<p>（2）临界区代码复杂或者循环量大</p>
<p>（3）临界区竞争非常激烈</p>
<p>（4）单核处理器</p>
<ol start="2">
<li><strong>自旋锁就</strong>主要用在临界区持锁时间非常短且CPU资源不紧张的情况下。</li>
</ol>
<h3 id="47、线程有哪些状态，相互之间怎么转换？">47、线程有哪些状态，相互之间怎么转换？</h3>
<p>类似进程，有以下五种状态：</p>
<ol>
<li>
<p><strong>新建状态(New)</strong></p>
</li>
<li>
<p><strong>就绪状态(Runnable)</strong></p>
</li>
<li>
<p><strong>运行状态(Running)</strong></p>
</li>
<li>
<p><strong>阻塞状态(Blocked)</strong></p>
</li>
<li>
<p><strong>死亡状态(Dead)</strong></p>
</li>
</ol>
<p><strong>转换方式如下</strong>：</p>
<p><strong>创建状态</strong><br>
一个应用程序从系统上启动，首先就是进入<strong>创建状态</strong>，获取系统资源。</p>
<p><strong>就绪状态</strong><br>
在<strong>创建状态</strong>完成之后，线程已经准备好，处于<strong>就绪状态</strong>，但是还未获得处理器资源，无法运行。</p>
<p><strong>运行状态</strong><br>
获取处理器资源，被系统调度，当具有时间片开始进入<strong>运行状态</strong>。如果线程的时间片用完了就进入<strong>就绪状态</strong>。</p>
<p><strong>阻塞状态</strong><br>
在<strong>运行状态</strong>期间，如果进行了阻塞的操作，如耗时的I/O操作，此时线程暂时无法操作就进入到了<strong>阻塞状态</strong>，在这些操作完成后就进入<strong>就绪状态</strong>。等待再次获取处理器资源，被系统调度，当具有时间片就进入<strong>运行状态</strong>。</p>
<p><strong>终止状态</strong><br>
线程结束或者被系统终止，进入<strong>终止状态</strong></p>
<p>相互转换如图：</p>
<img src="https://uploadfiles.nowcoder.com/images/20210519/59_1621415889970/F1B3E414CB7B8F254EBDAED60E3BF80E" alt="image-20201221105446608" style="zoom:33%;" />
<h3 id="48、多线程和单线程有什么区别，多线程编程要注意什么，多线程加锁需要注意什么？">48、多线程和单线程有什么区别，多线程编程要注意什么，多线程加锁需要注意什么？</h3>
<p><strong>参考回答</strong></p>
<ol>
<li>
<p><strong>区别</strong>：</p>
<p>（1）多线程从属于一个进程，单线程也从属于一个进程；一个线程挂掉都会导致从属的进程挂掉。</p>
<p>（2）一个进程里有多个线程，可以并发执行多个任务；一个进程里只有一个线程，就只能执行一个任务。</p>
<p>（3）多线程并发执行多任务，需要切换内核栈与硬件上下文，有切换的开销；单线程不需要切换，没有切换的开销。</p>
<p>（4）多线程并发执行多任务，需要考虑同步的问题；单线程不需要考虑同步的问题。</p>
</li>
<li>
<p>多线程编程需要考虑<strong>同步</strong>的问题。线程间的同步方式包括<strong>互斥锁、信号量、条件变量、读写锁</strong>。</p>
</li>
<li>
<p>多线程加锁，主要需要注意<strong>死锁</strong>的问题。破坏死锁的必要条件从而避免死锁。</p>
</li>
</ol>
<p><strong>解析</strong></p>
<ol>
<li>
<p><strong>死锁</strong>: 是指多个进程在执行过程中，因争夺资源而造成了互相等待。此时系统产生了死锁。比如两只羊过独木桥，若两只羊互不相让，争着过桥，就产生死锁。</p>
</li>
<li>
<p><strong>产生的条件</strong>：死锁发生有<strong>四个必要条件</strong>：<br>
（1）<strong>互斥条件</strong>：进程对所分配到的资源不允许其他进程访问，若其他进程访问，只能等待，直到进程使用完成后释放该资源；</p>
<p>（2）<strong>请求保持条件</strong>：进程获得一定资源后，又对其他资源发出请求，但该资源被其他进程占有，此时请求阻塞，而且该进程不会释放自己已经占有的资源；</p>
<p>（3）<strong>不可剥夺条件</strong>：进程已获得的资源，只能自己释放，不可剥夺；</p>
<p>（4）<strong>环路等待条件</strong>：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
</li>
<li>
<p><strong>如何解决</strong>：</p>
<p>（1）资源一次性分配，从而解决请求保持的问题</p>
<p>（2）可剥夺资源：当进程新的资源未得到满足时，释放已有的资源；</p>
<p>（3）资源有序分配：资源按序号递增，进程请求按递增请求，释放则相反。</p>
</li>
</ol>
<p><strong>解析</strong></p>
<p>举个例子，比如：如果此时有两个线程T1和T2，它们分别占有R1和R2资源</p>
<p>此时，T1请求R2资源的同时，T2请求R1资源。</p>
<p>这个时候T2说：你把R1给我，我就给你R2</p>
<p>T1说：不行，你要先给我R2，我才能给你R1</p>
<p>那么就这样，死锁产生了。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202281120157.png" alt="image-20201221105446608"></p>
<h3 id="49、sleep和wait的区别？">49、sleep和wait的区别？</h3>
<ol>
<li>
<p><strong>sleep</strong></p>
<p>sleep是一个延时函数，让进程或线程进入休眠。休眠完毕后继续运行。</p>
<p>在linux下面，sleep函数的参数是秒，而windows下面sleep的函数参数是毫秒。</p>
<p>windows下面sleep的函数参数是毫秒。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;// 首先应该先导入头文件</span><br><span class="line">Sleep (500) ; //注意第一个字母是大写。</span><br><span class="line">//就是到这里停半秒，然后继续向下执行。</span><br></pre></td></tr></table></figure>
<p>在 Linux C语言中 sleep的单位是秒</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;// 首先应该先导入头文件</span><br><span class="line">sleep(5); //停5秒</span><br><span class="line">//就是到这里停5秒，然后继续向下执行。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>wait</strong></p>
<p>wait是父进程回收子进程PCB资源的一个系统调用。进程一旦调用了wait函数，就立即阻塞自己本身，然后由wait函数自动分析当前进程的某个子进程是否已经退出，当找到一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞，直到有一个出现为止。函数原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/types.h&gt;  </span><br><span class="line">#include&lt;sys/wait.h&gt;  </span><br><span class="line"></span><br><span class="line">pid_t wait(int* status);  </span><br></pre></td></tr></table></figure>
<p>子进程的结束状态值会由参数status返回，而子进程的进程识别码也会一起返回。如果不需要结束状态值，则参数status可以设成 NULL。</p>
</li>
<li>
<p><strong>区别</strong>：<br>
（1）sleep是一个延时函数，让进程或线程进入休眠。休眠完毕后继续运行。</p>
<p>（2）wait是父进程回收子进程PCB（Process Control Block）资源的一个系统调用。</p>
</li>
</ol>
<h3 id="50、线程池的设计思路，线程池中线程的数量由什么确定？">50、线程池的设计思路，线程池中线程的数量由什么确定？</h3>
<ol>
<li>
<p><strong>设计思路</strong>：</p>
<p>实现线程池有以下几个步骤：<br>
（1）设置一个生产者消费者队列，作为临界资源。</p>
<p>（2）初始化n个线程，并让其运行起来，加锁去队列里取任务运行</p>
<p>（3）当任务队列为空时，所有线程阻塞。</p>
<p>（4）当生产者队列来了一个任务后，先对队列加锁，把任务挂到队列上，然后使用条件变量去通知阻塞中的一个线程来处理。</p>
</li>
<li>
<p><strong>线程池中线程数量</strong>：</p>
<p>线程数量和哪些因素有关：CPU，IO、并行、并发</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果是CPU密集型应用，则线程池大小设置为：CPU数目+1</span><br><span class="line">如果是IO密集型应用，则线程池大小设置为：2*CPU数目+1</span><br><span class="line">最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目</span><br></pre></td></tr></table></figure>
<p>所以线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。</p>
</li>
</ol>
<p><strong>解析</strong></p>
<ol>
<li>
<p><strong>为什么要创建线程池</strong>：</p>
<p>创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。<strong>同时线程池也是为了提升系统效率。</strong></p>
</li>
<li>
<p><strong>线程池的核心线程与普通线程：</strong></p>
<p>任务队列可以存放100个任务，此时为空，线程池里有10个核心线程，若突然来了10个任务，那么刚好10个核心线程直接处理；若又来了90个任务，此时核心线程来不及处理，那么有80个任务先入队列，再创建核心线程处理任务；若又来了120个任务，此时任务队列已满，不得已，就得创建20个普通线程来处理多余的任务。<br>
<strong>以上是线程池的工作流程。</strong></p>
</li>
</ol>
<h3 id="51、进程和线程相比，为什么慢？">51、进程和线程相比，为什么慢？</h3>
<ol>
<li>进程系统开销显著大于线程开销；线程需要的系统资源更少。</li>
<li>进程切换开销比线程大。多进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈；多线程切换时只需要切换硬件上下文和内核栈。</li>
<li>进程通信比线程通信开销大。进程通信需要借助管道、队列、共享内存，需要额外申请空间，通信繁琐；而线程共享进程的内存，如代码段、数据段、扩展段，通信快捷简单，同步开销更小。</li>
</ol>
<h3 id="52、Linux零拷贝的原理？">52、Linux零拷贝的原理？</h3>
<ol>
<li>
<p><strong>什么是零拷贝</strong>：</p>
<p>所谓「零拷贝」描述的是计算机操作系统当中，CPU不执行将数据从一个内存区域，拷贝到另外一个内存区域的任务。通过网络传输文件时，这样通常可以节省 CPU 周期和内存带宽。</p>
</li>
<li>
<p><strong>零拷贝的好处</strong>：</p>
<p>（1）节省了 CPU 周期，空出的 CPU 可以完成更多其他的任务</p>
<p>（2）减少了内存区域之间数据拷贝，节省内存带宽</p>
<p>（3）减少用户态和内核态之间数据拷贝，提升数据传输效率</p>
<p>（4）应用零拷贝技术，减少用户态和内核态之间的上下文切换</p>
</li>
<li>
<p><strong>零拷贝原理</strong>：</p>
<p>在传统 IO 中，用户态空间与内核态空间之间的复制是完全不必要的，因为用户态空间仅仅起到了一种数据转存媒介的作用，除此之外没有做任何事情。</p>
<p><strong>（1）Linux 提供了 sendfile() 用来减少我们的数据拷贝和上下文切换次数。</strong></p>
<p>过程如图：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202281122653.png" alt="image-20201221105446608" style="zoom: 33%;" />
<p>a. 发起 sendfile() 系统调用，操作系统由用户态空间切换到内核态空间（第一次上下文切换）</p>
<p>b. 通过 DMA 引擎将数据从磁盘拷贝到内核态空间的输入的 socket 缓冲区中（第一次拷贝）</p>
<p>c. 将数据从内核空间拷贝到与之关联的 socket 缓冲区（第二次拷贝）</p>
<p>d. 将 socket 缓冲区的数据拷贝到协议引擎中（第三次拷贝）</p>
<p>e. sendfile() 系统调用结束，操作系统由用户态空间切换到内核态空间（第二次上下文切换）</p>
<p>根据以上过程，一共有 2 次的上下文切换，3 次的 I/O 拷贝。我们看到从用户空间到内核空间并没有出现数据拷贝，<strong>从操作系统角度来看，这个就是零拷贝</strong>。内核空间出现了复制的原因: 通常的硬件在通过DMA访问时期望的是连续的内存空间。</p>
<p>（2）<strong>mmap 数据零拷贝原理</strong></p>
<p><strong>如果需要对数据做操作，Linux 提供了mmap 零拷贝来实现。</strong></p>
</li>
</ol>
<h3 id="53、epoll-和-select-的区别，epoll-为什么高效？">53、epoll 和 select 的区别，epoll 为什么高效？</h3>
<ol>
<li>
<p><strong>区别</strong>：</p>
<p>（1）每次调用select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；而 epoll 保证了每个 fd 在整个过程中只会拷贝一次。</p>
<p>（2）每次调用select都需要在内核遍历传递进来的所有 fd；而 epoll 只需要轮询一次 fd 集合，同时查看就绪链表中有没有就绪的 fd 就可以了。</p>
<p>（3）select支持的文件描述符数量太小了，默认是1024；而 epoll 没有这个限制，它所支持的 fd 上限是最大可以打开文件的数目，这个数字一般远大于2048。</p>
</li>
<li>
<p><strong>epoll为什么高效</strong>：</p>
<p>（1）select，poll实现需要自己不断轮询所有 fd 集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而 epoll 只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。</p>
<p>（2）select，poll每次调用都要把 fd 集合从用户态往内核态拷贝一次，并且要把当前进程往设备等待队列中挂一次，而 epoll 只要一次拷贝，而且把当前进程往等待队列上挂也只挂一次，这也能节省不少的开销。</p>
</li>
</ol>
<h3 id="54、多路IO复用技术有哪些，区别是什么？">54、多路IO复用技术有哪些，区别是什么？</h3>
<ol>
<li>
<p>**select，poll，epoll **都是IO多路复用的机制，I/O多路复用就是通过一种机制，可以监视多个文件描述符，一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知应用程序进行相应的读写操作。</p>
</li>
<li>
<p><strong>区别</strong>：</p>
<p>（1）poll与select不同，通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制，pollfd中的events字段和revents分别用于标示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。</p>
<p>（2）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。</p>
<p>（3）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把当前进程往设备等待队列中挂一次，而epoll只要一次拷贝，而且把当前进程往等待队列上挂也只挂一次，这也能节省不少的开销。</p>
</li>
</ol>
<h3 id="55、socket中select，epoll的使用场景和区别，epoll水平触发与边缘触发的区别？">55、socket中select，epoll的使用场景和区别，epoll水平触发与边缘触发的区别？</h3>
<ol>
<li>
<p><strong>select，epoll的使用场景</strong>：都是IO多路复用的机制，应用于高并发的网络编程的场景。I/O多路复用就是通过一种机制，可以监视多个文件描述符，一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知应用程序进行相应的读写操作。</p>
</li>
<li>
<p><strong>select，epoll的区别</strong>：</p>
<p>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；而epoll保证了每个fd在整个过程中只会拷贝一次。</p>
<p>（2）每次调用select都需要在内核遍历传递进来的所有fd；而epoll只需要轮询一次fd集合，同时查看就绪链表中有没有就绪的fd就可以了。</p>
<p>（3）select支持的文件描述符数量太小了，默认是1024；而epoll没有这个限制，它所支持的fd上限是最大可以打开文件的数目，这个数字一般远大于2048。</p>
</li>
<li>
<p><strong>epoll水平触发与边缘触发的区别</strong></p>
<p>LT模式（水平触发）下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作；</p>
<p>而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。</p>
</li>
</ol>
<h3 id="56、Reactor、Proactor模式。">56、Reactor、Proactor模式。</h3>
<p>在高性能的I/O设计中，有两个比较著名的模式Reactor和Proactor模式，其中<strong>Reactor模式用于同步I/O</strong>，而<strong>Proactor运用于异步I/O</strong>操作。</p>
<ol>
<li>
<p><strong>Reactor模式</strong>：Reactor模式应用于同步I/O的场景。Reactor中读操作的具体步骤如下：</p>
<p>读取操作：</p>
<p>（1）应用程序注册读就需事件和相关联的事件处理器</p>
<p>（2）事件分离器等待事件的发生</p>
<p>（3）当发生读就需事件的时候，事件分离器调用第一步注册的事件处理器</p>
<p>（4）事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理</p>
</li>
<li>
<p><strong>Proactor模式</strong>：Proactor模式应用于异步I/O的场景。Proactor中读操作的具体步骤如下：</p>
<p>（1）应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。</p>
<p>（2）事件分离器等待读取操作完成事件</p>
<p>（3）在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作，并将读取的内容放入用户传递过来的缓存区中。这也是区别于Reactor的一点，Proactor中，应用程序需要传递缓存区。</p>
<p>（4）事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。</p>
</li>
<li>
<p><strong>区别</strong>：从上面可以看出，Reactor中需要<strong>应用程序自己读取或者写入数据</strong>，而Proactor模式中，应用程序不需要用户再自己接收数据，直接使用就可以了，操作系统会将数据从<strong>内核拷贝到用户区</strong>。</p>
</li>
</ol>
<p><strong>解析</strong></p>
<p>IO模型的类型。<br>
（1）阻塞IO：调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。</p>
<p>（2）非阻塞IO：非阻塞等待，每隔一段时间就去检查IO事件是否就绪。没有就绪就可以做其他事情。</p>
<p>（3）信号驱动IO：Linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO信号，然后处理IO事件。</p>
<p>（4）IO多路复用：Linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检查。知道有数据可读或可写时，才真正调用IO操作函数。</p>
<p>（5）异步IO：Linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。用户可以直接去使用数据。</p>
<p>前四种模型–阻塞IO、非阻塞IO、多路复用IO和信号驱动IO都属于<strong>同步模式</strong>，因为其中真正的IO操作(函数)都将会阻塞进程，只有<strong>异步IO模型</strong>真正实现了IO操作的异步性。</p>
<h3 id="57、同步与异步的区别，阻塞与非阻塞的区别？">57、同步与异步的区别，阻塞与非阻塞的区别？</h3>
<ol>
<li>
<p><strong>同步与异步的区别</strong>：</p>
<p><strong>同步</strong>：是所有的操作都做完，才返回给用户结果。即<strong>写完数据库</strong>之后，<strong>再响应用户</strong>，用户体验不好。</p>
<p><strong>异步</strong>：不用等所有操作都做完，就响应用户请求。即<strong>先响应用户请求</strong>，然后<strong>慢慢去写数据库</strong>，用户体验较好。</p>
</li>
<li>
<p><strong>阻塞与非阻塞的区别</strong>：</p>
<p><strong>阻塞</strong>：调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。</p>
<p><strong>非阻塞</strong>：非阻塞等待，每隔一段时间就去检查IO事件是否就绪。没有就绪就可以做其他事情。</p>
</li>
</ol>
<h3 id="58、BIO、NIO有什么区别？">58、BIO、NIO有什么区别？</h3>
<p><strong>BIO（Blocking I/O）</strong>：<strong>阻塞IO</strong>。调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。</p>
<p><strong>NIO（New I/O）</strong>：<strong>同时支持阻塞与非阻塞模式</strong>，NIO的做法是叫一个线程不断的轮询每个IO的状态，看看是否有IO的状态发生了改变，从而进行下一步的操作。</p>
<h3 id="59、5种IO模型">59、5种IO模型</h3>
<ol>
<li>阻塞IO：调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。</li>
<li>非阻塞IO：非阻塞等待，每隔一段时间就去检查IO事件是否就绪。没有就绪就可以做其他事情。</li>
<li>信号驱动IO：Linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO信号，然后处理IO事件。</li>
<li>IO多路复用：Linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检查。知道有数据可读或可写时，才真正调用IO操作函数。</li>
<li>异步IO：Linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。用户可以直接去使用数据。</li>
</ol>
<p><strong>解析</strong></p>
<p>前四种模型–阻塞IO、非阻塞IO、多路复用IO和信号驱动IO都属于<strong>同步模式</strong>，因为其中真正的IO操作(函数)都将会阻塞进程，只有<strong>异步IO模型</strong>真正实现了IO操作的异步性。</p>
<p><strong>异步和同步的区别就在于</strong>，异步是内核将数据拷贝到用户区，不需要用户再自己接收数据，直接使用就可以了，而同步是内核通知用户数据到了，然后用户自己调用相应函数去接收数据。</p>
<h3 id="60、socket网络编程中客户端和服务端用到哪些函数？">60、socket网络编程中客户端和服务端用到哪些函数？</h3>
<ol>
<li>
<p><strong>服务器端函数</strong>：</p>
<p>（1）socket创建一个套接字</p>
<p>（2）bind绑定ip和port</p>
<p>（3）listen使套接字变为可以被动链接</p>
<p>（4）accept等待客户端的链接</p>
<p>（5）write/read接收发送数据</p>
<p>（6）close关闭连接</p>
</li>
<li>
<p><strong>客户端函数</strong>：</p>
<p>（1）创建一个socket，用函数socket()</p>
<p>（2）bind绑定ip和port</p>
<p>（3）连接服务器，用函数connect()</p>
<p>（4）收发数据，用函数send()和recv()，或read()和write()</p>
<p>（5）close关闭连接、</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202281122727.png" alt="image-20201221105446608"></p>
<h3 id="61、网络七层参考模型，每一层的作用？">61、网络七层参考模型，每一层的作用？</h3>
<table>
<thead>
<tr>
<th>OSI七层模型</th>
<th>功能</th>
<th>对应的网络协议</th>
<th style="text-align:center">TCP/IP四层概念模型</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>文件传输，文件管理，电子邮件的信息处理</td>
<td>HTTP、TFTP, FTP, NFS, WAIS、SMTP</td>
<td style="text-align:center">应用层</td>
</tr>
<tr>
<td>表示层</td>
<td>确保一个系统的应用层发送的消息可以被另一个系统的应用层读取，编码转换，数据解析，管理数据的解密和加密。</td>
<td>Telnet, Rlogin, SNMP, Gopher</td>
<td style="text-align:center">应用层</td>
</tr>
<tr>
<td>会话层</td>
<td>负责在网络中的两节点建立，维持和终止通信。</td>
<td>SMTP, DNS</td>
<td style="text-align:center">应用层</td>
</tr>
<tr>
<td>传输层</td>
<td>定义一些传输数据的协议和端口。</td>
<td>TCP, UDP</td>
<td style="text-align:center">传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>控制子网的运行，如逻辑编址，分组传输，路由选择</td>
<td>IP, ICMP, ARP, RARP, AKP, UUCP</td>
<td style="text-align:center">网络层</td>
</tr>
<tr>
<td>数据链路层</td>
<td>主要是对物理层传输的比特流包装，检测保证数据传输的可靠性，将物理层接收的数据进行MAC（媒体访问控制）地址的封装和解封装</td>
<td>FDDI, Ethernet, Arpanet, PDN, SLIP, PPP，STP。HDLC,SDLC,帧中继</td>
<td style="text-align:center">数据链路层</td>
</tr>
<tr>
<td>物理层</td>
<td>定义物理设备的标准，主要对物理连接方式，电气特性，机械特性等制定统一标准。</td>
<td>IEEE 802.1A, IEEE 802.2到IEEE 802.</td>
<td style="text-align:center">数据链路层</td>
</tr>
</tbody>
</table>
<h2 id="阿秀-3">阿秀</h2>
<h3 id="1、进程、线程和协程的区别和联系">1、进程、线程和协程的区别和联系</h3>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">进程</th>
<th style="text-align:center">线程</th>
<th style="text-align:center">协程</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">定义</td>
<td style="text-align:center">资源分配和拥有的基本单位</td>
<td style="text-align:center">程序执行（CPU调度）的基本单位</td>
<td style="text-align:center">用户态的轻量级线程，线程内部调度的基本单位</td>
</tr>
<tr>
<td style="text-align:center">切换情况</td>
<td style="text-align:center">进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td>
<td style="text-align:center">保存和设置程序计数器、少量寄存器和栈的内容</td>
<td style="text-align:center">先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td>
</tr>
<tr>
<td style="text-align:center">切换者</td>
<td style="text-align:center">操作系统</td>
<td style="text-align:center">操作系统</td>
<td style="text-align:center">用户</td>
</tr>
<tr>
<td style="text-align:center">切换过程</td>
<td style="text-align:center">用户态-&gt;内核态-&gt;用户态</td>
<td style="text-align:center">用户态-&gt;内核态-&gt;用户态</td>
<td style="text-align:center">用户态(没有陷入内核)</td>
</tr>
<tr>
<td style="text-align:center">调用栈</td>
<td style="text-align:center">内核栈</td>
<td style="text-align:center">内核栈</td>
<td style="text-align:center">用户栈</td>
</tr>
<tr>
<td style="text-align:center">拥有资源</td>
<td style="text-align:center">CPU资源、内存资源、文件资源和句柄等</td>
<td style="text-align:center">程序计数器、寄存器、栈和状态字</td>
<td style="text-align:center">拥有自己的寄存器上下文和栈</td>
</tr>
<tr>
<td style="text-align:center">并发性</td>
<td style="text-align:center">不同进程之间切换实现并发，各自占有CPU实现并行</td>
<td style="text-align:center">一个进程内部的多个线程并发执行</td>
<td style="text-align:center">同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td>
</tr>
<tr>
<td style="text-align:center">系统开销</td>
<td style="text-align:center">切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td>
<td style="text-align:center">切换时只需保存和设置少量寄存器内容，因此开销很小</td>
<td style="text-align:center">直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td>
</tr>
<tr>
<td style="text-align:center">通信方面</td>
<td style="text-align:center">进程间通信需要借助操作系统</td>
<td style="text-align:center">线程间可以直接读写进程数据段(如全局变量)来进行通信</td>
<td style="text-align:center">共享内存、消息队列</td>
</tr>
</tbody>
</table>
<ol>
<li>进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序</li>
<li>线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束</li>
<li>多提一句：协程是用户态的轻量级线程，线程内部调度的基本单位</li>
</ol>
<p  id="线程与进程的比较"></p>
<h3 id="2、线程与进程的比较">2、线程与进程的比较</h3>
<ol>
<li>线程启动速度快，轻量级</li>
<li>线程的系统开销小</li>
<li>线程使用有一定难度，需要处理数据一致性问题</li>
<li>同一线程共享的有堆、全局变量、静态变量、指针，引用、文件等，而独自占有栈</li>
</ol>
<p  id="一个进程可以创建多少线程和什么有关"></p>
<h3 id="3、一个进程可以创建多少线程，和什么有关？">3、一个进程可以创建多少线程，和什么有关？</h3>
<p>理论上，一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建2048个线程。如果要创建多于2048的话，必须修改编译器的设置。</p>
<p>因此，一个进程可以创建的线程数由可用虚拟空间和线程的栈的大小共同决定，只要虚拟空间足够，那么新线程的建立就会成功。如果需要创建超过2K以上的线程，减小你线程栈的大小就可以实现了，虽然在一般情况下，你不需要那么多的线程。过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响。</p>
<p  id="外中断和异常有什么区别"></p>
<h3 id="4、外中断和异常有什么区别？">4、外中断和异常有什么区别？</h3>
<p>外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p>
<p>而<strong>异常是由 CPU 执行指令的内部事件</strong>引起，如非法操作码、地址越界、算术溢出等。</p>
<p  id="进程线程模型你知道多少"></p>
<h3 id="5、进程线程模型你知道多少？">5、进程线程模型你知道多少？</h3>
<p>对于进程和线程的理解和把握可以说基本奠定了对系统的认知和把控能力。其核心意义绝不仅仅是“线程是调度的基本单位，进程是资源分配的基本单位”这么简单。</p>
<h4 id="多进程">多进程</h4>
<ul>
<li>每一个进程是资源分配的基本单位。</li>
<li>进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。</li>
<li>实际上在父进程创建子进程之后，父、子进程除了 pid 外，几乎所有的部分几乎一样。</li>
<li>父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过<strong>写时复制</strong>机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。</li>
<li><strong>如果子进程想要运行自己的代码段，还可以通过调用 execv() 函数重新加载新的代码段，之后就和父进程独立开了。</strong></li>
<li>我们在 shell 中执行程序就是通过 shell 进程先 fork() 一个子进程再通过 execv() 重新加载新的代码段的过程。</li>
</ul>
<ol>
<li>
<p>进程创建与结束</p>
<ul>
<li>
<p>背景知识：</p>
<p>进程有两种创建方式，一种是操作系统创建的，一种是父进程创建的。从计算机启动到终端执行程序的过程为：0号进程 -&gt; 1号内核进程 -&gt; 1号用户进程(init 进程) -&gt; getty 进程 -&gt; shell 进程 -&gt; 命令行执行进程。所以我们在命令行中通过 ./program 执行可执行文件时，所有创建的进程都是 shell 进程的子进程，这也就是为什么 shell 一关闭，在 shell 中执行的进程都自动被关闭的原因。从 shell 进程到创建其他子进程需要通过以下接口。</p>
</li>
<li>
<p>相关接口：</p>
<ul>
<li>
<p>创建进程：<code>pid_t fork(void);</code></p>
<p>返回值：出错返回-1；父进程中返回 pid &gt; 0；子进程中 pid == 0</p>
</li>
<li>
<p>结束进程：<code>void exit(int status);</code></p>
<ul>
<li>status 是退出状态，保存在全局变量中S?，通常 0 表示正常退出。</li>
</ul>
</li>
<li>
<p>获得 PID：<code>pid_t getpid(void);</code></p>
<p>返回调用者 pid。</p>
</li>
<li>
<p>获得父进程PID：<code>pid_t getppid(void);</code></p>
<p>返回父进程 pid。</p>
</li>
</ul>
</li>
<li>
<p>其他补充：</p>
<ul>
<li>
<p>正常退出方式：exit()、_exit()、return（在main中）。</p>
<p>exit() 和 _exit() 区别：exit() 是对 _exit() 的封装，都会终止进程并做相关收尾工作，最主要的区别是 _exit() 函数关闭全部描述符和清理函数后不会刷新流，但是exit()会在调用 _exit() 函数前刷新数据流。</p>
<p>return 和 exit() 区别：exit() 是函数，但有参数，执行完之后控制权交给系统。return 若是在调用函数中，执行完之后控制权交给调用进程，若是在main函数中，控制权交给系统。</p>
</li>
<li>
<p>异常退出方式：abort() 、终止信号。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Linux进程控制</p>
<ul>
<li>
<p>进程地址空间（地址空间）</p>
<p>虚拟存储器为每个进程提供了独占系统地址空间的假象。</p>
<p>尽管每个进程地址空间内容不尽相同，但是他们的都有相似的结构。X86 Linux进程的地址空间底部是保留给用户程序的，包括文本、数据、堆、栈等，其中文本区和数据区是通过存储器映射方式将磁盘中可执行文件的相应段映射至虚拟存储器地址空间中。</p>
<p>有一些&quot;敏感&quot;的地址需要注意下，对于32位进程来说，代码段从0x08048000开始。从0xC0000000开始到0xFFFFFFFF是内核地址空间，通常情况下代码运行在用户态（使用0x00000000 ~ 0xC00000000的用户地址空间），当发生系统调用、进程切换等操作时CPU控制寄存器设置模式位，进入内核模式，在该状态（超级用户模式）下进程可以访问全部存储器位置和执行全部指令。</p>
<p><strong>也就说32位进程的地址空间都是4G，但用户态下只能访问低3G的地址空间，若要访问3G ~ 4G的地址空间则只有进入内核态才行。</strong></p>
</li>
<li>
<p>进程控制块（处理机）</p>
<p>进程的调度实际就是内核选择相应的进程控制块，被选择的进程控制块中包含了一个进程基本的信息。</p>
</li>
<li>
<p>上下文切换</p>
<p>内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。</p>
<p>进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。</p>
<p>一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程 B。</p>
</li>
</ul>
</li>
</ol>
<h4 id="多线程">多线程</h4>
<ul>
<li>
<p>我们这里讨论的是用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量 <code>int i = 10</code>，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被 CPU 调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。</p>
</li>
<li>
<p>我们必须知道，**做一次简单的 <code>i = i + 1</code>在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，**而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。</p>
</li>
<li>
<p>但是，虽然线程在安全性方面会引入许多新挑战，但是线程带来的好处也是有目共睹的。首先，原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。</p>
</li>
<li>
<p>比如 QQ 可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。</p>
</li>
<li>
<p>对于线程，我认为弄清以下两点非常重要：</p>
<ul>
<li>
<p>线程之间有无先后访问顺序（线程依赖关系）</p>
</li>
<li>
<p>多个线程共享访问同一变量（同步互斥问题）</p>
</li>
</ul>
</li>
<li>
<p>另外，我们通常只会去说同一进程的多个线程共享进程的资源，但是每个线程特有的部分却很少提及，除了标识线程的 tid，每个线程还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。</p>
</li>
<li>
<p>而作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和 PC 即可，相比进程切换开销要小很多。</p>
</li>
</ul>
<p>线程相关接口不少，主要需要了解各个参数意义和返回值意义。</p>
<ol>
<li>
<p>线程创建和结束</p>
<ul>
<li>
<p>背景知识：</p>
<p>在一个文件内的多个函数通常都是按照 main 函数中出现的顺序来执行，但是在分时系统下，我们可以让每个函数都作为一个逻辑流并发执行，最简单的方式就是采用多线程策略。在 main 函数中调用多线程接口创建线程，每个线程对应特定的函数（操作），这样就可以不按照 main 函数中各个函数出现的顺序来执行，避免了忙等的情况。线程基本操作的接口如下。</p>
</li>
<li>
<p>相关接口：</p>
<ul>
<li>
<p>创建线程：<code>int pthread_create(pthread_t *tidp, const pthread_attr_t *attr, void *(*start_rtn)(void*), void *arg);</code></p>
<p>创建一个新线程，pthread 和 start_routine 不可或缺，分别用于标识线程和执行体入口，其他可以填 NULL。</p>
<ul>
<li>
<p>pthread：用来返回线程的 tid，*pthread 值即为 tid，类型 pthread_t == unsigned long int。</p>
</li>
<li>
<p>attr：指向线程属性结构体的指针，用于改变所创线程的属性，填NULL使用默认值。</p>
</li>
<li>
<p>start_routine：线程执行函数的首地址，传入函数指针。</p>
</li>
<li>
<p>arg：通过地址传递来传递函数参数，这里是无符号类型指针，可以传任意类型变量的地址，在被传入函数中先强制类型转换成所需类型即可。</p>
</li>
</ul>
</li>
<li>
<p>获得线程ID：<code>pthread_t pthread_self();</code></p>
<p>调用时，会打印线程ID。</p>
</li>
<li>
<p>等待线程结束：<code>int pthread_join(pthread_t tid, void** retval);</code></p>
<p>主线程调用，等待子线程退出并回收其资源，类似于进程中 wait/waitpid 回收僵尸进程，调用 pthread_join 的线程会被阻塞。</p>
<ul>
<li>
<p>tid：创建线程时通过指针得到 tid 值。</p>
</li>
<li>
<p>retval：指向返回值的指针。</p>
</li>
</ul>
</li>
<li>
<p>结束线程：<code>pthread_exit(void *retval);</code></p>
<p>子线程执行，用来结束当前线程并通过 retval 传递返回值，该返回值可通过 pthread_join 获得。</p>
<ul>
<li>retval：同上。</li>
</ul>
</li>
<li>
<p>分离线程：<code>int pthread_detach(pthread_t tid);</code></p>
<p>主线程、子线程均可调用。主线程中 pthread_detach(tid)，子线程中 pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。</p>
<ul>
<li>tid：同上。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>线程属性值修改</p>
<ul>
<li>
<p>背景知识：</p>
<p>线程属性对象类型为 pthread_attr_t，结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> etachstate;    <span class="comment">// 线程分离的状态</span></span><br><span class="line">    <span class="keyword">int</span> schedpolicy;    <span class="comment">// 线程调度策略</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">schedparam</span>;</span>    <span class="comment">// 线程的调度参数</span></span><br><span class="line">    <span class="keyword">int</span> inheritsched;    <span class="comment">// 线程的继承性</span></span><br><span class="line">    <span class="keyword">int</span> scope;    <span class="comment">// 线程的作用域</span></span><br><span class="line">    <span class="comment">// 以下为线程栈的设置</span></span><br><span class="line">    <span class="keyword">size_t</span> guardsize;    <span class="comment">// 线程栈末尾警戒缓冲大小</span></span><br><span class="line">    <span class="keyword">int</span> stackaddr_set;    <span class="comment">// 线程的栈设置</span></span><br><span class="line">    <span class="keyword">void</span> *    stackaddr;    <span class="comment">// 线程栈的位置</span></span><br><span class="line">    <span class="keyword">size_t</span> stacksize;    <span class="comment">// 线程栈大小</span></span><br><span class="line">&#125;<span class="keyword">pthread_arrt_t</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>相关接口：</p>
<p>对上述结构体中各参数大多有：pthread_attr_get() 和 pthread_attr_set() 系统调用函数来设置和获取。这里不一一罗列。</p>
</li>
</ul>
<p  id="进程调度算法你了解多少"></p>
<h3 id="6、进程调度算法你了解多少？">6、进程调度算法你了解多少？</h3>
<ol>
<li>
<p><strong>先来先服务 first-come first-serverd（FCFS）</strong></p>
<ul>
<li>非抢占式的调度算法，按照请求的顺序进行调度。</li>
<li>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</li>
</ul>
</li>
<li>
<p><strong>短作业优先 shortest job first（SJF）</strong></p>
<ul>
<li>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</li>
<li>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</li>
</ul>
</li>
<li>
<p><strong>最短剩余时间优先 shortest remaining time next（SRTN）</strong></p>
<ul>
<li>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。</li>
<li>如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</li>
</ul>
</li>
<li>
<p><strong>时间片轮转</strong></p>
<ul>
<li>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。</p>
</li>
<li>
<p>当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
</li>
<li>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>
<p>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</p>
</li>
<li>
<p>而如果时间片过长，那么实时性就不能得到保证。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081659744.png" alt=""></p>
<ol start="5">
<li>
<p><strong>优先级调度</strong></p>
<ul>
<li>为每个进程分配一个优先级，按优先级进行调度。</li>
<li>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</li>
</ul>
</li>
<li>
<p><strong>多级反馈队列</strong></p>
<ul>
<li>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</li>
<li>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,…。进程在第一个队列没执行完，就会被移到下一个队列。</li>
<li>这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</li>
<li>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081659694.png" alt=""></p>
<p  id="Linux下进程间通信方式"></p>
<h3 id="7、Linux-下进程间通信方式？">7、Linux 下进程间通信方式？</h3>
<ul>
<li>
<p>管道：</p>
<ul>
<li>
<p>无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。</p>
</li>
<li>
<p>有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。</p>
</li>
</ul>
</li>
<li>
<p>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。<strong>共享内存是最快的 IPC 方式</strong>，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。</p>
</li>
<li>
<p>消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
</li>
<li>
<p>套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。</p>
</li>
<li>
<p>信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</p>
</li>
<li>
<p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。</p>
</li>
</ul>
<p  id="李牛可爱下同步机制"></p>
<h3 id="8、Linux-下同步机制？">8、Linux 下同步机制？</h3>
<ul>
<li>
<p><strong>POSIX 信号量：可用于进程同步，也可用于线程同步。</strong></p>
</li>
<li>
<p><strong>POSIX 互斥锁 + 条件变量：只能用于线程同步。</strong></p>
</li>
</ul>
<ol>
<li>
<p>线程和进程的区别？</p>
<ul>
<li>
<p>调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。</p>
</li>
<li>
<p>并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。</p>
</li>
<li>
<p>拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。</p>
</li>
<li>
<p>系统开销：线程创建销毁只需要处理 PC 值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁 task_struct 结构。</p>
</li>
</ul>
</li>
</ol>
<p  id="如果系统中具有快表后那么地址的转换过程变成什么样了"></p>
<h3 id="9、如果系统中具有快表后，那么地址的转换过程变成什么样了？">9、如果系统中具有快表后，那么地址的转换过程变成什么样了？</h3>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081659084.png" alt="image-20220306204120295"></p>
<blockquote>
<p>①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</p>
<p>②如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</p>
<p>③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)</p>
</blockquote>
<p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。<br>
因为局部性原理，一般来说快表的命中率可以达到90%以上。</p>
<blockquote>
<p>例:某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时1us， 访问一次内存耗时100us。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少?</p>
<p><code>(1+100) * 0.9 + (1+100+100) * 0.1 = 111 us</code></p>
<p>有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是(1+100) * 0.9+ (100+100) *0.1=110.9 us<br>
若未采用快表机制，则访问一个逻辑地址需要100+100 = 200us<br>
显然，引入快表机制后，访问一个逻辑地址的速度快多了。</p>
</blockquote>
<p  id="内存交换和覆盖有什么区别"></p>
<h3 id="10、内存交换和覆盖有什么区别？">10、内存交换和覆盖有什么区别？</h3>
<p>交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一程序或进程中。</p>
<p  id="动态分区分配算法有哪几种可以分别说说吗"></p>
<h3 id="11、动态分区分配算法有哪几种？可以分别说说吗？">11、动态分区分配算法有哪几种？可以分别说说吗？</h3>
<h4 id="1、首次适应算法">1、首次适应算法</h4>
<p>算法思想：每次都从低地址开始查找，找到第–个能满足大小的空闲分区。</p>
<p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p>
<p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@2.8/202104/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-11-1.png" alt=""></p>
<h4 id="2、最佳适应算法">2、最佳适应算法</h4>
<p>算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区。</p>
<p>如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。<br>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081659034.png" alt=""></p>
<h4 id="3、最坏适应算法">3、最坏适应算法</h4>
<p>又称最大适应算法(Largest Fit)</p>
<p>算法思想:为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p>
<p>如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。<br>
<img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@2.8/202104/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-11-3.png" alt=""></p>
<h4 id="4、邻近适应算法">4、邻近适应算法</h4>
<p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p>
<p>如何实现：空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。<br>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081659191.png" alt=""></p>
<h4 id="5、总结">5、总结</h4>
<p>首次适应不仅最简单，通常也是最好最快，不过首次适应算法会使得内存低地址部分出现很多小的空闲分区，而每次查找都要经过这些分区，因此也增加了查找的开销。邻近适应算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间分裂成小的碎片，它通常比首次适应算法结果要差。</p>
<p>最佳适应算法导致大量碎片，最坏适应算法导致没有大的空间。</p>
<p>进行实验，首次适应比最佳适应要好，他们都比最坏好。</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>算法思想</th>
<th>分区排列顺序</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>首次适应</td>
<td>从头到尾找适合的分区</td>
<td>空闲分区以地址递增次序排列</td>
<td>综合看性能最好。<strong>算法开销小</strong>，回收分区后一般不需要对空闲分区队列重新排序</td>
<td></td>
</tr>
<tr>
<td>最佳适应</td>
<td>优先使用更小的分区，以保留更多大分区</td>
<td>空闲分区以容量递增次序排列</td>
<td>会有更多的大分区被保留下来，更能满足大进程需求</td>
<td>会产生很多太小的、难以利用的碎片;<strong>算法开销大</strong>，回收分区后可能需要对空闲分区队列重新排序</td>
</tr>
<tr>
<td>最坏适应</td>
<td>优先使用更大的分区，以防止产生太小的不可用的碎片</td>
<td>空闲分区以容量递减次序排列</td>
<td>可以减少难以利用的小碎片</td>
<td>大分区容易被用完，不利于大进程;<strong>算法开销大</strong>(原因同上)</td>
</tr>
<tr>
<td>邻近适应</td>
<td>由首次适应演变而来，每次从上次查找结束位置开始查找</td>
<td>空闲分区以地址递增次序排列(可排列成循环链表)</td>
<td>不用每次都从低地址的小分区开始检索。<strong>算法开销小</strong>(原因同首次适应算法)</td>
<td>会使高地址的大分区也被用完</td>
</tr>
</tbody>
</table>
<p  id="虚拟技术你了解吗"></p>
<h3 id="12、虚拟技术你了解吗？">12、虚拟技术你了解吗？</h3>
<p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p>
<ul>
<li>多进程与多线程（时分复用技术）：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</li>
<li>虚拟内存（空分复用技术）：它将物理内存抽象为地址空间，<strong>每个进程都有各自的地址空间</strong>。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，<strong>当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中</strong>。</li>
</ul>
<p  id="进程状态的切换你知道多少"></p>
<h3 id="13、进程状态的切换你知道多少？">13、进程状态的切换你知道多少？</h3>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700006.png" alt=""></p>
<ul>
<li>就绪状态（ready）：等待被调度</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）：等待资源</li>
</ul>
<p>应该注意以下内容：</p>
<ul>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<p  id="一个程序从开始运行到结束的完整过程你能说出来多少"></p>
<h3 id="14、一个程序从开始运行到结束的完整过程，你能说出来多少？">14、一个程序从开始运行到结束的完整过程，你能说出来多少？</h3>
<p>四个过程：</p>
<ol>
<li><strong>预编译</strong><br>
<strong>主要处理源代码文件中的以“#”开头的预编译指令</strong>。处理规则见下
<ul>
<li>删除所有的#define，展开所有的宏定义。</li>
<li>处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</li>
<li>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他<br>
文件。</li>
<li>删除所有的注释，“//”和“/**/”。</li>
<li>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重<br>
复引用。</li>
<li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是<br>
能够显示行号。</li>
</ul>
</li>
<li><strong>编译</strong><br>
把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，<strong>生成相应的汇编代码文件</strong>。
<ul>
<li>词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</li>
<li>语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。</li>
<li>语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</li>
<li>优化：源代码级别的一个优化过程。</li>
<li><strong>目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示</strong>。</li>
<li>目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</li>
</ul>
</li>
<li><strong>汇编</strong><br>
<strong>将汇编代码转变成机器可以执行的指令(机器码文件)</strong>。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。<br>
经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux下)、xxx.obj(Windows下)。</li>
<li><strong>链接</strong><br>
<strong>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序</strong>。链接分为静态链接和动态链接：
<ol>
<li><strong>静态链接：</strong><br>
函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。
<ul>
<li>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</li>
<li>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</li>
<li>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</li>
</ul>
</li>
<li><strong>动态链接：</strong><br>
动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。
<ul>
<li>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</li>
<li>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</li>
<li>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</li>
</ul>
</li>
</ol>
</li>
</ol>
<p  id="通过例子讲解逻辑地址转换为物理地址的基本过程"></p>
<h3 id="15、通过例子讲解逻辑地址转换为物理地址的基本过程">15、通过例子讲解逻辑地址转换为物理地址的基本过程</h3>
<p>可以借助进程的页表将逻辑地址转换为物理地址。</p>
<p>通常会在系统中设置一个页表寄存器 (PTR)，存放页表在内存中的起始地址 F 和页表长度 M。进程未执行时，页表的始址和页表长度放在进程控制块 (PCB) 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p>
<p>注意:页面大小是 2 的整数幂<br>
设页面大小为 L，逻辑地址 A 到物理地址 E 的变换过程如下:</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081659990.png" style="zoom: 80%;" />
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700941.png" style="zoom: 50%;" />
<p>例:若页面大小 L 为 1K 字节，页号 2 对应的内存块号 b=8，将逻辑地址 A=2500 转换为物理地址 E。<br>
等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占 10 位 (说明一个页面的大小为 2^10B = 1KB)，页号 2 对应的内存块号 b=8，将逻辑地址 A=2500转换为物理地址 E。</p>
<blockquote>
<p>①计算页号、页内偏移量<br>
页号 P=A/L = 2500/1024 = 2; 页内偏移量W= A%L = 2500%1024 = 452</p>
<p>②根据题中条件可知，页号 2 没有越界，其存放的内存块号 b=8</p>
<p>③物理地址 E=b*L+W=8 * 1024+ 425 = 8644</p>
<p>在分页存储管理(页式管理)的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p>
</blockquote>
<p  id="进程同步的四种方法"></p>
<h3 id="16、进程同步的四种方法？">16、进程同步的四种方法？</h3>
<h4 id="1-临界区">1. 临界区</h4>
<p>对临界资源进行访问的那段代码称为临界区。</p>
<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// entry section</span><br><span class="line">// critical section;</span><br><span class="line">// exit section</span><br></pre></td></tr></table></figure>
<h4 id="2-同步与互斥">2. 同步与互斥</h4>
<ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
<h4 id="3-信号量">3. 信号量</h4>
<p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li><strong>down</strong>   : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong>  ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
<p><strong>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断</strong>。</p>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了   <strong>互斥量（Mutex）</strong>  ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用信号量实现生产者-消费者问题</strong></p>
<p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。<strong>数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量</strong>。</p>
<p>其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
<p><strong>注意</strong>，<strong>不能先对缓冲区进行加锁，再测试信号量</strong>。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。</p>
<p>消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="keyword">int</span> item = produce_item();</span><br><span class="line">        down(&amp;empty);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;full);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-管程">4. 管程</h4>
<p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>
<p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">remove</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br></pre></td></tr></table></figure>
<p>管程有一个重要特性：<strong>在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程</strong>。</p>
<p>管程引入了   <strong>条件变量</strong>   以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p>
<p><strong>使用管程实现生产者-消费者问题</strong></p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(empty);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span> integer;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N -<span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span>;</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p  id="操作系统在对内存进行管理的时候需要做些什么"></p>
<h3 id="17、操作系统在对内存进行管理的时候需要做些什么">17、操作系统在对内存进行管理的时候需要做些什么?</h3>
<ul>
<li>操作系统负责<strong>内存空间的分配与回收</strong>。</li>
<li>操作系统需要提供某种技术<strong>从逻辑上对内存空间进行扩充</strong>。</li>
<li>操作系统需要提供<strong>地址转换功能</strong>，负责程序的逻辑地址与物理地址的转换。</li>
<li>操作系统需要提供<strong>内存保护功能</strong>。保证各进程在各自存储空间内运行，互不干扰</li>
</ul>
<p  id="进程通信方法下线程通信方法里牛客死下"></p>
<h3 id="18、进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）">18、进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）</h3>
<p><strong>进程通信方法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700920.png" alt=""></p>
<table>
<thead>
<tr>
<th>名称及方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>管道(pipe)：允许一个进程和另一个与它有共同祖先的进程之间进行通信</td>
</tr>
<tr>
<td>命名管道(FIFO)：类似于管道，但是它可以用于任何两个进程之间的通信，命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建</td>
</tr>
<tr>
<td>消息队列(MQ)：消息队列是消息的连接表，包括POSIX消息对和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能成该无格式字节流以及缓冲区大小受限等缺点；</td>
</tr>
<tr>
<td>信号量(semaphore)：信号量主要作为进程间以及同进程不同线程之间的同步手段；</td>
</tr>
<tr>
<td>共享内存(shared memory)：它使得多个进程可以访问同一块内存空间，**是最快的可用IPC形式。**这是针对其他通信机制运行效率较低而设计的。它往往与其他通信机制，如信号量结合使用，以达到进程间的同步及互斥</td>
</tr>
<tr>
<td>信号(signal)：信号是比较复杂的通信方式，用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身</td>
</tr>
<tr>
<td>内存映射(mapped memory)：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它</td>
</tr>
<tr>
<td>Socket：它是更为通用的进程间通信机制，可用于不同机器之间的进程间通信</td>
</tr>
</tbody>
</table>
<p><strong>线程通信方法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@2.8/202104/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-18-2.png" alt=""></p>
<table>
<thead>
<tr>
<th>名称及含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Linux：</strong></td>
</tr>
<tr>
<td>信号：类似进程间的信号处理</td>
</tr>
<tr>
<td>锁机制：互斥锁、读写锁和自旋锁</td>
</tr>
<tr>
<td>条件变量：使用通知的方式解锁，与互斥锁配合使用</td>
</tr>
<tr>
<td>信号量：包括无名线程信号量和命名线程信号量</td>
</tr>
<tr>
<td><strong>Windows：</strong></td>
</tr>
<tr>
<td>全局变量：需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，以防编译器对此变量进行优化</td>
</tr>
<tr>
<td>Message消息机制：常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。</td>
</tr>
<tr>
<td>CEvent对象：CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法。</td>
</tr>
</tbody>
</table>
<p  id="进程间通信有哪几种方式把你知道的都说出来"></p>
<h3 id="19、进程间通信有哪几种方式？把你知道的都说出来">19、进程间通信有哪几种方式？把你知道的都说出来</h3>
<p>Linux几乎支持全部UNIX进程间通信方法，包括管道（有名管道和无名管道）、消息队列、共享内存、信号量和套接字。其中前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。</p>
<h4 id="管道">管道</h4>
<ul>
<li>
<p>无名管道</p>
<ul>
<li>
<p>无名管道特点：</p>
<ul>
<li>
<p>无名管道是一种特殊的文件，这种文件只存在于内存中。</p>
</li>
<li>
<p>无名管道只能用于父子进程或兄弟进程之间，必须用于具有亲缘关系的进程间的通信。</p>
</li>
<li>
<p>无名管道只能由一端向另一端发送数据，是半双工方式，如果双方需要同时收发数据需要两个管道。</p>
</li>
</ul>
</li>
<li>
<p>相关接口：</p>
<ul>
<li><code>int pipe(int fd[2]);</code></li>
</ul>
</li>
<li>
<p>fd[2]：管道两端用 fd[0] 和 fd[1] 来描述，读的一端用 fd[0] 表示，写的一端用 fd[1] 表示。通信双方的进程中写数据的一方需要把 fd[0] 先 close 掉，读的一方需要先把 fd[1] 给 close 掉。</p>
</li>
</ul>
</li>
<li>
<p>有名管道：</p>
<ul>
<li>
<p>有名管道特点：</p>
<ul>
<li>
<p>有名管道是 FIFO 文件，存在于文件系统中，可以通过文件路径名来指出。</p>
</li>
<li>
<p>有名管道可以在不具有亲缘关系的进程间进行通信。</p>
</li>
</ul>
</li>
<li>
<p>相关接口：</p>
<ul>
<li><code>int mkfifo(const char *pathname, mode_t mode);</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>pathname：即将创建的FIFO文件路径，如果文件存在需要先删除。</p>
</li>
<li>
<p>mode：和open()中的参数相同。</p>
</li>
</ul>
<h4 id="消息队列">消息队列</h4>
<p>相比于 FIFO，消息队列具有以下优点：</p>
<ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li>
</ul>
<h4 id="共享内存">共享内存</h4>
<p>进程可以将同一段共享内存连接到它们自己的地址空间，所有进程都可以访问共享内存中的地址，如果某个进程向共享内存内写入数据，所做的改动将立即影响到可以访问该共享内存的其他所有进程。</p>
<ul>
<li>
<p>相关接口</p>
<ul>
<li>
<p>创建共享内存：<code>int shmget(key_t key, int size, int flag);</code></p>
<p>成功时返回一个和key相关的共享内存标识符，失败范湖范围-1。</p>
<ul>
<li>
<p>key：为共享内存段命名，多个共享同一片内存的进程使用同一个key。</p>
</li>
<li>
<p>size：共享内存容量。</p>
</li>
<li>
<p>flag：权限标志位，和open的mode参数一样。</p>
</li>
</ul>
</li>
<li>
<p>连接到共享内存地址空间：<code>void *shmat(int shmid, void *addr, int flag);</code></p>
<p>返回值即共享内存实际地址。</p>
<ul>
<li>
<p>shmid：shmget() 返回的标识。</p>
</li>
<li>
<p>addr：决定以什么方式连接地址。</p>
</li>
<li>
<p>flag：访问模式。</p>
</li>
</ul>
</li>
<li>
<p>从共享内存分离：<code>int shmdt(const void *shmaddr);</code></p>
<p>调用成功返回0，失败返回-1。</p>
<ul>
<li>shmaddr：是shmat()返回的地址指针。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>其他补充</p>
<p>共享内存的方式像极了多线程中线程对全局变量的访问，大家都对等地有权去修改这块内存的值，这就导致在多进程并发下，最终结果是不可预期的。所以对这块临界区的访问需要通过信号量来进行进程同步。</p>
<p>但共享内存的优势也很明显，首先可以通过共享内存进行通信的进程不需要像无名管道一样需要通信的进程间有亲缘关系。其次内存共享的速度也比较快，不存在读取文件、消息传递等过程，只需要到相应映射到的内存地址直接读写数据即可。</p>
</li>
</ul>
<h4 id="信号量">信号量</h4>
<p>在提到共享内存方式时也提到，进程共享内存和多线程共享全局变量非常相似。所以在使用内存共享的方式是也需要通过信号量来完成进程间同步。多线程同步的信号量是 POSIX 信号量，而在进程里使用 SYSTEM  V 信号量。</p>
<ul>
<li>
<p>相关接口</p>
<ul>
<li>
<p>创建信号量：<code>int semget(key_t key, int nsems, int semflag);</code></p>
<p>创建成功返回信号量标识符，失败返回-1。</p>
<ul>
<li>
<p>key：进程pid。</p>
</li>
<li>
<p>nsems：创建信号量的个数。</p>
</li>
<li>
<p>semflag：指定信号量读写权限。</p>
</li>
</ul>
</li>
<li>
<p>改变信号量值：<code>int semop(int semid, struct sembuf *sops, unsigned nsops);</code></p>
<p>我们所需要做的主要工作就是创建 sembuf 变量并设置其值，然后调用 semop，把设置好的 sembuf 变量传递进去。</p>
<p>struct sembuf结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line">    <span class="keyword">short</span> sem_num;</span><br><span class="line">    <span class="keyword">short</span> sem_op;</span><br><span class="line">    <span class="keyword">short</span> sem_flg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>成功返回信号量标识符，失败返回-1。</p>
<ul>
<li>
<p>semid：信号量集标识符，由 semget() 函数返回。</p>
</li>
<li>
<p>sops：指向struct sembuf结构的指针，先设置好sembuf值再通过指针传递。</p>
</li>
<li>
<p>nsops：进行操作信号量的个数，即sops结构变量的个数，需大于或等于1。最常见设置此值等于1，只完成对一个信号量的操作。</p>
</li>
</ul>
</li>
<li>
<p>直接控制信号量信息：<code>int semctl(int semid, int semnum, int cmd, union semun arg);</code></p>
<ul>
<li>
<p>semid：信号量集标识符。</p>
</li>
<li>
<p>semnum：信号量集数组上的下标，表示某一个信号量。</p>
</li>
<li>
<p>arg：union semun类型。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>辅助命令</strong></p>
<p>ipcs 命令用于报告共享内存、信号量和消息队列信息。</p>
<ul>
<li>
<p>ipcs -a：列出共享内存、信号量和消息队列信息。</p>
</li>
<li>
<p>ipcs -l：列出系统限额。</p>
</li>
<li>
<p>ipcs -u：列出当前使用情况。</p>
</li>
</ul>
<h4 id="套接字">套接字</h4>
<p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p>
<p  id="虚拟内存的目的是什么"></p>
<h3 id="20、虚拟内存的目的是什么？">20、虚拟内存的目的是什么？</h3>
<p>虚拟内存的目的<strong>是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</strong>。</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。</p>
<p>这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。</p>
<p>例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700161.png" alt=""></p>
<p  id="说一下你理解中的内存他有什么作用呢"></p>
<h3 id="21、说一下你理解中的内存？他有什么作用呢？">21、说一下你理解中的内存？他有什么作用呢？</h3>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700456.png" style="zoom:80%;" />
<P  id="操作系统经典问题之哲学家进餐问题"></p>
<h3 id="22、操作系统经典问题之哲学家进餐问题">22、操作系统经典问题之哲学家进餐问题</h3>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700309.png" alt="image-20220306214643280" style="zoom: 80%;" />
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203062146034.png" alt="image-20220306214655922" style="zoom:80%;" />
<p  id="操作系统经典问题之读者写者问题"></p>
<h3 id="23、操作系统经典问题之读者-写者问题">23、操作系统经典问题之读者-写者问题</h3>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700723.png" alt="image-20220306223857187" style="zoom:80%;" />
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203062239758.png" alt="image-20220306223908563" style="zoom:80%;" />
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700596.png" alt="image-20220306223922457" style="zoom:80%;" />
<p  id="介绍一下几种典型的锁"></p>
<h3 id="24、介绍一下几种典型的锁？">24、介绍一下几种典型的锁？</h3>
<h5 id="读写锁">读写锁</h5>
<ul>
<li>多个读者可以同时进行读</li>
<li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li>
<li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li>
</ul>
<h5 id="互斥锁">互斥锁</h5>
<p>一次只能一个线程拥有互斥锁，其他线程只有等待</p>
<p>互斥锁是在抢锁失败的情况下主动放弃 CPU 进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</p>
<h5 id="条件变量">条件变量</h5>
<p>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说<strong>互斥锁是线程间互斥的机制，条件变量则是同步机制。</strong></p>
<h5 id="自旋锁">自旋锁</h5>
<p>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</p>
<p  id="你知道哪几种线程锁POSIX"></p>
<h4 id="24-1、你知道哪几种线程锁（POSIX）？">24.1、你知道哪几种线程锁（POSIX）？</h4>
<ul>
<li>
<p><strong>互斥锁（mutex）</strong></p>
<ul>
<li>互斥锁属于sleep-waiting类型的锁。例如在一个双核的机器上有两个线程A和B，它们分别运行在core 0和core 1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞，此时会通过上下文切换将线程A置于等待队列中，此时core 0就可以运行其他的任务（如线程C）。</li>
</ul>
</li>
<li>
<p><strong>条件变量(cond)</strong></p>
</li>
<li>
<p><strong>自旋锁(spin)</strong></p>
<ul>
<li>
<p>自旋锁属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，如果自旋锁已经被线程B所持有，那么线程A就会一直在core 0上进行忙等待并不停的进行锁请求，检查该自旋锁是否已经被线程B释放，直到得到这个锁为止。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。</p>
</li>
<li>
<p>虽然它的效率比互斥锁高，但是它也有些不足之处：</p>
<ul>
<li>
<p>自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。</p>
</li>
<li>
<p>在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。</p>
</li>
</ul>
</li>
<li>
<p>自旋锁只有在内核可抢占式或SMP的情况下才真正需要，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。</p>
</li>
</ul>
</li>
</ul>
<p id="逻辑地址为爱死物理地址"></p>
<h3 id="25、逻辑地址VS物理地址">25、逻辑地址VS物理地址</h3>
<p>Eg: 编译时只需确定变量 x 存放的相对地址是 100 ( 也就是说相对于进程在内存中的起始地址而言的地址)。CPU想要找到 x 在内存中的实际存放位置，只需要用进程的起始地址+100即可。<br>
相对地址又称逻辑地址，绝对地址又称物理地址。</p>
<p  id="怎么回收线程有哪几种方法"></p>
<h3 id="26、怎么回收线程？有哪几种方法？">26、怎么回收线程？有哪几种方法？</h3>
<ul>
<li>
<p><strong>等待线程结束：</strong> <code>int pthread_join(pthread_t tid, void** retval);</code></p>
<p>主线程调用，等待子线程退出并回收其资源，类似于进程中 wait/waitpid 回收僵尸进程，调用 pthread_join 的线程会被阻塞。</p>
<ul>
<li>
<p>tid：创建线程时通过指针得到tid值。</p>
</li>
<li>
<p>retval：指向返回值的指针。</p>
</li>
</ul>
</li>
<li>
<p><strong>结束线程：</strong><code>pthread_exit(void *retval);</code></p>
<p>子线程执行，用来结束当前线程并通过 retval 传递返回值，该返回值可通过 pthread_join 获得。</p>
<ul>
<li>retval：同上。</li>
</ul>
</li>
<li>
<p><strong>分离线程：</strong> <code>int pthread_detach(pthread_t tid);</code></p>
<p>主线程、子线程均可调用。主线程中 pthread_detach(tid)，子线程中 pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。</p>
<ul>
<li>tid：同上。</li>
</ul>
</li>
</ul>
<p  id="内存的覆盖是什么有什么特点"></p>
<h3 id="27、内存的覆盖是什么？有什么特点？">27、内存的覆盖是什么？有什么特点？</h3>
<p>由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成为一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。</p>
<p>覆盖技术的特点：是打破了必须将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，再而，大家要注意到，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存。</p>
<p  id="内存交换是什么有什么特点"></p>
<h3 id="28、内存交换是什么？有什么特点？">28、内存交换是什么？有什么特点？</h3>
<p><strong>交换(对换)技术的设计思想</strong>：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)</p>
<p>换入：把准备好竞争 CPU 运行的程序从辅存移到内存。<br>
换出：把处于等待状态（或 CPU 调度原则下被剥夺运行权力）的程序从内存移到辅存，把内存空间腾出来。</p>
<p  id="什么时候会进行内存的交换"></p>
<h3 id="29、什么时候会进行内存的交换？">29、什么时候会进行内存的交换？</h3>
<p>内存交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如: 在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程; 如果缺页率明显下降，就可以暂停换出。</p>
<p  id="终端退出终端运行的进程会怎样"></p>
<h3 id="30、终端退出，终端运行的进程会怎样">30、终端退出，终端运行的进程会怎样</h3>
<p>终端在退出时会发送 SIGHUP 给对应的 bash 进程，bash 进程收到这个信号后首先将它发给 session 下面的进程，如果程序没有对 SIGHUP 信号做特殊处理，那么进程就会随着终端关闭而退出</p>
<p  id="如何让进程后台运行"></p>
<h3 id="31、如何让进程后台运行">31、如何让进程后台运行</h3>
<p>（1）命令后面加上 &amp; 即可，实际上，这样是将命令放入到一个作业队列中了</p>
<p>（2）ctrl + z 挂起进程，使用 jobs 查看序号，在使用 bg % 序号后台运行进程</p>
<p>（3）nohup + &amp;，将标准输出和标准错误缺省会被重定向到 nohup.out 文件中，忽略所有挂断（SIGHUP）信号</p>
<p>（4）运行指令前面 + setsid，使其父进程变成 init 进程，不受HUP信号的影响</p>
<p>（5）将 命令+ &amp;放在()括号中，也可以使进程不受HUP信号的影响</p>
<p  id="什么是快表你知道多少关于快表的知识"></p>
<h3 id="32、什么是快表，你知道多少关于快表的知识？">32、什么是快表，你知道多少关于快表的知识？</h3>
<p>快表，又称联想寄存器(TLB) ，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700287.png" alt=""></p>
<p  id="地址变换中有快表和没快表有什么区别"></p>
<h3 id="33、地址变换中，有快表和没快表，有什么区别？">33、地址变换中，有快表和没快表，有什么区别？</h3>
<table>
<thead>
<tr>
<th></th>
<th>地址变换过程</th>
<th>访问一个逻辑地址的访存次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本地址变换机构</td>
<td>①算页号、页内偏移量 ②检查页号合法性 ③查页表，找到页面存放的内存块号 ④根据内存块号与页内偏移量得到物理地址 ⑤访问目标内存单元</td>
<td>两次访存</td>
</tr>
<tr>
<td>具有快表的地址变换机构</td>
<td>①算页号、页内偏移量 ②检查页号合法性 ③查快表。若命中，即可知道页面存放的内存块号，可直接进行⑤;若未命中则进行④ ④查页表，找到页面存放的内存块号，并且将页表项复制到快表中 ⑤根据内存块号与页内偏移量得到物理地址 ⑥访问目标内存单元</td>
<td>快表命中，只需一次访存 快表未命中，需要两次访存</td>
</tr>
</tbody>
</table>
<p  id="在执行malloc申请内存的时候操作系统是怎么做的"></p>
<h3 id="34、在执行malloc申请内存的时候，操作系统是怎么做的？">34、在执行malloc申请内存的时候，操作系统是怎么做的？</h3>
<p>从操作系统层面上看，malloc是通过两个系统调用来实现的： brk 和 mmap</p>
<ul>
<li>brk 是将进程数据段 (.data) 的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小</li>
<li>mmap 是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。</li>
</ul>
<p>通常，分配的内存小于 128k 时，使用 brk 调用来获得虚拟内存，大于 128k 时就使用 mmap 来获得虚拟内存。</p>
<p>进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。</p>
<p  id="守护进程僵尸进程和孤儿进程"></p>
<h3 id="35、-守护进程、僵尸进程和孤儿进程">35、 守护进程、僵尸进程和孤儿进程</h3>
<h4 id="守护进程">守护进程</h4>
<p>指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如 web 服务器进程 http 等</p>
<p>创建守护进程要点：</p>
<p>（1）让程序在后台执行。方法是调用 fork() 产生一个子进程，然后使父进程退出。</p>
<p>（2）调用 setsid() 创建一个新对话期。控制终端、登录会话和进程组通常是从父进程继承下来的，守护进程要摆脱它们，不受它们的影响，方法是调用 setsid() 使进程成为一个会话组长。setsid() 调用成功后，进程成为新的会话组长和进程组长，并与原来的登录会话、进程组和控制终端脱离。</p>
<p>（3）禁止进程重新打开控制终端。经过以上步骤，进程已经成为一个无终端的会话组长，但是它可以重新申请打开一个终端。为了避免这种情况发生，可以通过使进程不再是会话组长来实现。再一次通过 fork() 创建新的子进程，使调用 fork 的进程退出。</p>
<p>（4）关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。首先获得最高文件描述符值，然后用一个循环程序，关闭0到最高文件描述符值的所有文件描述符。</p>
<p>（5）将当前目录更改为根目录。</p>
<p>（6）子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。为防止这一点，使用 unmask（0）将屏蔽字清零。</p>
<p>（7）处理 SIGCHLD 信号。对于服务器进程，在请求到来时往往生成子进程处理请求。如果子进程等待父进程捕获状态，则子进程将成为僵尸进程（zombie），从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。这样，子进程结束时不会产生僵尸进程。</p>
<h4 id="孤儿进程">孤儿进程</h4>
<p>如果父进程先退出，子进程还没退出，那么子进程的父进程将变为 init 进程。（注：任何一个进程都必须有父进程）。</p>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被 init 进程(进程号为1)所收养，并由 init 进程对它们完成状态收集工作。</p>
<h4 id="僵尸进程">僵尸进程</h4>
<p>如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。</p>
<p>设置<strong>僵尸进程的目的</strong>是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程 ID，进程的终止状态，以及该进程使用的 CPU 时间，所以当终止子进程的父进程调用 wait 或 waitpid 时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程 ID 将被重置为1（init 进程）。继承这些子进程的 init 进程将清理它们（也就是说 init 进程将 wait 它们，从而去除它们的僵尸状态）。</p>
<p  id="如何避免僵尸进程"></p>
<h3 id="36、如何避免僵尸进程？">36、如何避免僵尸进程？</h3>
<ul>
<li>
<p>通过 <code>signal(SIGCHLD, SIG_IGN)</code> 通知内核对子进程的结束不关心，由内核回收。如果不想让父进程挂起，可以在父进程中加入一条语句：<code>signal(SIGCHLD,SIG_IGN);</code> 表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。</p>
</li>
<li>
<p>父进程调用 <code>wait/waitpid</code> 等函数等待子进程结束，如果尚无子进程退出 wait 会导致父进程阻塞。<strong>waitpid可以通过传递 WNOHANG 使父进程不阻塞立即返回。</strong></p>
</li>
<li>
<p>如果父进程很忙可以用 signal 注册信号处理函数，在信号处理函数调用 wait/waitpid 等待子进程退出。</p>
</li>
<li>
<p>通过两次调用 fork。父进程首先调用 fork 创建一个子进程然后 waitpid 等待子进程退出，子进程再 fork 一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由 init 进程接管，孙进程结束后，init 会等待回收。</p>
</li>
</ul>
<p>第一种方法忽略SIGCHLD信号，这常用于并发服务器的性能的一个技巧,因为并发服务器常常 fork 很多子进程，子进程终结之后需要服务器进程去 wait 清理资源。如果将此信号的处理方式设为忽略，可让内核把僵尸子进程转交给 init 进程去处理，省去了大量僵尸进程占用系统资源。</p>
<p  id="局部性原理你知道吗主要有哪两大局部性原理各自是什么"></p>
<h3 id="37、局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？">37、局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？</h3>
<p>主要分为<strong>时间局部性和空间局部性</strong>。</p>
<p>时间局部性: 如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行; 如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)<br>
空间局部性: 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700125.png" alt=""></p>
<p  id="父进程子进程进程组作业和会话"></p>
<h3 id="38、父进程、子进程、进程组、作业和会话">38、父进程、子进程、进程组、作业和会话</h3>
<h4 id="父进程">父进程</h4>
<p>已创建一个或多个子进程的进程</p>
<h4 id="子进程">子进程</h4>
<p>由 fork 创建的新进程被称为子进程（child process）。该函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是 0，而父进程的返回值则是新进程（子进程）的进程 id。将子进程 id 返回给父进程的理由是：因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程 id。对子进程来说，之所以 fork 返回0给它，是因为它随时可以调用 getpid() 来获取自己的 pid；也可以调用 getppid() 来获取父进程的 id。(进程 id 0总是由交换进程使用，所以一个子进程的进程 id 不可能为0 )。</p>
<p>fork 之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这 2 个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器 pc 值相同，也就是说，子进程是从 fork 返回处开始执行的），但有一点不同，如果 fork 成功，子进程中 fork 的返回值是 0，父进程中 fork 的返回值是子进程的进程号，如果 fork 不成功，父进程会返回错误。</p>
<p>子进程从父进程继承的有：</p>
<ol>
<li>进程的资格(真实(real)/有效(effective)/已保存(saved)用户号(UIDs)和组号(GIDs))</li>
<li>环境(environment)</li>
<li>堆栈</li>
<li>内存</li>
<li>进程组号</li>
</ol>
<p>独有：</p>
<ol>
<li>进程号；</li>
<li>不同的父进程号(译者注：即子进程的父进程号与父进程的父进程号不同， 父进程号可由 getppid 函数得到)；</li>
<li>资源使用(resource utilizations)设定为0</li>
</ol>
<h4 id="进程组">进程组</h4>
<p>进程组就是多个进程的集合，其中肯定有一个组长，其进程 PID 等于进程组的 PGID。只要在某个进程组中一个进程存在，该进程组就存在，这与其组长进程是否终止无关。</p>
<h4 id="作业">作业</h4>
<p>shell 分前后台来控制的不是进程而是作业（job）或者进程组（Process Group）。</p>
<p>一个前台作业可以由多个进程组成，一个后台也可以由多个进程组成，shell 可以运行一个前台作业和任意多个后台作业，这称为作业控制</p>
<p><strong>为什么只能运行一个前台作业？</strong><br>
答：当我们在前台新起了一个作业，shell 就被提到了后台，因此 shell 就没有办法再继续接受我们的指令并且解析运行了。 但是如果前台进程退出了，shell 就会有被提到前台来，就可以继续接受我们的命令并且解析运行。</p>
<p>作业与进程组的区别：如果作业中的某个进程有创建了子进程，则该子进程是不属于该作业的。<br>
一旦作业运行结束，shell 就把自己提到前台（子进程还存在，但是子进程不属于作业），如果原来的前台进程还存在（这个子进程还没有终止），他将自动变为后台进程组</p>
<h4 id="会话">会话</h4>
<p>会话（Session）是一个或多个进程组的集合。一个会话可以有一个控制终端。在 xshell 或者 WinSCP 中打开一个窗口就是新建一个会话。</p>
<p  id="进程终止的几种方式"></p>
<h3 id="39、进程终止的几种方式">39、进程终止的几种方式</h3>
<p>1、main函数的自然返回，<code>return</code><br>
2、调用<code>exit</code>函数，属于 c 的函数库<br>
3、调用<code>_exit</code>函数，属于系统调用<br>
4、调用<code>abort</code>函数，异常程序终止，同时发送SIGABRT信号给调用进程。<br>
5、接受能导致进程终止的信号：ctrl+c (^C)、SIGINT(SIGINT中断进程)</p>
<p><strong>exit和_exit的区别</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@2.8/202104/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-39-1.png" alt=""></p>
<p  id="里牛客死中异常和中断的区别"></p>
<h3 id="40、Linux-中异常和中断的区别">40、Linux 中异常和中断的区别</h3>
<p><strong>中断</strong></p>
<p>大家都知道，当我们在敲击键盘的同时就会产生中断，当硬盘读写完数据之后也会产生中断，所以，我们需要知道，中断是由硬件设备产生的，而它们从物理上说就是电信号，之后，它们通过中断控制器发送给 CPU，接着 CPU 判断收到的中断来自于哪个硬件设备（这定义在内核中），最后，由 CPU 发送给内核，有内核处理中断。下面这张图显示了中断处理的流程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@2.8/202104/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-40-1.png" alt=""></p>
<p><strong>异常</strong></p>
<p>我们在学习《计算机组成原理》的时候会知道两个概念，CPU 处理程序的时候一旦程序不在内存中，会产生缺页异常；当运行除法程序时，当除数为 0 时，又会产生除 0 异常。所以，大家也需要记住的是，<strong>异常是由CPU产生的，同时，它会发送给内核，要求内核处理这些异常</strong>，下面这张图显示了异常处理的流程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700500.png" alt=""></p>
<p><strong>相同点</strong></p>
<ul>
<li>
<p>最后都是由CPU发送给内核，由内核去处理</p>
</li>
<li>
<p>处理程序的流程设计上是相似的</p>
</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li><strong>产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的</strong></li>
<li>内核需要根据是异常还是中断调用不同的处理程序</li>
<li>中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的</li>
<li>当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中</li>
</ul>
<p  id="瘟都死和里牛客死环境下内存分布情况"></p>
<h3 id="41、Windows和Linux环境下内存分布情况">41、Windows和Linux环境下内存分布情况</h3>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700617.png" alt=""></p>
<p>通过这张图你可以看到，用户空间内存，从<strong>低到高</strong>分别是 7 种不同的内存段：</p>
<ul>
<li>程序文件段，包括二进制可执行代码；</li>
<li>已初始化数据段，包括静态常量；</li>
<li>未初始化数据段，包括未初始化的静态变量；</li>
<li>堆段，包括动态分配的内存，从低地址开始向上增长；</li>
<li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）</li>
<li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>。当然系统也提供了参数，以便我们自定义大小；</li>
</ul>
<p  id="一个由西加加编译的程序占用的内存分为哪几个部分"></p>
<h3 id="42、一个由C-C-编译的程序占用的内存分为哪几个部分？">42、一个由C/C++编译的程序占用的内存分为哪几个部分？</h3>
<ol>
<li>栈区（stack）— 地址向下增长，由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的队列，先进后出。</li>
<li>堆区（heap）— 地址向上增长，一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</li>
<li>全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后由系统释放</li>
<li>文字常量区 —常量字符串就是放在这里的。程序结束后由系统释放</li>
<li>程序代码区(text)—存放函数体的二进制代码。</li>
</ol>
<p  id="一般情况下在里牛客死和瘟都死平台下栈空间的大小"></p>
<h3 id="43、一般情况下在Linux-windows平台下栈空间的大小">43、一般情况下在Linux/windows平台下栈空间的大小</h3>
<p>Linux 环境下有操作系统决定，一般是 8MB，8192KB，通过 ulimit 命令查看以及修改</p>
<p>Windows 环境下由编译器决定，VC++6.0一般是1M</p>
<p><strong>Linux</strong></p>
<p>linux 下非编译器决定栈大小，而是由操作系统环境决定，默认是 8192KB（8M）；而在 Windows 平台下栈的大小是被记录在可执行文件中的（由编译器来设置)，即：windows下可以由编译器决定栈大小，而在Linux下是由系统环境变量来控制栈的大小的。</p>
<p>在Linux下通过如下命令可查看和设置栈的大小：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">ulimit</span> -a            <span class="comment"># 显示当前栈的大小 （ulimit为系统命令，非编译器命令）</span></span>       </span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">ulimit</span> -s 32768      <span class="comment"># 设置当前栈的大小为32M</span></span></span><br></pre></td></tr></table></figure>
<p><strong>Windows</strong></p>
<p>下程序栈空间的大小，VC++ 6.0 默认的栈空间是1M。</p>
<p>VC6.0中修改堆栈大小的方法：</p>
<ul>
<li>选择 “Project-&gt;Setting”</li>
<li>选择 “Link”</li>
<li>选择 &quot;Category&quot;中的 “Output”</li>
<li>在 &quot;Stack allocations&quot;中的&quot;Reserve:&quot;中输栈的大小</li>
</ul>
<p  id="程序从堆中动态分配内存时虚拟内存上怎么操作的"></p>
<h3 id="44、程序从堆中动态分配内存时，虚拟内存上怎么操作的">44、程序从堆中动态分配内存时，虚拟内存上怎么操作的</h3>
<p>页表：是一个存放在物理内存中的数据结构，它记录了虚拟页与物理页的映射关系</p>
<p>在进行动态内存分配时，例如 malloc() 函数或者其他高级语言中的 new 关键字，操作系统会在硬盘中创建或申请一段虚拟内存空间，并更新到页表（分配一个页表条目（PTE），使该 PTE 指向硬盘上这个新创建的虚拟页），通过 PTE 建立虚拟页和物理页的映射关系。</p>
<p  id="常见的几种磁盘调度算法"></p>
<h3 id="45、常见的几种磁盘调度算法">45、常见的几种磁盘调度算法</h3>
<p>读写一个磁盘块的时间的影响因素有：</p>
<ul>
<li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li>
<li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li>实际的数据传输时间</li>
</ul>
<p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<h4 id="1-先来先服务">1. 先来先服务</h4>
<p>按照磁盘请求的顺序进行调度。</p>
<p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>
<h4 id="2-最短寻道时间优先">2. 最短寻道时间优先</h4>
<p>优先调度与当前磁头所在磁道距离最近的磁道。</p>
<p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700431.png" alt=""></p>
<h4 id="3-电梯扫描算法（扫描SCAN算法）">3. 电梯扫描算法（扫描SCAN算法）</h4>
<p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p>
<p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p>
<p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700046.png" alt=""></p>
<ol start="4">
<li>循环扫描（C-SCAN）算法<br>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700493.png" alt="image-20220308143356931"><br>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081438138.png" alt="image-20220308143803071"></li>
</ol>
<p  id="交换空间与虚拟内存的关系"></p>
<h3 id="46、交换空间与虚拟内存的关系">46、交换空间与虚拟内存的关系</h3>
<p><strong>交换空间</strong><br>
Linux 中的交换空间（Swap space）在<strong>物理内存</strong>（RAM）被充满时被使用。如果系统需要更多的内存资源，而物理内存已经充满，内存中不活跃的页就会被移到交换空间去。虽然交换空间可以为带有少量内存的机器提供帮助，但是这种方法不应该被当做是对内存的取代。交换空间位于硬盘驱动器上，它比进入物理内存要慢。<br>
交换空间可以是一个专用的交换分区（推荐的方法），交换文件，或两者的组合。<br>
交换空间的总大小应该相当于你的计算机内存的两倍和 32 MB这两个值中较大的一个，但是它不能超过 2048MB（2 GB）。<br>
<strong>虚拟内存</strong><br>
虚拟内存是文件数据交叉链接的活动文件。是WINDOWS目录下的一个&quot;WIN386.SWP&quot;文件，这个文件会不断地扩大和自动缩小。<br>
就速度方面而言,CPU的L1和L2缓存速度最快，内存次之，硬盘再次之。但是<strong>虚拟内存使用的是硬盘的空间</strong>，为什么我们要使用速度最慢的硬盘来做为虚拟内存呢？因为电脑中所有运行的程序都需要经过内存来执行，如果执行的程序很大或很多，就会导致我们只有可怜的256M/512M内存消耗殆尽。而硬盘空间动辄几十G上百G，为了解决这个问题，Windows中运用了虚拟内存技术，即拿出一部分硬盘空间来充当内存使用。</p>
<p  id="抖动你知道是什么吗它也叫颠簸现象"></p>
<h3 id="47、抖动你知道是什么吗？它也叫颠簸现象。进程工作集？">47、抖动你知道是什么吗？它也叫颠簸现象。进程工作集？</h3>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081440003.png" alt="image-20220308144057926"></p>
<p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)</p>
<p>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率<br>
为了研究为应该为每个进程分配多少个物理块，Denning 提出了 “进程工作集” 的概念</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081442894.png" alt="image-20220308144256786"></p>
<p  id="从堆和栈上建立对象哪个快考察堆和栈的分配效率比较"></p>
<h3 id="48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）">48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）</h3>
<p>从两方面来考虑：</p>
<ul>
<li>
<p>分配和释放，堆在分配和释放时都要调用函数（malloc, free)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成内存碎片），这些都会花费一定的时间，具体可以看看 malloc 和 free 的源代码，函数做了很多额外的工作，而栈却不需要这些。</p>
</li>
<li>
<p>访问时间，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正的数据，而栈只需访问一次。另外，堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。</p>
</li>
</ul>
<p   id="常见内存分配方式有哪些"></p>
<h3 id="49、常见内存分配方式有哪些？">49、常见内存分配方式有哪些？</h3>
<p><strong>内存分配方式</strong></p>
<p>（1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。</p>
<p>（2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
<p>（3） 从堆上分配，亦称动态内存分配。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</p>
<p  id="常见内存分配内存错误"></p>
<h3 id="50、常见内存分配内存错误">50、常见内存分配内存错误</h3>
<ol>
<li>
<p>内存分配未成功，却使用了它。<br>
编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。</p>
</li>
<li>
<p>内存分配虽然成功，但是尚未初始化就引用它。<br>
犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。</p>
</li>
<li>
<p>内存分配成功并且已经初始化，但操作越过了内存的边界。<br>
例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。</p>
</li>
<li>
<p>忘记了释放内存，造成内存泄露。<br>
含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然挂掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。</p>
</li>
<li>
<p>释放了内存却继续使用它。常见于以下有三种情况：</p>
<ul>
<li>
<p>程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。</p>
</li>
<li>
<p>函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。</p>
</li>
<li>
<p>使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。</p>
</li>
</ul>
</li>
</ol>
<p  id="内存交换中被换出的进程保存在哪里"></p>
<h3 id="51、内存交换中，被换出的进程保存在哪里？">51、内存交换中，被换出的进程保存在哪里？</h3>
<p>保存在磁盘中，也就是外存中。具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的I/O速度比文件区的更快。</p>
<p  id="在发生内存交换时有些进程是被优先考虑的你可以说一说吗"></p>
<h3 id="52、在发生内存交换时，有些进程是被优先考虑的？你可以说一说吗？">52、在发生内存交换时，有些进程是被优先考虑的？你可以说一说吗？</h3>
<p>可优先换出阻塞进程;<br>
可换出优先级低的进程;<br>
为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…<br>
(注意: PCB 会常驻内存，不会被换出外存)</p>
<P  id="埃斯特和鱼体服编码的区别"></p>
<h3 id="53、ASCII、Unicode-和-UTF-8-编码的区别？">53、ASCII、Unicode 和 UTF-8 编码的区别？</h3>
<p><strong>ASCII</strong></p>
<ul>
<li>ASCII 只有127个字符，表示英文字母的大小写、数字和一些符号，但由于其他语言用ASCII 编码表示字节不够，例如：常用中文需要两个字节，且不能和ASCII冲突，中国定制了 GB2312 编码格式，相同的，其他国家的语言也有属于自己的编码格式。</li>
</ul>
<p><strong>Unicode</strong></p>
<ul>
<li>由于每个国家的语言都有属于自己的编码格式，在多语言编辑文本中会出现乱码，这样 Unicode 应运而生，Unicode 就是将这些语言统一到一套编码格式中，通常两个字节表示一个字符，而 ASCII 是一个字节表示一个字符，这样如果你编译的文本是全英文的，用Unicode 编码比 ASCII 编码需要多一倍的存储空间，在存储和传输上就十分不划算。</li>
</ul>
<p><strong>UTF-8</strong></p>
<ul>
<li>为了解决上述问题，又出现了把 Unicode 编码转化为“<strong>可变长编码</strong>” UTF-8 编码，UTF-8 编码将 Unicode 字符按数字大小编码为1-6个字节，英文字母被编码成一个字节，常用汉字被编码成三个字节，如果你编译的文本是纯英文的，那么用 UTF-8 就会非常节省空间，并且 ASCII 码也是 UTF-8 的一部分。</li>
</ul>
<p><strong>三者之间的联系</strong></p>
<p>搞清楚了ASCII、Unicode 和 UTF-8 的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</p>
<ol>
<li>
<p>在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码</p>
</li>
<li>
<p>用记事本编辑的时候，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存里，编辑完成后，保存的时候再把 Unicode 转换为UTF-8 保存到文件。如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700333.png" alt=""></p>
</li>
<li>
<p>浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器：</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700681.png" alt=""></p>
<p  id="原子操作的是如何实现的"></p>
<h3 id="54、原子操作是如何实现的">54、原子操作是如何实现的</h3>
<p>**处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。**首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。Pentium 6 和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64 位的操作是原子的，但是复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p>
<ol>
<li>
<p>使用<strong>总线锁</strong>保证原子性</p>
<p>第一个机制是通过总线锁保证原子性。如果多个处理器同时对共享变量进行读改写操作（<code>i++</code>就是经典的读改写操作），那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致。举个例子，如果 <code>i = 1</code>，我们进行两次 <code>i++</code> 操作，我们期望的结果是 3，但是有可能结果是 2，如图下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081500734.png" alt="image-20220308150007694"></p>
<p>原因可能是多个处理器同时从各自的缓存中读取变量 i，分别进行加 1 操作，然后分别写入系统内存中。那么，想要保证读改写共享变量的操作是原子的，就必须保证 CPU1 读改写共享变量的时候，CPU2 不能操作缓存了该共享变量内存地址的缓存。<br>
处理器使用总线锁就是来解决这个问题的。<strong>所谓总线锁就是使用处理器提供的一个 LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</strong></p>
</li>
<li>
<p>使用<strong>缓存锁</strong>保证原子性</p>
<p>第二个机制是通过缓存锁定来保证原子性。在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但<strong>总线锁定把 CPU 和内存之间的通信锁住了</strong>，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</p>
<p>频繁使用的内存会缓存在处理器的 L1、L2 和 L3 高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在 Pentium 6 和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。</p>
<p>所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在 Lock 操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言 LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为<strong>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效，在如上图所示的例子中，当 CPU1 修改缓存行中的 i 时使用了缓存锁定，那么 CPU2 就不能使用同时缓存 i 的缓存行。</strong></p>
<p>但是有两种情况下处理器不会使用缓存锁定。</p>
<ul>
<li>第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。</li>
<li>第二种情况是：有些处理器不支持缓存锁定。对于 Intel 486 和 Pentium 处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。</li>
</ul>
</li>
</ol>
<P  id="内存交换你知道有哪些需要注意的关键点吗"></p>
<h3 id="55、内存交换你知道有哪些需要注意的关键点吗？">55、内存交换你知道有哪些需要注意的关键点吗？</h3>
<ol>
<li>交换需要备份存储，通常是快速磁盘，它必须足够大，并且提供对这些内存映像的直接访问。</li>
<li>为了有效使用CPU，需要每个进程的执行时间比交换时间长，而影响交换时间的主要是转移时间，转移时间与所交换的空间内存成正比。</li>
<li>如果换出进程，比如确保该进程的内存空间成正比。</li>
<li>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用就可能很快。</li>
<li>交换通常在有许多进程运行且内存空间吃紧时开始启动，而系统负荷降低就暂停。</li>
<li>普通交换使用不多，但交换的策略的某些变种在许多系统中（如UNIX系统）仍然发挥作用。</li>
</ol>
<p  id="系统并发和并行分得清吗"></p>
<h3 id="56、系统并发和并行，分得清吗？">56、系统并发和并行，分得清吗？</h3>
<p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p>
<p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p>
<p>操作系统通过引入进程和线程，使得程序能够并发运行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700768.png" alt="image-20220308150937867"></p>
<p  id="可能是最全的页面置换算法总结了"></p>
<h3 id="57、可能是最全的页面置换算法总结了">57、可能是最全的页面置换算法总结了</h3>
<h4 id="1、最佳置换法-OPT">1、最佳置换法(OPT)</h4>
<p>最佳置换算法(OPT，Optimal) : 每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。<br>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700207.png" alt=""><br>
最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700372.png" alt="image-20220308151641962"></p>
<h4 id="2、先进先出置换算法-FIFO">2、先进先出置换算法(FIFO)</h4>
<p>先进先出置换算法(FIFO) :每次选择淘汰的页面是最早进入内存的页面<br>
实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面队列的最大长度取决于系统为进程分配了多少个内存块。</p>
<p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@2.8/202104/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-57-2.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@2.8/202104/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-57-3.png" alt=""></p>
<p>Belady 异常：<strong>当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</strong></p>
<p><strong>只有FIFO算法会产生 Belady 异常，而 LRU 和 OPT 算法永远不会出现 Belady 异常</strong>。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差。</p>
<p>FIFO的性能较差，因为较早调入的页往往是经常被访问的页，这些页在 FIFO 算法下被反复调入和调出，并且有 Belady 现象。所谓Belady 现象是指：采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。</p>
<h4 id="3、最近最久未使用置换算法-LRU">3、最近最久未使用置换算法(LRU)</h4>
<p>最近最久未使用置换算法(LRU，least recently used) : 每次淘汰的页面是最近最久未使用的页面</p>
<p>实现方法: 赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间 t (该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大)。当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面。</p>
<p><strong>LRU 性能较好，但需要寄存器和栈的硬件支持</strong>。<strong>LRU是堆栈类算法，理论上可以证明，堆栈类算法不可能出现 Belady 异常</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700859.png" alt=""></p>
<p>在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在逆向扫描过程中最后一个出现的页号就是要淘汰的页面。</p>
<h4 id="4、时钟置换算法-CLOCK">4、时钟置换算法(CLOCK)</h4>
<p>最佳置换算法性OPT能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p>
<p>所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近 LRU 的性能，这类算法都是 CLOCK 算法的变体，因为算法要循环扫描缓冲区像时钟一样转动。所以叫 clock 算法。</p>
<p>时钟置换算法是一种性能和开销较均衡的算法，又称 CLOCK 算法，或最近未用算法(NRU，Not Recently Used)</p>
<p>简单的 CLOCK 算法实现方法: 为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出; 如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是 1，则将这些页面的访问位依次置为 0 后，再进行第二轮扫描(第二轮扫描中一定会有访问位为 0 的页面，因此简单的 CLOCK 算法选择一个淘汰页面最多会经过两轮扫描)</p>
<p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@2.8/202104/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-57-5.png" alt=""></p>
<h4 id="5、改进型的时钟置换算法">5、改进型的时钟置换算法</h4>
<p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过,就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</p>
<p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。修改位=0，表示页面没有被修改过;修改位=1，表示页面被修改过。</p>
<p>为方便讨论，用(访问位，修改位)的形式表示各页面状态。如(1, 1)表示一个页面近期被访问过，且被修改过。</p>
<p>改进型的Clock算法需要综合考虑某一内存页面的访问位和修改位来判断是否置换该页面。在实际编写算法过程中，同样可以用一个等长的整型数组来标识每个内存块的修改状态。访问位A和修改位M可以组成一下四种类型的页面。</p>
<p>算法规则:将所有可能被置换的页面排成–个循环队列</p>
<blockquote>
<p>第一轮:从当前位置开始扫描到第一个(A =0, M = 0)的帧用于替换。表示该页面最近既未被访问，又未被修改，是最佳淘汰页<br>
第二轮:若第一轮扫描失败，则重新扫描，查找第一个(A =1, M = 0)的帧用于替换。本轮将所有扫描过的帧访问位设为0。表示该页面最近未被访问，但已被修改，并不是很好的淘汰页。<br>
第三轮:若第二轮扫描失败，则重新扫描，查找第一个(A =0, M = 1)的帧用于替换。本轮扫描不修改任何标志位。表示该页面最近已被访问，但未被修改，该页有可能再被访问。<br>
第四轮:若第三轮扫描失败，则重新扫描，查找第一个A =1, M = 1)的帧用于替换。表示该页最近已被访问且被修改，该页可能再被访问。</p>
</blockquote>
<p>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择- -个淘汰页面最多会进行四轮扫描</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700377.png" alt=""><br>
算法规则：将所有可能被置换的页面排成一个循环队列<br>
第一轮:从当前位置开始扫描到第-一个(0, 0)的帧用于替换。本轮扫描不修改任何标志位。(第一优先级:最近没访问，且没修改的页面)<br>
第二轮:若第一轮扫描失败，则重新扫描，查找第一个(0, 1)的帧用于替换。本轮将所有扫描过的帧访问位设为0<br>
(第二优先级: 最近没访问，但修改过的页面)<br>
第三轮:若第二轮扫描失败，则重新扫描，查找第一个(0, 0)的帧用于替换。本轮扫描不修改任何标志位(第三优先级:最近访问过，但没修改的页面)<br>
第四轮:若第三轮扫描失败，则重新扫描，查找第一个(0, 1)的帧用于替换。(第四优先级:最近访问过，且修改过的页面)<br>
由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700182.png" alt="image-20220308152502145"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081525019.png" alt="image-20220308152511924"></p>
<h4 id="6、总结">6、总结</h4>
<table>
<thead>
<tr>
<th></th>
<th>算法规则</th>
<th>优缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>OPT</td>
<td>优先淘汰最长时间内不会被访问的页面</td>
<td>缺页率最小，性能最好;但无法实现</td>
</tr>
<tr>
<td>FIFO</td>
<td>优先淘汰最先进入内存的页面</td>
<td>实现简单;但性能很差，可能出现 Belady 异常</td>
</tr>
<tr>
<td>LRU</td>
<td>优先淘汰最近最久没访问的页面</td>
<td>性能很好;但需要硬件支持，算法开销大</td>
</tr>
<tr>
<td>CLOCK (NRU)</td>
<td>循环扫描各页面 第一轮淘汰访问位=0的，并将扫描过的页面访问位改为1。若第-轮没选中，则进行第二轮扫描。</td>
<td>实现简单，算法开销小;但未考虑页面是否被修改过。</td>
</tr>
<tr>
<td>改进型CLOCK (改进型NRU)</td>
<td>若用(访问位，修改位)的形式表述，则 第一轮:淘汰(0,0) 第二轮:淘汰(O,1)，并将扫描过的页面访问位都置为0 第三轮:淘汰(O, 0) 第四轮:淘汰(0, 1)</td>
<td>算法开销较小，性能也不错</td>
</tr>
</tbody>
</table>
<p  id="共享是什么"></p>
<h3 id="58、共享是什么？">58、共享是什么？</h3>
<p>共享是指系统中的资源可以被多个并发进程共同使用。</p>
<p>有两种共享方式：互斥共享和同时共享。</p>
<p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p>
<p  id="死锁相关问题大总结超全"></p>
<h3 id="59、死锁相关问题大总结，超全！">59、死锁相关问题大总结，超全！</h3>
<p><strong>死锁是指两个（多个）线程相互等待对方数据的过程，死锁的产生会导致程序卡死，不解锁程序将永远无法进行下去。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700640.png" alt="image-20220308160653439"></p>
<h4 id="死锁产生原因和-4-个必要条件">死锁产生原因和 4 个必要条件</h4>
<p>举个例子：两个线程 A 和 B，两个数据 1 和 2。线程 A 在执行过程中，首先对资源 1 加锁，然后再去给资源 2 加锁，但是由于线程的切换，导致线程 A 没能给资源 2 加锁。线程切换到 B 后，线程 B 先对资源 2 加锁，然后再去给资源 1 加锁，由于资源 1 已经被线程 A 加锁，因此线程 B 无法加锁成功，当线程切换为 A 时，A 也无法成功对资源 2 加锁，由此就造成了线程 A B 双方相互对一个已加锁资源的等待，死锁产生。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700387.png" alt="image-20220308155030084"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700118.png" alt="image-20220308155042635"></p>
<h4 id="鸵鸟策略"><strong>鸵鸟策略</strong></h4>
<p>把头埋在沙子里，假装根本没发生问题。<br>
因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。<br>
当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。<br>
大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h4 id="死锁检测与死锁恢复"><strong>死锁检测与死锁恢复</strong></h4>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081558218.png" alt="image-20220308155810993"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700298.png" alt="image-20220308155730296"></p>
<p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>
<ol>
<li>
<p><strong>死锁检测：</strong></p>
<ol>
<li>
<p>每种类型一个资源的死锁检测<br>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700090.png" alt=""><br>
上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p>
<p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p>
<p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>
</li>
<li>
<p>每种类型多个资源的死锁检测<br>
<img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/QQ%E6%88%AA%E5%9B%BE20210227001758.png" alt=""><br>
上图中，有三个进程四个资源，每个数据代表的含义如下：</p>
<ul>
<li>
<p>E 向量：资源总量</p>
</li>
<li>
<p>A 向量：资源剩余量</p>
</li>
<li>
<p>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</p>
</li>
<li>
<p>R 矩阵：每个进程请求的资源数量</p>
</li>
</ul>
<p>进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p>算法总结如下：</p>
<p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol>
<li>寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止。</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong>死锁恢复</strong><br>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700215.png" alt="image-20220308160448399"></p>
<ul>
<li>
<p>利用抢占恢复</p>
</li>
<li>
<p>利用回滚恢复</p>
</li>
<li>
<p>通过杀死进程恢复</p>
</li>
</ul>
</li>
</ol>
<h4 id="死锁预防">死锁预防</h4>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700216.png" alt="image-20220308155526780"></p>
<p>在程序运行之前预防发生死锁。</p>
<ol>
<li>破坏互斥条件：例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</li>
<li>破坏请求和保持条件：一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</li>
<li>破坏不剥夺条件：允许抢占资源</li>
<li>破坏循环请求等待：给资源统一编号，进程只能按编号顺序来请求资源。</li>
</ol>
<h4 id="死锁避免">死锁避免</h4>
<p>避免死锁同样属于事先预防策略，但并不是事先采取某种限制措施破坏死锁的必要条件，<strong>而是在资源动态分配过程中， 防止系统进入不安全状态，以避免发生死锁</strong>。这种方法所施加的限制条件较弱，可以获得较好的系统性能。</p>
<ol>
<li>
<p><strong>安全状态</strong><br>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700224.png" alt=""><br>
图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c)；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p>
<p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p>
</li>
<li>
<p><strong>单个资源的银行家算法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700424.png" alt="image-20220308161436345"><br>
一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。<br>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081700494.png" alt=""><br>
上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>
</li>
<li>
<p><strong>多个资源的银行家算法</strong><br>
<img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/QQ%E6%88%AA%E5%9B%BE20210227001939.png" alt=""><br>
上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p>
</li>
<li>
<p><strong>检查一个状态是否安全的算法如下</strong>：</p>
<ul>
<li>
<p>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</p>
</li>
<li>
<p>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</p>
</li>
<li>
<p>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</p>
</li>
</ul>
<p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>
</li>
</ol>
<p  id="为什么分段式存储管理有外部碎片而无内部碎片为什么固定分区分配有内部碎片而不会有外部碎片"></p>
<h3 id="60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？">60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？</h3>
<p>分段式分配是按需分配，而固定式分配是固定分配的方式</p>
<p  id="内部碎片与外部碎片"></p>
<h3 id="61、内部碎片与外部碎片-存储方式与碎片的关系">61、内部碎片与外部碎片,存储方式与碎片的关系</h3>
<ol>
<li>性质不同：<br>
①内存碎片：指的是已经被分配出去的，但是却没有被使用的内存空间。  因为基本存储单位的限制<br>
②外存碎片：指的是还没有被分配的，但是由于太小或者是不连续，而导致不满足要求，所以没办法被分配的内存空间</li>
<li>存储位置不同：<br>
①内存碎片是存储于已分配区域内部的<br>
②外存碎片是存储于未分配区域的</li>
<li>状态不同：<br>
①内存碎片：其他进程没办法使用它，因为它被某一个进程占有<br>
②外存碎片：其他进程没办法使用它，因为它可存储的位置不连续或者是太小了</li>
</ol>
<ul>
<li>分页存储会产生内存碎片、不会产生外存碎片。</li>
<li>分段存储：会产生外存碎片、不会产生内存碎片。</li>
<li>段页式存储：产生内存碎片、外存碎片。</li>
</ul>
<p>内碎片：分配给某些进程的内存区域中有些部分没用上，常见于固定分配方式<br>
内存总量相同，100M<br>
固定分配，将100M分割成10块，每块10M，一个程序需要45M，那么需要分配5块，第五块只用了5M，剩下的5M就是内部碎片；<br>
分段式分配，按需分配，一个程序需要45M，就给分片45MB，剩下的55M供其它程序使用，不存在内部碎片。<br>
外碎片：内存中某些空闲区因为比较小，而难以利用上，一般出现在内存动态分配方式中<br>
分段式分配：内存总量相同，100M，比如，内存分配依次5M，15M，50M，25M，程序运行一段时间之后，5M，15M的程序运行完毕，释放内存，其他程序还在运行，再次分配一个10M的内存供其它程序使用，只能从头开始分片，这样，就会存在10M+5M的外部碎片</p>
<p  id="如何消除碎片文件"></p>
<h3 id="62、如何消除碎片文件">62、如何消除碎片文件</h3>
<p>对于外部碎片，通过<strong>紧凑技术</strong>消除，就是操作系统不时地对进程进行移动和整理。但是这需要动态重定位寄存器地支持，且相对费时。紧凑地过程实际上类似于Windows系统中地磁盘整理程序，只不过后者是对外存空间地紧凑</p>
<p>解决外部内存碎片的问题就是<strong>内存交换</strong>。</p>
<p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p>
<p>回收内存时要尽可能地将相邻的空闲空间合并。</p>
<p  id="冯诺依曼结构有哪几个模块分别对应现代计算机的哪几个部分百度安全一面"></p>
<h3 id="63、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）">63、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）</h3>
<ul>
<li>存储器：内存</li>
<li>控制器：南桥北桥</li>
<li>运算器：CPU</li>
<li>输入设备：键盘</li>
<li>输出设备：显示器、网卡</li>
</ul>
<p  id="多进程和多线程的区别是什么换句话说什么时候该用多线程什么时候该用多进程"></p>
<h3 id="64、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？">64、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？</h3>
<ul>
<li>频繁修改：需要频繁创建和销毁的优先使用<strong>多线程</strong></li>
<li>计算量：需要大量计算的优先使用<strong>多线程</strong>  因为需要消耗大量CPU资源且切换频繁，所以多线程好一点</li>
<li>相关性：任务间相关性比较强的用<strong>多线程</strong>，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。</li>
<li>多分布：可能要扩展到多机分布的用<strong>多进程</strong>，多核分布的用<strong>多线程</strong>。</li>
</ul>
<p>但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。</p>
<p  id="服务器高并发的解决方案你知道多少"></p>
<h3 id="65、服务器高并发的解决方案你知道多少？">65、服务器高并发的解决方案你知道多少？</h3>
<ul>
<li>
<p>应用数据与静态资源分离<br>
将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。</p>
</li>
<li>
<p>客户端缓存<br>
因为效率最高，消耗资源最小的就是纯静态的html页面，所以可以把网站上的页面尽可能用静态的来实现，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。</p>
</li>
<li>
<p>集群和分布式<br>
（集群是所有的服务器都有相同的功能，请求哪台都可以，主要起分流作用）<br><br>
（分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。）<br><br>
可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度。</p>
</li>
<li>
<p>反向代理<br>
在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。</p>
</li>
</ul>
<h3 id="参考文献">参考文献</h3>
<blockquote>
<p>《一个进程到底能创建多少线程》：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Leo_wl/p/5969621.html">https://www.cnblogs.com/Leo_wl/p/5969621.html</a></p>
<p>《操作系统（三）》：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/tutorial/93/675fd4af3ab34b2db0ae650855aa52d5">https://www.nowcoder.com/tutorial/93/675fd4af3ab34b2db0ae650855aa52d5</a></p>
<p>《互斥锁、读写锁、自旋锁、条件变量的特点总结》：<a target="_blank" rel="noopener" href="https://blog.csdn.net/RUN32875094/article/details/80169978">https://blog.csdn.net/RUN32875094/article/details/80169978</a></p>
<p>《linux终端关闭时为什么会导致在其上启动的进程退出？》：<a target="_blank" rel="noopener" href="https://blog.csdn.net/QFire/article/details/80112701">https://blog.csdn.net/QFire/article/details/80112701</a></p>
<p>《Linux系统下创建守护进程(Daemon)》：<a target="_blank" rel="noopener" href="https://blog.csdn.net/linkedin_35878439/article/details/81288889">https://blog.csdn.net/linkedin_35878439/article/details/81288889</a></p>
<p>《01_fork()的使用》：<a target="_blank" rel="noopener" href="https://blog.csdn.net/WUZHU2017/article/details/81636851">https://blog.csdn.net/WUZHU2017/article/details/81636851</a></p>
<p>《学习笔记]进程终止的5种方式》：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/shichuan/p/4432503.html">https://www.cnblogs.com/shichuan/p/4432503.html</a></p>
<p>《Linux内核–异常和中断的区别》：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011068464/article/details/10284741">https://blog.csdn.net/u011068464/article/details/10284741</a></p>
<p>《Linux/windows栈大小》：<a target="_blank" rel="noopener" href="https://blog.csdn.net/HQ354974212/article/details/76087676">https://blog.csdn.net/HQ354974212/article/details/76087676</a></p>
<p>《交换空间和虚拟内存的区别》：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qsd007/article/details/1567955">https://blog.csdn.net/qsd007/article/details/1567955</a></p>
<p>《内存分配方式及常见错误》：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/skynet/archive/2010/12/03/1895045.html">https://www.cnblogs.com/skynet/archive/2010/12/03/1895045.html</a></p>
<p>《原子操作的实现原理》：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zxx901221/article/details/83033998">https://blog.csdn.net/zxx901221/article/details/83033998</a></p>
<p>《字符编码中ASCII、Unicode和UTF-8的区别》：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/moumoon/p/10988234.html">https://www.cnblogs.com/moumoon/p/10988234.html</a></p>
<p>《多进程与多线程》：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yu876876/article/details/82810178">https://blog.csdn.net/yu876876/article/details/82810178</a></p>
<p>《内存分配》：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yusiguyuan/article/details/39496057">https://blog.csdn.net/yusiguyuan/article/details/39496057</a></p>
</blockquote>
<h2 id="huihut-2">huihut</h2>
<h3 id="进程与线程">进程与线程</h3>
<p>对于有线程系统：</p>
<ul>
<li>进程是资源分配的独立单位</li>
<li>线程是资源调度的独立单位</li>
</ul>
<p>对于无线程系统：</p>
<ul>
<li>进程是资源调度、分配的独立单位</li>
</ul>
<h4 id="进程之间的通信方式以及优缺点">进程之间的通信方式以及优缺点</h4>
<h5 id="管道（PIPE）">管道（PIPE）</h5>
<ul>
<li>有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信
<ul>
<li>优点：可以实现任意关系的进程间的通信</li>
<li>缺点：
<ol>
<li>长期存于系统中，使用不当容易出错</li>
<li>缓冲区有限</li>
</ol>
</li>
</ul>
</li>
<li>无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）
<ul>
<li>优点：简单方便</li>
<li>缺点：
<ol>
<li>局限于单向通信</li>
<li>只能创建在它的进程以及其有亲缘关系的进程之间</li>
<li>缓冲区有限</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="信号量（Semaphore）">信号量（Semaphore）</h5>
<ul>
<li>一个计数器，可以用来控制多个线程对共享资源的访问</li>
</ul>
<ul>
<li>优点：可以同步进程</li>
<li>缺点：信号量有限</li>
</ul>
<h5 id="信号（Signal）">信号（Signal）</h5>
<ul>
<li>一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li>
</ul>
<h5 id="消息队列（Message-Queue）">消息队列（Message Queue）</h5>
<ul>
<li>是消息的链表，存放在内核中并由消息队列标识符标识</li>
</ul>
<ul>
<li>优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便</li>
<li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li>
</ul>
<h5 id="共享内存（Shared-Memory）">共享内存（Shared Memory）</h5>
<ul>
<li>映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问</li>
</ul>
<ul>
<li>优点：无须复制，快捷，信息量大</li>
<li>缺点：
<ol>
<li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此需要考虑进程间的读写操作的同步问题</li>
<li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li>
</ol>
</li>
</ul>
<h5 id="套接字（Socket）">套接字（Socket）</h5>
<ul>
<li>可用于不同计算机间的进程通信</li>
</ul>
<ul>
<li>优点：
<ol>
<li>传输数据为字节级，传输数据可自定义，数据量小效率高</li>
<li>传输数据时间短，性能高</li>
<li>适合于客户端和服务器端之间信息实时交互</li>
<li>可以加密,数据安全性强</li>
</ol>
</li>
<li>缺点：需对传输的数据进行解析，转化成应用级的数据。</li>
</ul>
<h4 id="线程之间的通信方式">线程之间的通信方式</h4>
<ul>
<li>锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）
<ul>
<li>互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。</li>
<li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。</li>
<li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ul>
</li>
<li>信号量机制(Semaphore)
<ul>
<li>无名线程信号量</li>
<li>命名线程信号量</li>
</ul>
</li>
<li>信号机制(Signal)：类似进程间的信号处理</li>
<li>屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li>
</ul>
<p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制</p>
<blockquote>
<p>进程之间的通信方式以及优缺点来源于：<a target="_blank" rel="noopener" href="http://blog.csdn.net/wujiafei_njgcxy/article/details/77098977">进程线程面试题总结</a></p>
</blockquote>
<h4 id="进程之间私有和共享的资源">进程之间私有和共享的资源</h4>
<ul>
<li>私有：地址空间、堆、全局变量、栈、寄存器</li>
<li>共享：代码段，公共数据，进程目录，进程 ID</li>
</ul>
<h4 id="线程之间私有和共享的资源">线程之间私有和共享的资源</h4>
<ul>
<li>私有：线程栈，寄存器，程序计数器</li>
<li>共享：堆，地址空间，全局变量，静态变量</li>
</ul>
<h4 id="多进程与多线程间的对比、优劣与选择">多进程与多线程间的对比、优劣与选择</h4>
<h5 id="对比">对比</h5>
<table>
<thead>
<tr>
<th style="text-align:center">对比维度</th>
<th style="text-align:center">多进程</th>
<th style="text-align:center">多线程</th>
<th>总结</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数据共享、同步</td>
<td style="text-align:center">数据共享复杂，需要用 IPC；数据是分开的，同步简单</td>
<td style="text-align:center">因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td>
<td>各有优势</td>
</tr>
<tr>
<td style="text-align:center">内存、CPU</td>
<td style="text-align:center">占用内存多，切换复杂，CPU 利用率低</td>
<td style="text-align:center">占用内存少，切换简单，CPU 利用率高</td>
<td>线程占优</td>
</tr>
<tr>
<td style="text-align:center">创建销毁、切换</td>
<td style="text-align:center">创建销毁、切换复杂，速度慢</td>
<td style="text-align:center">创建销毁、切换简单，速度很快</td>
<td>线程占优</td>
</tr>
<tr>
<td style="text-align:center">编程、调试</td>
<td style="text-align:center">编程简单，调试简单</td>
<td style="text-align:center">编程复杂，调试复杂</td>
<td>进程占优</td>
</tr>
<tr>
<td style="text-align:center">可靠性</td>
<td style="text-align:center">进程间不会互相影响</td>
<td style="text-align:center">一个线程挂掉将导致整个进程挂掉</td>
<td>进程占优</td>
</tr>
<tr>
<td style="text-align:center">分布式</td>
<td style="text-align:center">适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td>
<td style="text-align:center">适应于多核分布式</td>
<td>进程占优</td>
</tr>
</tbody>
</table>
<h5 id="优劣">优劣</h5>
<table>
<thead>
<tr>
<th>优劣</th>
<th>多进程</th>
<th>多线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>编程、调试简单，可靠性较高</td>
<td>创建、销毁、切换速度快，内存、资源占用小</td>
</tr>
<tr>
<td>缺点</td>
<td>创建、销毁、切换速度慢，内存、资源占用大</td>
<td>编程、调试复杂，可靠性较差</td>
</tr>
</tbody>
</table>
<h5 id="选择">选择</h5>
<ul>
<li>需要频繁创建销毁的优先用线程</li>
<li>需要进行大量计算的优先使用线程</li>
<li>强相关的处理用线程，弱相关的处理用进程</li>
<li>可能要扩展到多机分布的用进程，多核分布的用线程</li>
</ul>
<blockquote>
<p>多进程与多线程间的对比、优劣与选择来自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lishenglong666/article/details/8557215">多线程还是多进程的选择及区别</a></p>
</blockquote>
<h3 id="Linux-内核的同步方式">Linux 内核的同步方式</h3>
<h4 id="原因">原因</h4>
<p>在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实像多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。</p>
<h4 id="同步方式">同步方式</h4>
<ul>
<li>原子操作</li>
<li>信号量（semaphore）</li>
<li>读写信号量（rw_semaphore）</li>
<li>自旋锁（spinlock）</li>
<li>大内核锁（BKL，Big Kernel Lock）</li>
<li>读写锁（rwlock）</li>
<li>大读者锁（brlock-Big Reader Lock）</li>
<li>读-拷贝修改(RCU，Read-Copy Update)</li>
<li>顺序锁（seqlock）</li>
</ul>
<blockquote>
<p>来自：<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-synch/part1/">Linux 内核的同步机制，第 1 部分</a>、<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-synch/part2/">Linux 内核的同步机制，第 2 部分</a></p>
</blockquote>
<h3 id="死锁">死锁</h3>
<h4 id="原因-2">原因</h4>
<ul>
<li>系统资源不足</li>
<li>资源分配不当</li>
<li>进程运行推进顺序不合适</li>
</ul>
<h4 id="产生条件">产生条件</h4>
<ul>
<li>互斥</li>
<li>请求和保持</li>
<li>不剥夺</li>
<li>环路等待</li>
</ul>
<h4 id="预防">预防</h4>
<ul>
<li>打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</li>
<li>打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</li>
<li>打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</li>
<li>打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</li>
<li>有序资源分配法</li>
<li>银行家算法</li>
</ul>
<h3 id="文件系统">文件系统</h3>
<ul>
<li>Windows：FCB 表 + FAT + 位图</li>
<li>Unix：inode + 混合索引 + 成组链接</li>
</ul>
<h3 id="主机字节序与网络字节序">主机字节序与网络字节序</h3>
<h4 id="主机字节序（CPU-字节序）">主机字节序（CPU 字节序）</h4>
<h5 id="概念">概念</h5>
<p>主机字节序又叫 CPU 字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。主机字节序分为两种：</p>
<ul>
<li>大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址</li>
<li>小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址</li>
</ul>
<h5 id="存储方式">存储方式</h5>
<p>32 位整数 <code>0x12345678</code> 是从起始位置为 <code>0x00</code> 的地址开始存放，则：</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>0x00</th>
<th>0x01</th>
<th>0x02</th>
<th>0x03</th>
</tr>
</thead>
<tbody>
<tr>
<td>大端</td>
<td>12</td>
<td>34</td>
<td>56</td>
<td>78</td>
</tr>
<tr>
<td>小端</td>
<td>78</td>
<td>56</td>
<td>34</td>
<td>12</td>
</tr>
</tbody>
</table>
<p>大端小端图片</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/CPU-Big-Endian.svg.png" alt="大端序"><br>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203081648277.png" alt="小端序"></p>
<h5 id="判断大端小端">判断大端小端</h5>
<p>判断大端小端</p>
<p>可以这样判断自己 CPU 字节序是大端还是小端：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0x12345678</span>;</span><br><span class="line">	<span class="keyword">if</span> (*((<span class="keyword">char</span>*)&amp;i) == <span class="number">0x12</span>) cout &lt;&lt; <span class="string">&quot;大端&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;小端&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="各架构处理器的字节序">各架构处理器的字节序</h5>
<ul>
<li>x86（Intel、AMD）、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为小端序；</li>
<li>Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC（除 V9 外）等处理器为大端序；</li>
<li>ARM（默认小端序）、PowerPC（除 PowerPC 970 外）、DEC Alpha、SPARC V9、MIPS、PA-RISC 及 IA64 的字节序是可配置的。</li>
</ul>
<h4 id="网络字节序">网络字节序</h4>
<p>网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。</p>
<p>网络字节顺序采用：大端（Big Endian）排列方式。</p>
<h3 id="页面置换算法">页面置换算法</h3>
<p>在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</p>
<h4 id="分类">分类</h4>
<ul>
<li>全局置换：在整个内存空间置换</li>
<li>局部置换：在本进程中进行置换</li>
</ul>
<h4 id="算法">算法</h4>
<p>全局：</p>
<ul>
<li>工作集算法</li>
<li>缺页率置换算法</li>
</ul>
<p>局部：</p>
<ul>
<li>最佳置换算法（OPT）</li>
<li>先进先出置换算法（FIFO）</li>
<li>最近最久未使用（LRU）算法</li>
<li>时钟（Clock）置换算法</li>
</ul>
<h2 id="CS-Notes-2">CS-Notes</h2>
<h3 id="基本特征">基本特征</h3>
<h4 id="1-并发">1. 并发</h4>
<ul>
<li>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</li>
<li>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</li>
<li>操作系统通过引入进程和线程，使得程序能够并发运行。</li>
</ul>
<h4 id="2-共享">2. 共享</h4>
<ul>
<li>共享是指系统中的资源可以被多个并发进程共同使用。</li>
<li>有两种共享方式：互斥共享和同时共享。</li>
<li>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</li>
</ul>
<h4 id="3-虚拟">3. 虚拟</h4>
<ul>
<li>虚拟技术把一个物理实体转换为多个逻辑实体。</li>
<li>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。
<ul>
<li>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</li>
<li>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</li>
</ul>
</li>
</ul>
<h4 id="4-异步">4. 异步</h4>
<ul>
<li>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</li>
</ul>
<h3 id="基本功能">基本功能</h3>
<h4 id="1-进程管理">1. 进程管理</h4>
<ul>
<li>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</li>
</ul>
<h4 id="2-内存管理">2. 内存管理</h4>
<ul>
<li>内存分配、地址映射、内存保护与共享、虚拟内存等。</li>
</ul>
<h4 id="3-文件管理">3. 文件管理</h4>
<ul>
<li>文件存储空间的管理、目录管理、文件读写管理和保护等。</li>
</ul>
<h4 id="4-设备管理">4. 设备管理</h4>
<ul>
<li>
<p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p>
</li>
<li>
<p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p>
</li>
</ul>
<h3 id="系统调用">系统调用</h3>
<p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/tGPV0.png" width="600"/> </div><br>
<p>Linux 的系统调用主要有以下这些：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Task</th>
<th>Commands</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">进程控制</td>
<td>fork(); exit(); wait();</td>
</tr>
<tr>
<td style="text-align:center">进程通信</td>
<td>pipe(); shmget(); mmap();</td>
</tr>
<tr>
<td style="text-align:center">文件操作</td>
<td>open(); read(); write();</td>
</tr>
<tr>
<td style="text-align:center">设备操作</td>
<td>ioctl(); read(); write();</td>
</tr>
<tr>
<td style="text-align:center">信息维护</td>
<td>getpid(); alarm(); sleep();</td>
</tr>
<tr>
<td style="text-align:center">安全</td>
<td>chmod(); umask(); chown();</td>
</tr>
</tbody>
</table>
<h3 id="宏内核和微内核">宏内核和微内核</h3>
<h4 id="1-宏内核">1. 宏内核</h4>
<ul>
<li>宏内核是将操作系统功能作为一个紧密结合的整体放到内核。</li>
<li>由于各模块共享信息，因此有很高的性能。</li>
</ul>
<h4 id="2-微内核">2. 微内核</h4>
<ul>
<li>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</li>
<li>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</li>
<li>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2_14_microkernelArchitecture.jpg"/> </div><br>
<h3 id="中断分类">中断分类</h3>
<h4 id="1-外中断">1. 外中断</h4>
<ul>
<li>由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</li>
</ul>
<h4 id="2-异常">2. 异常</h4>
<ul>
<li>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</li>
</ul>
<h4 id="3-陷入">3. 陷入</h4>
<ul>
<li>在用户程序中使用系统调用。</li>
</ul>
<h3 id="进程与线程-2">进程与线程</h3>
<h4 id="1-进程">1. 进程</h4>
<ul>
<li>进程是资源分配的基本单位。</li>
<li>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</li>
<li>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a6ac2b08-3861-4e85-baa8-382287bfee9f.png"/> </div><br>
<h4 id="2-线程">2. 线程</h4>
<ul>
<li>线程是独立调度的基本单位。</li>
<li>一个进程中可以有多个线程，它们共享进程资源。</li>
<li>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3cd630ea-017c-488d-ad1d-732b4efeddf5.png"/> </div><br>
<h4 id="3-区别">3. 区别</h4>
<p>Ⅰ 拥有资源</p>
<ul>
<li>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</li>
</ul>
<p>Ⅱ 调度</p>
<ul>
<li>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
</ul>
<p>Ⅲ 系统开销</p>
<ul>
<li>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li>
</ul>
<p>Ⅳ 通信方面</p>
<ul>
<li>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</li>
</ul>
<h3 id="进程状态的切换">进程状态的切换</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png" width="500"/> </div><br>
<ul>
<li>就绪状态（ready）：等待被调度</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）：等待资源</li>
</ul>
<p>应该注意以下内容：</p>
<ul>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<h3 id="进程调度算法">进程调度算法</h3>
<p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>
<h4 id="1-批处理系统">1. 批处理系统</h4>
<ul>
<li>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</li>
</ul>
<h5 id="1-1-先来先服务-first-come-first-serverd（FCFS）"><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></h5>
<ul>
<li>
<p>非抢占式的调度算法，按照请求的顺序进行调度。</p>
</li>
<li>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
</li>
</ul>
<h5 id="1-2-短作业优先-shortest-job-first（SJF）"><strong>1.2 短作业优先 shortest job first（SJF）</strong></h5>
<ul>
<li>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
</li>
<li>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
</li>
</ul>
<h5 id="1-3-最短剩余时间优先-shortest-remaining-time-next（SRTN）"><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></h5>
<ul>
<li>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</li>
</ul>
<h4 id="2-交互式系统">2. 交互式系统</h4>
<ul>
<li>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</li>
</ul>
<h5 id="2-1-时间片轮转"><strong>2.1 时间片轮转</strong></h5>
<ul>
<li>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
</li>
<li>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>
<p>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</p>
</li>
<li>
<p>而如果时间片过长，那么实时性就不能得到保证。</p>
</li>
</ul>
</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8c662999-c16c-481c-9f40-1fdba5bc9167.png"/> </div><br>
<h5 id="2-2-优先级调度"><strong>2.2 优先级调度</strong></h5>
<ul>
<li>为每个进程分配一个优先级，按优先级进行调度。</li>
<li>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</li>
</ul>
<h5 id="2-3-多级反馈队列"><strong>2.3 多级反馈队列</strong></h5>
<ul>
<li>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</li>
<li>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,…。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</li>
<li>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</li>
<li>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png"/> </div><br>
<h4 id="3-实时系统">3. 实时系统</h4>
<ul>
<li>实时系统要求一个请求在一个确定时间内得到响应。</li>
<li>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</li>
</ul>
<h3 id="进程同步">进程同步</h3>
<h4 id="1-临界区-2">1. 临界区</h4>
<p>对临界资源进行访问的那段代码称为临界区。</p>
<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// entry section</span><br><span class="line">// critical section;</span><br><span class="line">// exit section</span><br></pre></td></tr></table></figure>
<h4 id="2-同步与互斥-2">2. 同步与互斥</h4>
<ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
<h4 id="3-信号量-2">3. 信号量</h4>
<p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li><strong>down</strong>   : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong>  ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了   <strong>互斥量（Mutex）</strong>  ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt;font size=3&gt;   <strong>使用信号量实现生产者-消费者问题</strong>   &lt;/font&gt; &lt;/br&gt;</p>
<p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
<p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="keyword">int</span> item = produce_item();</span><br><span class="line">        down(&amp;empty);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;full);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-管程-2">4. 管程</h4>
<p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>
<p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">remove</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br></pre></td></tr></table></figure>
<p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p>
<p>管程引入了   <strong>条件变量</strong>   以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p>
<p><font size=3>  <strong>使用管程实现生产者-消费者问题</strong>  </font><br></p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(empty);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span> integer;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N -<span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span>;</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h3 id="经典同步问题">经典同步问题</h3>
<p>生产者和消费者问题前面已经讨论过了。</p>
<h4 id="1-哲学家进餐问题">1. 哲学家进餐问题</h4>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg"/> </div><br>
<p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p>
<p>下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take(i);       <span class="comment">// 拿起左边的筷子</span></span><br><span class="line">        take((i+<span class="number">1</span>)%N); <span class="comment">// 拿起右边的筷子</span></span><br><span class="line">        eat();</span><br><span class="line">        put(i);</span><br><span class="line">        put((i+<span class="number">1</span>)%N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了防止死锁的发生，可以设置两个条件：</p>
<ul>
<li>必须同时拿起左右两根筷子；</li>
<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (i + N - 1) % N <span class="comment">// 左邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (i + 1) % N    <span class="comment">// 右邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING   2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line"><span class="keyword">int</span> state[N];                <span class="comment">// 跟踪每个哲学家的状态</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;         <span class="comment">// 临界区的互斥，临界区是 state 数组，对其修改需要互斥</span></span><br><span class="line">semaphore s[N];              <span class="comment">// 每个哲学家一个信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think(i);</span><br><span class="line">        take_two(i);</span><br><span class="line">        eat(i);</span><br><span class="line">        put_two(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_two</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    check(i);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">    down(&amp;s[i]); <span class="comment">// 只有收到通知之后才可以开始吃，否则会一直等下去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_two</span><span class="params">(i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    check(LEFT); <span class="comment">// 尝试通知左右邻居，自己吃完了，你们可以开始吃了</span></span><br><span class="line">    check(RIGHT);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = EATING;</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(i)</span> </span>&#123;         </span><br><span class="line">    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-读者-写者问题">2. 读者-写者问题</h4>
<p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        read();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        write();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下内容由 <a target="_blank" rel="noopener" href="https://github.com/yugandharbandi">@Bandi Yugandhar</a> 提供。</p>
<p>The first case may result Writer to starve. This case favous Writers i.e no writer, once added to the queue, shall be kept waiting longer than absolutely necessary(only when there are readers that entered the queue before the writer).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readcount, writecount;                   <span class="comment">//(initial value = 0)</span></span><br><span class="line">semaphore rmutex, wmutex, readLock, resource; <span class="comment">//(initial value = 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//READER</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&lt;ENTRY Section&gt;</span><br><span class="line"> down(&amp;readLock);                 <span class="comment">//  reader is trying to enter</span></span><br><span class="line"> down(&amp;rmutex);                  <span class="comment">//   lock to increase readcount</span></span><br><span class="line">  readcount++;                 </span><br><span class="line">  <span class="keyword">if</span> (readcount == <span class="number">1</span>)          </span><br><span class="line">   down(&amp;resource);              <span class="comment">//if you are the first reader then lock  the resource</span></span><br><span class="line"> up(&amp;rmutex);                  <span class="comment">//release  for other readers</span></span><br><span class="line"> up(&amp;readLock);                 <span class="comment">//Done with trying to access the resource</span></span><br><span class="line"></span><br><span class="line">&lt;CRITICAL Section&gt;</span><br><span class="line"><span class="comment">//reading is performed</span></span><br><span class="line"></span><br><span class="line">&lt;EXIT Section&gt;</span><br><span class="line"> down(&amp;rmutex);                  <span class="comment">//reserve exit section - avoids race condition with readers</span></span><br><span class="line"> readcount--;                       <span class="comment">//indicate you&#x27;re leaving</span></span><br><span class="line">  <span class="keyword">if</span> (readcount == <span class="number">0</span>)          <span class="comment">//checks if you are last reader leaving</span></span><br><span class="line">   up(&amp;resource);              <span class="comment">//if last, you must release the locked resource</span></span><br><span class="line"> up(&amp;rmutex);                  <span class="comment">//release exit section for other readers</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//WRITER</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &lt;ENTRY Section&gt;</span><br><span class="line">  down(&amp;wmutex);                  <span class="comment">//reserve entry section for writers - avoids race conditions</span></span><br><span class="line">  writecount++;                <span class="comment">//report yourself as a writer entering</span></span><br><span class="line">  <span class="keyword">if</span> (writecount == <span class="number">1</span>)         <span class="comment">//checks if you&#x27;re first writer</span></span><br><span class="line">   down(&amp;readLock);               <span class="comment">//if you&#x27;re first, then you must lock the readers out. Prevent them from trying to enter CS</span></span><br><span class="line">  up(&amp;wmutex);                  <span class="comment">//release entry section</span></span><br><span class="line"></span><br><span class="line">&lt;CRITICAL Section&gt;</span><br><span class="line"> down(&amp;resource);                <span class="comment">//reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource</span></span><br><span class="line">  <span class="comment">//writing is performed</span></span><br><span class="line"> up(&amp;resource);                <span class="comment">//release file</span></span><br><span class="line"></span><br><span class="line">&lt;EXIT Section&gt;</span><br><span class="line">  down(&amp;wmutex);                  <span class="comment">//reserve exit section</span></span><br><span class="line">  writecount--;                <span class="comment">//indicate you&#x27;re leaving</span></span><br><span class="line">  <span class="keyword">if</span> (writecount == <span class="number">0</span>)         <span class="comment">//checks if you&#x27;re the last writer</span></span><br><span class="line">   up(&amp;readLock);               <span class="comment">//if you&#x27;re last writer, you must unlock the readers. Allows them to try enter CS for reading</span></span><br><span class="line">  up(&amp;wmutex);                  <span class="comment">//release exit section</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We can observe that every reader is forced to acquire ReadLock. On the otherhand, writers doesn’t need to lock individually. Once the first writer locks the ReadLock, it will be released only when there is no writer left in the queue.</p>
<p>From the both cases we observed that either reader or writer has to starve. Below solutionadds the constraint that no thread shall be allowed to starve; that is, the operation of obtaining a lock on the shared data will always terminate in a bounded amount of time.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">int readCount;                  // init to 0; number of readers currently accessing resource</span><br><span class="line"></span><br><span class="line">// all semaphores initialised to 1</span><br><span class="line">Semaphore resourceAccess;       // controls access (read/write) to the resource</span><br><span class="line">Semaphore readCountAccess;      // for syncing changes to shared variable readCount</span><br><span class="line">Semaphore serviceQueue;         // FAIRNESS: preserves ordering of requests (signaling must be FIFO)</span><br><span class="line"></span><br><span class="line">void writer()</span><br><span class="line">&#123; </span><br><span class="line">    down(&amp;serviceQueue);           // wait in line to be servicexs</span><br><span class="line">    // &lt;ENTER&gt;</span><br><span class="line">    down(&amp;resourceAccess);         // request exclusive access to resource</span><br><span class="line">    // &lt;/ENTER&gt;</span><br><span class="line">    up(&amp;serviceQueue);           // let next in line be serviced</span><br><span class="line"></span><br><span class="line">    // &lt;WRITE&gt;</span><br><span class="line">    writeResource();            // writing is performed</span><br><span class="line">    // &lt;/WRITE&gt;</span><br><span class="line"></span><br><span class="line">    // &lt;EXIT&gt;</span><br><span class="line">    up(&amp;resourceAccess);         // release resource access for next reader/writer</span><br><span class="line">    // &lt;/EXIT&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reader()</span><br><span class="line">&#123; </span><br><span class="line">    down(&amp;serviceQueue);           // wait in line to be serviced</span><br><span class="line">    down(&amp;readCountAccess);        // request exclusive access to readCount</span><br><span class="line">    // &lt;ENTER&gt;</span><br><span class="line">    if (readCount == 0)         // if there are no readers already reading:</span><br><span class="line">        down(&amp;resourceAccess);     // request resource access for readers (writers blocked)</span><br><span class="line">    readCount++;                // update count of active readers</span><br><span class="line">    // &lt;/ENTER&gt;</span><br><span class="line">    up(&amp;serviceQueue);           // let next in line be serviced</span><br><span class="line">    up(&amp;readCountAccess);        // release access to readCount</span><br><span class="line"></span><br><span class="line">    // &lt;READ&gt;</span><br><span class="line">    readResource();             // reading is performed</span><br><span class="line">    // &lt;/READ&gt;</span><br><span class="line"></span><br><span class="line">    down(&amp;readCountAccess);        // request exclusive access to readCount</span><br><span class="line">    // &lt;EXIT&gt;</span><br><span class="line">    readCount--;                // update count of active readers</span><br><span class="line">    if (readCount == 0)         // if there are no readers left:</span><br><span class="line">        up(&amp;resourceAccess);     // release resource access for all</span><br><span class="line">    // &lt;/EXIT&gt;</span><br><span class="line">    up(&amp;readCountAccess);        // release access to readCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="进程通信">进程通信</h3>
<p>进程同步与进程通信很容易混淆，它们的区别在于：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间传输信息。</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<h4 id="1-管道">1. 管道</h4>
<p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>它具有以下限制：</p>
<ul>
<li>只支持半双工通信（单向交替传输）；</li>
<li>只能在父子进程或者兄弟进程中使用。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png"/> </div><br>
<h4 id="2-FIFO">2. FIFO</h4>
<p>也称为命名管道，去除了管道只能在父子进程中使用的限制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png"/> </div><br>
<h4 id="3-消息队列">3. 消息队列</h4>
<p>相比于 FIFO，消息队列具有以下优点：</p>
<ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li>
</ul>
<h4 id="4-信号量">4. 信号量</h4>
<p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p>
<h4 id="5-共享存储">5. 共享存储</h4>
<p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p>
<p>需要使用信号量用来同步对共享存储的访问。</p>
<p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p>
<h4 id="6-套接字">6. 套接字</h4>
<p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p>
<h3 id="死锁必要条件">死锁必要条件</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c037c901-7eae-4e31-a1e4-9d41329e5c3e.png"/> </div><br>
<ul>
<li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li>
<li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li>
<li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<h3 id="死锁处理方法">死锁处理方法</h3>
<p>主要有以下四种方法：</p>
<ul>
<li>鸵鸟策略</li>
<li>死锁检测与死锁恢复</li>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
<h4 id="鸵鸟策略-2">鸵鸟策略</h4>
<p>把头埋在沙子里，假装根本没发生问题。</p>
<p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p>
<p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h4 id="死锁检测与死锁恢复-2">死锁检测与死锁恢复</h4>
<p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>
<h5 id="1-每种类型一个资源的死锁检测">1. 每种类型一个资源的死锁检测</h5>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1fa0453-a4b0-4eae-a352-48acca8fff74.png"/> </div><br>
<p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p>
<p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p>
<p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>
<h5 id="2-每种类型多个资源的死锁检测">2. 每种类型多个资源的死锁检测</h5>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png"/> </div><br>
<p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量</li>
</ul>
<p>进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p>算法总结如下：</p>
<p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol>
<li>寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止。</li>
</ol>
<h5 id="3-死锁恢复">3. 死锁恢复</h5>
<ul>
<li>利用抢占恢复</li>
<li>利用回滚恢复</li>
<li>通过杀死进程恢复</li>
</ul>
<h3 id="死锁预防-2">死锁预防</h3>
<p>在程序运行之前预防发生死锁。</p>
<h4 id="1-破坏互斥条件">1. 破坏互斥条件</h4>
<p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p>
<h4 id="2-破坏占有和等待条件">2. 破坏占有和等待条件</h4>
<p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p>
<h4 id="3-破坏不可抢占条件">3. 破坏不可抢占条件</h4>
<h4 id="4-破坏环路等待">4. 破坏环路等待</h4>
<p>给资源统一编号，进程只能按编号顺序来请求资源。</p>
<h3 id="死锁避免-2">死锁避免</h3>
<p>在程序运行时避免发生死锁。</p>
<h4 id="1-安全状态">1. 安全状态</h4>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed523051-608f-4c3f-b343-383e2d194470.png"/> </div><br>
<p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p>
<p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p>
<h4 id="2-单个资源的银行家算法">2. 单个资源的银行家算法</h4>
<p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png"/> </div><br>
<p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>
<h4 id="3-多个资源的银行家算法">3. 多个资源的银行家算法</h4>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png"/> </div><br>
<p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p>
<p>检查一个状态是否安全的算法如下：</p>
<ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>
</ul>
<p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>
<h3 id="虚拟内存">虚拟内存</h3>
<p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7b281b1e-0595-402b-ae35-8c91084c33c1.png"/> </div><br>
<h3 id="分页系统地址映射">分页系统地址映射</h3>
<p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p>
<p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p>
<p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" width="500"/> </div><br>
<h3 id="页面置换算法-2">页面置换算法</h3>
<p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p>
<p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p>
<p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p>
<h4 id="1-最佳">1. 最佳</h4>
<blockquote>
<p>OPT, Optimal replacement algorithm</p>
</blockquote>
<p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p>
<p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p>
<p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</span><br></pre></td></tr></table></figure>
<p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p>
<h4 id="2-最近最久未使用">2. 最近最久未使用</h4>
<blockquote>
<p>LRU, Least Recently Used</p>
</blockquote>
<p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p>
<p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p>
<p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4，7，0，7，1，0，1，2，1，2，6</span><br></pre></td></tr></table></figure>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eb859228-c0f2-4bce-910d-d9f76929352b.png"/> </div><br>
<h4 id="3-最近未使用">3. 最近未使用</h4>
<blockquote>
<p>NRU, Not Recently Used</p>
</blockquote>
<p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p>
<ul>
<li>R=0，M=0</li>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
<p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>
<p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p>
<h4 id="4-先进先出">4. 先进先出</h4>
<blockquote>
<p>FIFO, First In First Out</p>
</blockquote>
<p>选择换出的页面是最先进入的页面。</p>
<p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p>
<h4 id="5-第二次机会算法">5. 第二次机会算法</h4>
<p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p>
<p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png"/> </div><br>
<h4 id="6-时钟">6. 时钟</h4>
<blockquote>
<p>Clock</p>
</blockquote>
<p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png"/> </div><br>
<h3 id="分段">分段</h3>
<p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p>
<p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22de0538-7c6e-4365-bd3b-8ce3c5900216.png"/> </div><br>
<p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png"/> </div><br>
<h3 id="段页式">段页式</h3>
<p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p>
<h3 id="分页与分段的比较">分页与分段的比较</h3>
<ul>
<li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li>
<li>地址空间的维度：分页是一维地址空间，分段是二维的。</li>
<li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li>
<li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li>
</ul>
<h3 id="磁盘结构">磁盘结构</h3>
<ul>
<li>盘面（Platter）：一个磁盘有多个盘面；</li>
<li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li>
<li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li>
<li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li>
<li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li>
<li>主轴（Spindle）：使整个盘面转动。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/014fbc4d-d873-4a12-b160-867ddaed9807.jpg"/> </div><br>
<h3 id="磁盘调度算法">磁盘调度算法</h3>
<p>读写一个磁盘块的时间的影响因素有：</p>
<ul>
<li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li>
<li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li>实际的数据传输时间</li>
</ul>
<p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<h4 id="1-先来先服务-2">1. 先来先服务</h4>
<blockquote>
<p>FCFS, First Come First Served</p>
</blockquote>
<p>按照磁盘请求的顺序进行调度。</p>
<p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>
<h4 id="2-最短寻道时间优先-2">2. 最短寻道时间优先</h4>
<blockquote>
<p>SSTF, Shortest Seek Time First</p>
</blockquote>
<p>优先调度与当前磁头所在磁道距离最近的磁道。</p>
<p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4e2485e4-34bd-4967-9f02-0c093b797aaa.png"/> </div><br>
<h4 id="3-电梯算法">3. 电梯算法</h4>
<blockquote>
<p>SCAN</p>
</blockquote>
<p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p>
<p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p>
<p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/271ce08f-c124-475f-b490-be44fedc6d2e.png"/> </div><br>
<h3 id="编译系统">编译系统</h3>
<p>以下是一个 hello.c 程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure>
<p>这个过程大致如下：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg" width="800"/> </div><br>
<ul>
<li>预处理阶段：处理以 # 开头的预处理命令；</li>
<li>编译阶段：翻译成汇编文件；</li>
<li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li>
<li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li>
</ul>
<h3 id="静态链接">静态链接</h3>
<p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p>
<ul>
<li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li>
<li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/47d98583-8bb0-45cc-812d-47eefa0a4a40.jpg"/> </div><br>
<h3 id="目标文件">目标文件</h3>
<ul>
<li>可执行目标文件：可以直接在内存中执行；</li>
<li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li>
<li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li>
</ul>
<h3 id="动态链接">动态链接</h3>
<p>静态库有以下两个问题：</p>
<ul>
<li>当静态库更新时那么整个程序都要重新进行链接；</li>
<li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li>
</ul>
<p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p>
<ul>
<li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li>
<li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/76dc7769-1aac-4888-9bea-064f1caa8e77.jpg"/> </div><br>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">SEUGarfield</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.zgzheng.top/posts/64104/">https://blog.zgzheng.top/posts/64104/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.zgzheng.top" target="_blank">笑枕晚风の小站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203122101249.jpg" data-sites="facebook,twitter,wechat,weibo,qq,qzone,douban"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/42685/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203122058974.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络知识点笔记</div></div></a></div><div class="next-post pull-right"><a href="/posts/41181/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202111182200603.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">一文吃透字符串匹配！</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202110251550056.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">SEUGarfield</div><div class="author-info__description">欢迎乘坐猫巴士</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">93</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zgzhengSEU"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zgzhengSEU" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:DedSec@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">决定转码啦，建个博客记录学习过程，持续更新ing<div class="twopeople"><div class="container" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width:200px; max-height:200px; touch-action:none;width:640px;height:640px;"></canvas></div><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js"></script><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js"></script><script id="rendered-js" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center;}canvas {display:block;margin:0 auto;cursor:move;}</style></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">操作系统知识点总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TopK"><span class="toc-text">TopK</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1、进程和线程之间有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TopK-2"><span class="toc-text">TopK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CS-Notes"><span class="toc-text">CS-Notes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BF%E7%A7%80"><span class="toc-text">阿秀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%9B%E5%AE%A2"><span class="toc-text">牛客</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">2、进程间有哪些通信方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%9B%E5%AE%A2-2"><span class="toc-text">牛客</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BF%E7%A7%80-2"><span class="toc-text">阿秀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#huihut"><span class="toc-text">huihut</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%AE%80%E8%BF%B0-select-poll-epoll-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB%EF%BC%8Cepoll-%E4%B8%AD%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E4%BB%A5%E5%8F%8A%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">3、简述 select, poll, epoll 的使用场景以及区别，epoll 中水平触发以及边缘触发有什么不同？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E9%98%BB%E5%A1%9E-I-O-%E5%88%B0-I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">从阻塞 I&#x2F;O 到 I&#x2F;O 多路复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%86%85%E9%83%A8%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E9%9D%9E%E9%98%BB%E5%A1%9E-I-O"><span class="toc-text">为什么 I&#x2F;O 多路复用内部需要使用非阻塞 I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select"><span class="toc-text">select</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D%E4%B8%8E%E5%8F%82%E6%95%B0"><span class="toc-text">函数签名与参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-fd"><span class="toc-text">什么是文件描述符 fd</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#socket-%E4%B8%8E-fd-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">socket 与 fd 的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fd-set-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86%E5%90%88"><span class="toc-text">fd_set 文件描述符集合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#select-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">select 使用示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#select-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">select 的缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll"><span class="toc-text">poll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll"><span class="toc-text">epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll-create"><span class="toc-text">epoll_create</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll-ctl"><span class="toc-text">epoll_ctl</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll-wait"><span class="toc-text">epoll_wait</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">epoll 的优点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E3%80%81%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91"><span class="toc-text">水平触发、边缘触发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8%E9%9D%9E%E9%98%BB%E5%A1%9E-I-O%EF%BC%9F"><span class="toc-text">为什么边缘触发必须使用非阻塞 I&#x2F;O？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E8%80%85%E5%AF%B9%E6%AF%94"><span class="toc-text">三者对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-text">Linux 高性能服务器编程中的解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81select%E3%80%81poll%E3%80%81epoll%E7%AE%80%E4%BB%8B"><span class="toc-text">1、select、poll、epoll简介</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-select"><span class="toc-text">1.1 select</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-poll"><span class="toc-text">1.2 poll</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-epoll"><span class="toc-text">1.3 epoll</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81select%E3%80%81poll%E3%80%81epoll%E5%8C%BA%E5%88%AB"><span class="toc-text">2、select、poll、epoll区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%AE%80%E8%BF%B0-Linux-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-text">4、简述 Linux  进程调度的算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E7%AE%80%E8%BF%B0%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84-Linux-%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">5、简述几个常用的  Linux 命令以及他们的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E7%AE%80%E8%BF%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">6、简述操作系统如何进行内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%8C%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2"><span class="toc-text">7、线程有多少种状态，状态之间如何转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">8、线程间有哪些通信方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E7%AE%80%E8%BF%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD"><span class="toc-text">9、简述操作系统中的缺页中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E7%94%B1%E7%94%A8%E6%88%B7%E6%80%81%E9%99%B7%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9F"><span class="toc-text">10、什么时候会由用户态陷入内核态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-text">11、进程有多少种状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81Linux-%E4%B8%8B%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%93%AA%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8%EF%BC%9F"><span class="toc-text">12、Linux  下如何查看端口被哪个进程占用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E6%98%A0%E5%B0%84%EF%BC%9F"><span class="toc-text">13、操作系统中，虚拟地址与物理地址之间如何映射？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E7%AE%80%E8%BF%B0-Linux-%E7%B3%BB%E7%BB%9F%E6%80%81%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%BF%9B%E5%85%A5%E7%B3%BB%E7%BB%9F%E6%80%81%EF%BC%9F"><span class="toc-text">14、简述 Linux 系统态与用户态，什么时候会进入系统态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81%E7%AE%80%E8%BF%B0%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">15、简述同步与异步的区别，阻塞与非阻塞的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E6%93%8D%E4%BD%9C"><span class="toc-text">IO操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5IO-%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="toc-text">同步和异步IO 阻塞和非阻塞IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%EF%BC%88%E7%BA%BF%E7%A8%8B%E9%97%B4%E8%B0%83%E7%94%A8%EF%BC%89"><span class="toc-text">同步与异步（线程间调用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%86%85%E8%B0%83%E7%94%A8%EF%BC%89"><span class="toc-text">阻塞与非阻塞（线程内调用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8-%E7%BA%BF%E7%A8%8B-%E9%80%9A%E4%BF%A1"><span class="toc-text">同步与异步调用&#x2F;线程&#x2F;通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E7%BB%84%E5%90%88%E6%96%B9%E5%BC%8F"><span class="toc-text">四种组合方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81Linux-%E4%B8%AD%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8C%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-text">16、Linux 中虚拟内存和物理内存有什么区别？有什么优点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81%E7%AE%80%E8%BF%B0-Linux-%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">17、简述 Linux 零拷贝的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">19、多线程和多进程的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81BIO%E3%80%81NIO-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%86%99%E6%96%87%E4%BB%B6%E6%97%B6-Buffer-%E5%B7%B2%E7%BB%8F%E5%86%99%E6%BB%A1%EF%BC%9F%E7%AE%80%E8%BF%B0-Linux-%E7%9A%84-IO-%E6%A8%A1%E5%9E%8B"><span class="toc-text">20、BIO、NIO 有什么区别？怎么判断写文件时 Buffer 已经写满？简述 Linux 的 IO 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81%E7%AE%80%E8%BF%B0%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">21、简述自旋锁与互斥锁的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81%E7%AE%80%E8%BF%B0-mmap-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-text">22、简述 mmap 的使用场景以及原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81%E7%AE%80%E8%BF%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD-malloc-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">23、简述操作系统中 malloc 的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-text">结论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%86%85%E5%AE%B9"><span class="toc-text">具体内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">内存分配的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-text">具体分配过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%B8%80%EF%BC%9Amalloc-%E5%B0%8F%E4%BA%8E-128K-%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%8C%E4%BD%BF%E7%94%A8-brk-%E5%88%86%E9%85%8D"><span class="toc-text">情况一：malloc 小于 128K 的内存，使用 brk 分配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%BA%8C%EF%BC%9Amalloc-%E5%A4%A7%E4%BA%8E-128K-%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%8C%E4%BD%BF%E7%94%A8-mmap-%E5%88%86%E9%85%8D%EF%BC%88munmap-%E9%87%8A%E6%94%BE%EF%BC%89"><span class="toc-text">情况二：malloc 大于 128K 的内存，使用 mmap 分配（munmap 释放）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81Linux-%E4%B8%8B%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5-CPU-%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%9A%EF%BC%9F"><span class="toc-text">24、Linux 下如何排查 CPU 以及内存占用过多？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E4%B8%80%E4%B8%AA%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F"><span class="toc-text">25、两个线程交替打印一个共享变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">26、进程通信中的管道实现原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E3%80%81Linux-%E4%B8%8B%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B-CPU-%E8%8D%B7%E8%BD%BD%EF%BC%8C%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-text">27、Linux 下如何查看 CPU 荷载，正在运行的进程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28%E3%80%81%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">28、共享内存是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29%E3%80%81%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">29、如何调试服务器内存占用过高的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30%E3%80%81Linux-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E5%AE%9E%E6%97%B6%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%97%A5%E5%BF%97%EF%BC%9F"><span class="toc-text">30、Linux 如何查看实时的滚动日志？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E6%85%A2%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%BF%AB%EF%BC%9F"><span class="toc-text">31、为什么进程切换慢，线程切换快？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E3%80%81%E7%AE%80%E8%BF%B0%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">32、简述创建进程的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33%E3%80%81%E7%AE%80%E8%BF%B0-Linux-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">33、简述 Linux 虚拟内存的页面置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34%E3%80%81%E7%AE%80%E8%BF%B0-CPU-L1-L2-L3-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%9C%E7%94%A8"><span class="toc-text">34、简述 CPU  L1, L2, L3 多级缓存的基本作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35%E3%80%81malloc-%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%A0%86%E8%BF%98%E6%98%AF%E6%A0%88%E4%B8%AD%EF%BC%9F"><span class="toc-text">35、malloc 创建的对象在堆还是栈中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36%E3%80%81%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4%E4%BB%8E%E9%AB%98%E4%BD%8D%E5%88%B0%E4%BD%8E%E4%BD%8D%E9%83%BD%E6%9C%89%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">36、进程空间从高位到低位都有些什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%E4%BC%9A%E8%BF%9B%E8%A1%8C%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="toc-text">37、什么情况下，进程会进行切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39%E3%80%81%E7%AE%80%E8%BF%B0-traceroute-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">39、简述 traceroute 命令的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40%E3%80%81Linux-%E9%A1%B5%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">40、Linux 页大小是多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">41、信号量是如何实现的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%9B%E5%AE%A2-3"><span class="toc-text">牛客</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Linux%E4%B8%AD%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E7%9A%84%E6%8C%87%E4%BB%A4%E3%80%81%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E7%9A%84%E6%8C%87%E4%BB%A4%E3%80%81tar%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%82%E6%95%B0%E3%80%82"><span class="toc-text">1、Linux中查看进程运行状态的指令、查看内存使用情况的指令、tar解压文件的参数。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E6%80%8E%E4%B9%88%E4%BF%AE%E6%94%B9"><span class="toc-text">2、文件权限怎么修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84Linux%E5%91%BD%E4%BB%A4"><span class="toc-text">3、常用的Linux命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%A6%82%E4%BD%95%E4%BB%A5root%E6%9D%83%E9%99%90%E8%BF%90%E8%A1%8C%E6%9F%90%E4%B8%AA%E7%A8%8B%E5%BA%8F%E3%80%82"><span class="toc-text">4、如何以root权限运行某个程序。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-text">5、软链接和硬链接的区别。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E6%80%8E%E4%B9%88%E5%88%B6%E4%BD%9C%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E3%80%82"><span class="toc-text">6、静态库和动态库怎么制作及如何使用，区别是什么。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81GDB%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9%EF%BC%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E3%80%82"><span class="toc-text">7、GDB常见的调试命令，什么是条件断点，多进程下如何调试。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%EF%BC%9F"><span class="toc-text">8、什么是大端小端，如何判断大端小端？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">9、进程调度算法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%BB%A5%E5%8F%8A%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%EF%BC%9F"><span class="toc-text">10、操作系统如何申请以及管理内存的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E6%80%81%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%BF%9B%E5%85%A5%E7%B3%BB%E7%BB%9F%E6%80%81%EF%BC%9F"><span class="toc-text">11、Linux系统态与用户态，什么时候会进入系统态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81LRU-%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E3%80%82"><span class="toc-text">12、LRU 算法及其实现方式。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%8D%A0%E5%A4%9A%E5%A4%A7%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-text">13、一个线程占多大内存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%A1%B5%E8%A1%A8%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%EF%BC%9F"><span class="toc-text">14、什么是页表，为什么要有？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E3%80%82"><span class="toc-text">15、操作系统中的缺页中断。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E7%94%B1%E7%94%A8%E6%88%B7%E6%80%81%E9%99%B7%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9F"><span class="toc-text">16、虚拟内存分布，什么时候会由用户态陷入内核态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8C%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%8C%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">17、虚拟内存和物理内存，为什么要用虚拟内存，好处是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E6%80%8E%E4%B9%88%E6%98%A0%E5%B0%84%E7%9A%84%EF%BC%9F"><span class="toc-text">18、虚拟地址到物理地址怎么映射的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81%E5%A0%86%E6%A0%88%E6%BA%A2%E5%87%BA%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="toc-text">19、堆栈溢出是什么，会怎么样？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%ADmalloc%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">20、操作系统中malloc的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4%E4%BB%8E%E9%AB%98%E4%BD%8D%E5%88%B0%E4%BD%8E%E4%BD%8D%E9%83%BD%E6%9C%89%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">21、进程空间从高位到低位都有些什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%8132%E4%BD%8D%E7%B3%BB%E7%BB%9F%E8%83%BD%E8%AE%BF%E9%97%AE4GB%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%86%85%E5%AD%98%E5%90%97%EF%BC%9F"><span class="toc-text">22、32位系统能访问4GB以上的内存吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-text">23、并发和并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">24、进程、线程、协程是什么，区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81Linux%E7%9A%84fork%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">25、Linux的fork的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-text">26、什么是孤儿进程，什么是僵尸进程，如何解决僵尸进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">27、什么是守护进程，如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28%E3%80%81%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">28、进程通信的方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29%E3%80%81%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">29、进程同步的方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30%E3%80%81Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%8F%8A%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">30、Linux进程调度算法及策略有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E3%80%81%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-text">31、进程有多少种状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E3%80%81%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">32、进程通信中的管道实现原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33%E3%80%81mmap%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">33、mmap的原理和使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34%E3%80%81%E4%BA%92%E6%96%A5%E9%87%8F%E8%83%BD%E4%B8%8D%E8%83%BD%E5%9C%A8%E8%BF%9B%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">34、互斥量能不能在进程中使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35%E3%80%81%E5%8D%8F%E7%A8%8B%E6%98%AF%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%A1%A8%E7%8E%B0%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-text">35、协程是轻量级线程，轻量级表现在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36%E3%80%81%E5%B8%B8%E8%A7%81%E4%BF%A1%E5%8F%B7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E8%A1%A8%E7%A4%BA%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89%EF%BC%9F"><span class="toc-text">36、常见信号有哪些，表示什么含义？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37%E3%80%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">37、线程间通信的方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">38、线程同步方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%8C%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">39、什么是死锁，产生的条件，如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40%E3%80%81%E6%9C%89%E4%BA%86%E8%BF%9B%E7%A8%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">40、有了进程，为什么还要有线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41%E3%80%81%E5%8D%95%E6%A0%B8%E6%9C%BA%E5%99%A8%E4%B8%8A%E5%86%99%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%EF%BC%8C%E6%98%AF%E5%90%A6%E8%A6%81%E8%80%83%E8%99%91%E5%8A%A0%E9%94%81%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">41、单核机器上写多线程程序，是否要考虑加锁，为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">42、多线程和多进程的不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43%E3%80%81%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E6%9C%BA%E5%88%B6%EF%BC%8C%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E8%AF%BB%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">43、互斥锁的机制，互斥锁与读写的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">44、什么是信号量，有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E5%88%87%E6%8D%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">45、进程、线程的中断切换的过程是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">46、自旋锁和互斥锁的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47%E3%80%81%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%8C%E7%9B%B8%E4%BA%92%E4%B9%8B%E9%97%B4%E6%80%8E%E4%B9%88%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-text">47、线程有哪些状态，相互之间怎么转换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%94%81%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">48、多线程和单线程有什么区别，多线程编程要注意什么，多线程加锁需要注意什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49%E3%80%81sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">49、sleep和wait的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F%E7%94%B1%E4%BB%80%E4%B9%88%E7%A1%AE%E5%AE%9A%EF%BC%9F"><span class="toc-text">50、线程池的设计思路，线程池中线程的数量由什么确定？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9B%B8%E6%AF%94%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%85%A2%EF%BC%9F"><span class="toc-text">51、进程和线程相比，为什么慢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52%E3%80%81Linux%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">52、Linux零拷贝的原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53%E3%80%81epoll-%E5%92%8C-select-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8Cepoll-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%AB%98%E6%95%88%EF%BC%9F"><span class="toc-text">53、epoll 和 select 的区别，epoll 为什么高效？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54%E3%80%81%E5%A4%9A%E8%B7%AFIO%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">54、多路IO复用技术有哪些，区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55%E3%80%81socket%E4%B8%ADselect%EF%BC%8Cepoll%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%8Cepoll%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E4%B8%8E%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">55、socket中select，epoll的使用场景和区别，epoll水平触发与边缘触发的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56%E3%80%81Reactor%E3%80%81Proactor%E6%A8%A1%E5%BC%8F%E3%80%82"><span class="toc-text">56、Reactor、Proactor模式。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57%E3%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">57、同步与异步的区别，阻塞与非阻塞的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58%E3%80%81BIO%E3%80%81NIO%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">58、BIO、NIO有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59%E3%80%815%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="toc-text">59、5种IO模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60%E3%80%81socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%94%A8%E5%88%B0%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">60、socket网络编程中客户端和服务端用到哪些函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#61%E3%80%81%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%EF%BC%8C%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">61、网络七层参考模型，每一层的作用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BF%E7%A7%80-3"><span class="toc-text">阿秀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-text">1、进程、线程和协程的区别和联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">2、线程与进程的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%92%8C%E4%BB%80%E4%B9%88%E6%9C%89%E5%85%B3%EF%BC%9F"><span class="toc-text">3、一个进程可以创建多少线程，和什么有关？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%A4%96%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4、外中断和异常有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%BD%A0%E7%9F%A5%E9%81%93%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">5、进程线程模型你知道多少？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-text">多进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">多线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">6、进程调度算法你了解多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81Linux-%E4%B8%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">7、Linux 下进程间通信方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81Linux-%E4%B8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">8、Linux 下同步机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E5%A6%82%E6%9E%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E5%90%8E%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90%E4%BB%80%E4%B9%88%E6%A0%B7%E4%BA%86%EF%BC%9F"><span class="toc-text">9、如果系统中具有快表后，那么地址的转换过程变成什么样了？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E5%92%8C%E8%A6%86%E7%9B%96%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">10、内存交换和覆盖有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F%E5%8F%AF%E4%BB%A5%E5%88%86%E5%88%AB%E8%AF%B4%E8%AF%B4%E5%90%97%EF%BC%9F"><span class="toc-text">11、动态分区分配算法有哪几种？可以分别说说吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-text">1、首次适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-text">2、最佳适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-text">3、最坏适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-text">4、邻近适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">5、总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">12、虚拟技术你了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2%E4%BD%A0%E7%9F%A5%E9%81%93%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">13、进程状态的切换你知道多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E4%BB%8E%E5%BC%80%E5%A7%8B%E8%BF%90%E8%A1%8C%E5%88%B0%E7%BB%93%E6%9D%9F%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B%EF%BC%8C%E4%BD%A0%E8%83%BD%E8%AF%B4%E5%87%BA%E6%9D%A5%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">14、一个程序从开始运行到结束的完整过程，你能说出来多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81%E9%80%9A%E8%BF%87%E4%BE%8B%E5%AD%90%E8%AE%B2%E8%A7%A3%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B"><span class="toc-text">15、通过例子讲解逻辑地址转换为物理地址的基本过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">16、进程同步的四种方法？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-text">1. 临界区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-text">2. 同步与互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">3. 信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%AE%A1%E7%A8%8B"><span class="toc-text">4. 管程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9C%A8%E5%AF%B9%E5%86%85%E5%AD%98%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88"><span class="toc-text">17、操作系统在对内存进行管理的时候需要做些什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95%EF%BC%88Linux%E5%92%8Cwindows%E4%B8%8B%EF%BC%89%EF%BC%8C%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95%EF%BC%88Linux%E5%92%8Cwindows%E4%B8%8B%EF%BC%89"><span class="toc-text">18、进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F%E6%8A%8A%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E8%AF%B4%E5%87%BA%E6%9D%A5"><span class="toc-text">19、进程间通信有哪几种方式？把你知道的都说出来</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-text">管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-text">共享内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-text">套接字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">20、虚拟内存的目的是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%90%86%E8%A7%A3%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%9F%E4%BB%96%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E5%91%A2%EF%BC%9F"><span class="toc-text">21、说一下你理解中的内存？他有什么作用呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E4%B9%8B%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-text">22、操作系统经典问题之哲学家进餐问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E4%B9%8B%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">23、操作系统经典问题之读者-写者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E9%94%81%EF%BC%9F"><span class="toc-text">24、介绍一下几种典型的锁？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-text">条件变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">自旋锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-1%E3%80%81%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E9%94%81%EF%BC%88POSIX%EF%BC%89%EF%BC%9F"><span class="toc-text">24.1、你知道哪几种线程锁（POSIX）？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80VS%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-text">25、逻辑地址VS物理地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81%E6%80%8E%E4%B9%88%E5%9B%9E%E6%94%B6%E7%BA%BF%E7%A8%8B%EF%BC%9F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">26、怎么回收线程？有哪几种方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E3%80%81%E5%86%85%E5%AD%98%E7%9A%84%E8%A6%86%E7%9B%96%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">27、内存的覆盖是什么？有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28%E3%80%81%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">28、内存交换是什么？有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E7%9A%84%E4%BA%A4%E6%8D%A2%EF%BC%9F"><span class="toc-text">29、什么时候会进行内存的交换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30%E3%80%81%E7%BB%88%E7%AB%AF%E9%80%80%E5%87%BA%EF%BC%8C%E7%BB%88%E7%AB%AF%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="toc-text">30、终端退出，终端运行的进程会怎样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%A9%E8%BF%9B%E7%A8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C"><span class="toc-text">31、如何让进程后台运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%AB%E8%A1%A8%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%A4%9A%E5%B0%91%E5%85%B3%E4%BA%8E%E5%BF%AB%E8%A1%A8%E7%9A%84%E7%9F%A5%E8%AF%86%EF%BC%9F"><span class="toc-text">32、什么是快表，你知道多少关于快表的知识？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33%E3%80%81%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E4%B8%AD%EF%BC%8C%E6%9C%89%E5%BF%AB%E8%A1%A8%E5%92%8C%E6%B2%A1%E5%BF%AB%E8%A1%A8%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">33、地址变换中，有快表和没快表，有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34%E3%80%81%E5%9C%A8%E6%89%A7%E8%A1%8Cmalloc%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-text">34、在执行malloc申请内存的时候，操作系统是怎么做的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35%E3%80%81-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-text">35、 守护进程、僵尸进程和孤儿进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-text">守护进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-text">孤儿进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-text">僵尸进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36%E3%80%81%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-text">36、如何避免僵尸进程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37%E3%80%81%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F%E4%B8%BB%E8%A6%81%E6%9C%89%E5%93%AA%E4%B8%A4%E5%A4%A7%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%EF%BC%9F%E5%90%84%E8%87%AA%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">37、局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38%E3%80%81%E7%88%B6%E8%BF%9B%E7%A8%8B%E3%80%81%E5%AD%90%E8%BF%9B%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BB%84%E3%80%81%E4%BD%9C%E4%B8%9A%E5%92%8C%E4%BC%9A%E8%AF%9D"><span class="toc-text">38、父进程、子进程、进程组、作业和会话</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E8%BF%9B%E7%A8%8B"><span class="toc-text">父进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-text">子进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="toc-text">进程组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A"><span class="toc-text">作业</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D"><span class="toc-text">会话</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">39、进程终止的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40%E3%80%81Linux-%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">40、Linux 中异常和中断的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41%E3%80%81Windows%E5%92%8CLinux%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5"><span class="toc-text">41、Windows和Linux环境下内存分布情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42%E3%80%81%E4%B8%80%E4%B8%AA%E7%94%B1C-C-%E7%BC%96%E8%AF%91%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9F"><span class="toc-text">42、一个由C&#x2F;C++编译的程序占用的内存分为哪几个部分？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43%E3%80%81%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%E5%9C%A8Linux-windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%A0%88%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">43、一般情况下在Linux&#x2F;windows平台下栈空间的大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44%E3%80%81%E7%A8%8B%E5%BA%8F%E4%BB%8E%E5%A0%86%E4%B8%AD%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E6%97%B6%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8A%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%E7%9A%84"><span class="toc-text">44、程序从堆中动态分配内存时，虚拟内存上怎么操作的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">45、常见的几种磁盘调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1"><span class="toc-text">1. 先来先服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="toc-text">2. 最短寻道时间优先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%94%B5%E6%A2%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%EF%BC%88%E6%89%AB%E6%8F%8FSCAN%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">3. 电梯扫描算法（扫描SCAN算法）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46%E3%80%81%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">46、交换空间与虚拟内存的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47%E3%80%81%E6%8A%96%E5%8A%A8%E4%BD%A0%E7%9F%A5%E9%81%93%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97%EF%BC%9F%E5%AE%83%E4%B9%9F%E5%8F%AB%E9%A2%A0%E7%B0%B8%E7%8E%B0%E8%B1%A1%E3%80%82%E8%BF%9B%E7%A8%8B%E5%B7%A5%E4%BD%9C%E9%9B%86%EF%BC%9F"><span class="toc-text">47、抖动你知道是什么吗？它也叫颠簸现象。进程工作集？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48%E3%80%81%E4%BB%8E%E5%A0%86%E5%92%8C%E6%A0%88%E4%B8%8A%E5%BB%BA%E7%AB%8B%E5%AF%B9%E8%B1%A1%E5%93%AA%E4%B8%AA%E5%BF%AB%EF%BC%9F%EF%BC%88%E8%80%83%E5%AF%9F%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%88%86%E9%85%8D%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83%EF%BC%89"><span class="toc-text">48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49%E3%80%81%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">49、常见内存分配方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50%E3%80%81%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF"><span class="toc-text">50、常见内存分配内存错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51%E3%80%81%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E4%B8%AD%EF%BC%8C%E8%A2%AB%E6%8D%A2%E5%87%BA%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-text">51、内存交换中，被换出的进程保存在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52%E3%80%81%E5%9C%A8%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E6%97%B6%EF%BC%8C%E6%9C%89%E4%BA%9B%E8%BF%9B%E7%A8%8B%E6%98%AF%E8%A2%AB%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E7%9A%84%EF%BC%9F%E4%BD%A0%E5%8F%AF%E4%BB%A5%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%90%97%EF%BC%9F"><span class="toc-text">52、在发生内存交换时，有些进程是被优先考虑的？你可以说一说吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53%E3%80%81ASCII%E3%80%81Unicode-%E5%92%8C-UTF-8-%E7%BC%96%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">53、ASCII、Unicode 和 UTF-8 编码的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54%E3%80%81%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-text">54、原子操作是如何实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55%E3%80%81%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E4%BD%A0%E7%9F%A5%E9%81%93%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%85%B3%E9%94%AE%E7%82%B9%E5%90%97%EF%BC%9F"><span class="toc-text">55、内存交换你知道有哪些需要注意的关键点吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56%E3%80%81%E7%B3%BB%E7%BB%9F%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%EF%BC%8C%E5%88%86%E5%BE%97%E6%B8%85%E5%90%97%EF%BC%9F"><span class="toc-text">56、系统并发和并行，分得清吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57%E3%80%81%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%BA%86"><span class="toc-text">57、可能是最全的页面置换算法总结了</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E6%B3%95-OPT"><span class="toc-text">1、最佳置换法(OPT)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-FIFO"><span class="toc-text">2、先进先出置换算法(FIFO)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-LRU"><span class="toc-text">3、最近最久未使用置换算法(LRU)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-CLOCK"><span class="toc-text">4、时钟置换算法(CLOCK)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E6%94%B9%E8%BF%9B%E5%9E%8B%E7%9A%84%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">5、改进型的时钟置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">6、总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58%E3%80%81%E5%85%B1%E4%BA%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">58、共享是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59%E3%80%81%E6%AD%BB%E9%94%81%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%A4%A7%E6%80%BB%E7%BB%93%EF%BC%8C%E8%B6%85%E5%85%A8%EF%BC%81"><span class="toc-text">59、死锁相关问题大总结，超全！</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%E5%92%8C-4-%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-text">死锁产生原因和 4 个必要条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%B8%B5%E9%B8%9F%E7%AD%96%E7%95%A5"><span class="toc-text">鸵鸟策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D"><span class="toc-text">死锁检测与死锁恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="toc-text">死锁预防</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-text">死锁避免</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%9C%89%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87%E8%80%8C%E6%97%A0%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%9C%89%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%E8%80%8C%E4%B8%8D%E4%BC%9A%E6%9C%89%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87%EF%BC%9F"><span class="toc-text">60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#61%E3%80%81%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%E4%B8%8E%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87-%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E4%B8%8E%E7%A2%8E%E7%89%87%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">61、内部碎片与外部碎片,存储方式与碎片的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62%E3%80%81%E5%A6%82%E4%BD%95%E6%B6%88%E9%99%A4%E7%A2%8E%E7%89%87%E6%96%87%E4%BB%B6"><span class="toc-text">62、如何消除碎片文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63%E3%80%81%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9D%97%EF%BC%9F%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%93%AA%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9F%EF%BC%88%E7%99%BE%E5%BA%A6%E5%AE%89%E5%85%A8%E4%B8%80%E9%9D%A2%EF%BC%89"><span class="toc-text">63、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%8D%A2%E5%8F%A5%E8%AF%9D%E8%AF%B4%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-text">64、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BD%A0%E7%9F%A5%E9%81%93%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">65、服务器高并发的解决方案你知道多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-text">参考文献</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#huihut-2"><span class="toc-text">huihut</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text">进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">进程之间的通信方式以及优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%EF%BC%88PIPE%EF%BC%89"><span class="toc-text">管道（PIPE）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphore%EF%BC%89"><span class="toc-text">信号量（Semaphore）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%EF%BC%88Signal%EF%BC%89"><span class="toc-text">信号（Signal）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88Message-Queue%EF%BC%89"><span class="toc-text">消息队列（Message Queue）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%88Shared-Memory%EF%BC%89"><span class="toc-text">共享内存（Shared Memory）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%88Socket%EF%BC%89"><span class="toc-text">套接字（Socket）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">线程之间的通信方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%A7%81%E6%9C%89%E5%92%8C%E5%85%B1%E4%BA%AB%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-text">进程之间私有和共享的资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%A7%81%E6%9C%89%E5%92%8C%E5%85%B1%E4%BA%AB%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-text">线程之间私有和共享的资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%AF%B9%E6%AF%94%E3%80%81%E4%BC%98%E5%8A%A3%E4%B8%8E%E9%80%89%E6%8B%A9"><span class="toc-text">多进程与多线程间的对比、优劣与选择</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-text">对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8A%A3"><span class="toc-text">优劣</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%89%E6%8B%A9"><span class="toc-text">选择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E5%86%85%E6%A0%B8%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="toc-text">Linux 内核的同步方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-text">原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="toc-text">同步方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0-2"><span class="toc-text">原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6"><span class="toc-text">产生条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E9%98%B2"><span class="toc-text">预防</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-text">主机字节序与网络字节序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F%EF%BC%88CPU-%E5%AD%97%E8%8A%82%E5%BA%8F%EF%BC%89"><span class="toc-text">主机字节序（CPU 字节序）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">存储方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF"><span class="toc-text">判断大端小端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%84%E6%9E%B6%E6%9E%84%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-text">各架构处理器的字节序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-text">网络字节序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-text">分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CS-Notes-2"><span class="toc-text">CS-Notes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-text">基本特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B9%B6%E5%8F%91"><span class="toc-text">1. 并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%B1%E4%BA%AB"><span class="toc-text">2. 共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%99%9A%E6%8B%9F"><span class="toc-text">3. 虚拟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%BC%82%E6%AD%A5"><span class="toc-text">4. 异步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-text">基本功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-text">1. 进程管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">2. 内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-text">3. 文件管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-text">4. 设备管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E5%86%85%E6%A0%B8%E5%92%8C%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="toc-text">宏内核和微内核</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%8F%E5%86%85%E6%A0%B8"><span class="toc-text">1. 宏内核</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="toc-text">2. 微内核</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%88%86%E7%B1%BB"><span class="toc-text">中断分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A4%96%E4%B8%AD%E6%96%AD"><span class="toc-text">1. 外中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%82%E5%B8%B8"><span class="toc-text">2. 异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%99%B7%E5%85%A5"><span class="toc-text">3. 陷入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-2"><span class="toc-text">进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B"><span class="toc-text">1. 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B"><span class="toc-text">2. 线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8C%BA%E5%88%AB"><span class="toc-text">3. 区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-text">进程状态的切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">进程调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">1. 批处理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-first-come-first-serverd%EF%BC%88FCFS%EF%BC%89"><span class="toc-text">1.1 先来先服务 first-come first-serverd（FCFS）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88-shortest-job-first%EF%BC%88SJF%EF%BC%89"><span class="toc-text">1.2 短作业优先 shortest job first（SJF）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88-shortest-remaining-time-next%EF%BC%88SRTN%EF%BC%89"><span class="toc-text">1.3 最短剩余时间优先 shortest remaining time next（SRTN）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-text">2. 交互式系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC"><span class="toc-text">2.1 时间片轮转</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-text">2.2 优先级调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97"><span class="toc-text">2.3 多级反馈队列</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">3. 实时系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-text">进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%B4%E7%95%8C%E5%8C%BA-2"><span class="toc-text">1. 临界区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5-2"><span class="toc-text">2. 同步与互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BF%A1%E5%8F%B7%E9%87%8F-2"><span class="toc-text">3. 信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%AE%A1%E7%A8%8B-2"><span class="toc-text">4. 管程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-text">经典同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-text">1. 哲学家进餐问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">2. 读者-写者问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%A1%E9%81%93"><span class="toc-text">1. 管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-FIFO"><span class="toc-text">2. FIFO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">3. 消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">4. 信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="toc-text">5. 共享存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-text">6. 套接字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-text">死锁必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-text">死锁处理方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%B8%B5%E9%B8%9F%E7%AD%96%E7%95%A5-2"><span class="toc-text">鸵鸟策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D-2"><span class="toc-text">死锁检测与死锁恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-text">1. 每种类型一个资源的死锁检测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-text">2. 每种类型多个资源的死锁检测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D"><span class="toc-text">3. 死锁恢复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2-2"><span class="toc-text">死锁预防</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A0%B4%E5%9D%8F%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6"><span class="toc-text">1. 破坏互斥条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A0%B4%E5%9D%8F%E5%8D%A0%E6%9C%89%E5%92%8C%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="toc-text">2. 破坏占有和等待条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A0%B4%E5%9D%8F%E4%B8%8D%E5%8F%AF%E6%8A%A2%E5%8D%A0%E6%9D%A1%E4%BB%B6"><span class="toc-text">3. 破坏不可抢占条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%A0%B4%E5%9D%8F%E7%8E%AF%E8%B7%AF%E7%AD%89%E5%BE%85"><span class="toc-text">4. 破坏环路等待</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D-2"><span class="toc-text">死锁避免</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81"><span class="toc-text">1. 安全状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8D%95%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-text">2. 单个资源的银行家算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-text">3. 多个资源的银行家算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-text">分页系统地址映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-2"><span class="toc-text">页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%80%E4%BD%B3"><span class="toc-text">1. 最佳</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8"><span class="toc-text">2. 最近最久未使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9C%80%E8%BF%91%E6%9C%AA%E4%BD%BF%E7%94%A8"><span class="toc-text">3. 最近未使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA"><span class="toc-text">4. 先进先出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E7%AE%97%E6%B3%95"><span class="toc-text">5. 第二次机会算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%97%B6%E9%92%9F"><span class="toc-text">6. 时钟</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5"><span class="toc-text">分段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F"><span class="toc-text">段页式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">分页与分段的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="toc-text">磁盘结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">磁盘调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-2"><span class="toc-text">1. 先来先服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88-2"><span class="toc-text">2. 最短寻道时间优先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%94%B5%E6%A2%AF%E7%AE%97%E6%B3%95"><span class="toc-text">3. 电梯算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F"><span class="toc-text">编译系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-text">静态链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="toc-text">目标文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-text">动态链接</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/45995/" title="CPP Primer知识点笔记"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031713662.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP Primer知识点笔记"/></a><div class="content"><a class="title" href="/posts/45995/" title="CPP Primer知识点笔记">CPP Primer知识点笔记</a><time datetime="2022-04-03T06:20:46.000Z" title="发表于 2022-04-03 14:20:46">2022-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/43615/" title="C++11 新特性相关知识"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203122040654.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++11 新特性相关知识"/></a><div class="content"><a class="title" href="/posts/43615/" title="C++11 新特性相关知识">C++11 新特性相关知识</a><time datetime="2022-03-12T11:56:44.000Z" title="发表于 2022-03-12 19:56:44">2022-03-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/28622/" title="C++ 虚函数表"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203122041145.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ 虚函数表"/></a><div class="content"><a class="title" href="/posts/28622/" title="C++ 虚函数表">C++ 虚函数表</a><time datetime="2022-02-22T05:12:09.000Z" title="发表于 2022-02-22 13:12:09">2022-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/45007/" title="C++知识点笔记"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202112281103528.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++知识点笔记"/></a><div class="content"><a class="title" href="/posts/45007/" title="C++知识点笔记">C++知识点笔记</a><time datetime="2022-02-20T02:23:38.000Z" title="发表于 2022-02-20 10:23:38">2022-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/59570/" title="Typora 破解教程"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202111041917080.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Typora 破解教程"/></a><div class="content"><a class="title" href="/posts/59570/" title="Typora 破解教程">Typora 破解教程</a><time datetime="2022-02-16T08:04:53.000Z" title="发表于 2022-02-16 16:04:53">2022-02-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By SEUGarfield</div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadWaline () {
  function initWaline () {
    const waline = new Waline(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-api-one.vercel.app/',
      avatar: 'monsterid',
      avatarCDN: 'https://sdn.geekzu.org/avatar/',
      path: location.pathname,
      visitor: false,
      dark: 'html[data-theme="dark"]'
    }, null))
  }

  if (typeof Waline === 'function') initWaline() 
  else getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js').then(initWaline)
}

if ('Waline' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/f3334bcb.js","daovoice")
</script><script>var isChatBtn = true
daovoice('init', {
  app_id: 'f3334bcb',},{
  launcher: { 
     disableLauncherIcon: isChatBtn // 悬浮 ICON 是否显示
  },
});
daovoice('update');

if (isChatBtn) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      daovoice('show')
    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: true // 悬浮 ICON 是否显示
        },
      });
    }
    function chatBtnShow () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: false // 悬浮 ICON 是否显示
        },
      });
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>