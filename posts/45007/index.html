<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++知识点笔记 | 笑枕晚风の小站</title><meta name="keywords" content="C++"><meta name="author" content="SEUGarfield"><meta name="copyright" content="SEUGarfield"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Top K 1、智能指针的特点 简略   C++中的智能指针有4种，分别为：shared_ptr、unique_ptr、weak_ptr、auto_ptr，其中auto_ptr被C++11弃用。   为什么要使用智能指针：智能指针的作用是管理一个指针，因为存在申请的空间在函数结束时忘记释放，造成内存泄漏的情况。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类">
<meta property="og:type" content="article">
<meta property="og:title" content="C++知识点笔记">
<meta property="og:url" content="https://blog.zgzheng.top/posts/45007/index.html">
<meta property="og:site_name" content="笑枕晚风の小站">
<meta property="og:description" content="Top K 1、智能指针的特点 简略   C++中的智能指针有4种，分别为：shared_ptr、unique_ptr、weak_ptr、auto_ptr，其中auto_ptr被C++11弃用。   为什么要使用智能指针：智能指针的作用是管理一个指针，因为存在申请的空间在函数结束时忘记释放，造成内存泄漏的情况。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202112281103528.jpg">
<meta property="article:published_time" content="2022-02-20T02:23:38.000Z">
<meta property="article:modified_time" content="2022-04-03T09:15:53.967Z">
<meta property="article:author" content="SEUGarfield">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202112281103528.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202201121022530.png"><link rel="canonical" href="https://blog.zgzheng.top/posts/45007/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="jHeEqmxcY5gJhgQXHPVzNF9LSawljE99iQNENuIPBp4"/><meta name="baidu-site-verification" content="code-PCT1t1AN4f"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?fd347c67a4aa89bb0cfbfa45cf3b7a98";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-2FF9T1FD5L"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2FF9T1FD5L');
</script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "9ds0zhvaq8");</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++知识点笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-03 17:15:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="笑枕晚风の小站" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202110251550056.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">93</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/steamgames/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202112281103528.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">笑枕晚风の小站</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/steamgames/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++知识点笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-20T02:23:38.000Z" title="发表于 2022-02-20 10:23:38">2022-02-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-03T09:15:53.967Z" title="更新于 2022-04-03 17:15:53">2022-04-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">119.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>406分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++知识点笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="Top-K">Top K</h3>
<h4 id="1、智能指针的特点">1、智能指针的特点</h4>
<h5 id="简略">简略</h5>
<ol>
<li>
<p>C++中的智能指针有4种，分别为：<strong>shared_ptr、unique_ptr、weak_ptr、auto_ptr</strong>，其中auto_ptr被C++11弃用。</p>
</li>
<li>
<p><strong>为什么要使用智能指针</strong>：智能指针的作用是管理一个指针，因为存在申请的空间在函数结束时忘记释放，造成内存泄漏的情况。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，自动释放资源。</p>
</li>
<li>
<p>四种指针各自特性</p>
<p><strong>（1）auto_ptr</strong></p>
<p>auto指针存在的问题是，两个智能指针同时指向一块内存，就会两次释放同一块资源，自然报错。</p>
<p><strong>（2）unique_ptr</strong></p>
<p>unique指针规定一个智能指针独占一块内存资源。当两个智能指针同时指向一块内存，编译报错。</p>
<p>实现原理： <strong>将拷贝构造函数和赋值拷贝构造函数申明为 private 或 delete</strong> 。不允许拷贝构造函数和赋值操作符，但是支持移动构造函数，通过 std:move 把一个对象指针变成右值之后可以移动给另一个 unique_ptr</p>
<p><strong>（3）shared_ptr</strong></p>
<p>共享指针可以实现多个智能指针指向相同对象，该对象和其相关资源会在引用为0时被销毁释放。</p>
<p>实现原理：有一个<strong>引用计数</strong>的指针类型变量，专门用于引用计数，使用拷贝构造函数和赋值拷贝构造函数时，引用计数加1，当引用计数为0时，释放资源。</p>
<p>（4）<strong>weak_ptr</strong><br>
**注意：**shared_ptr 存在一个问题，当两个shared_ptr指针相互引用时，那么这两个指针的引用计数不会下降为0，资源得不到释放。因此引入weak_ptr，<strong>weak_ptr是弱引用，weak_ptr 的构造和析构不会引起引用计数的增加或减少</strong>。</p>
</li>
</ol>
<h5 id="详细">详细</h5>
<p>智能指针是为了解决动态内存分配时带来的<strong>内存泄漏</strong>以及<strong>多次释放同一块内存空间</strong>而提出的。C++11 中封装在了 <code>&lt;memory&gt;</code> 头文件中。</p>
<p>C++11 中智能指针包括以下三种：</p>
<ul>
<li><strong>共享指针（shared_ptr）</strong>：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 <code>use_count()</code> 查看资源的所有者的个数，可以通过 <code>unique_ptr</code>、<code>weak_ptr</code> 来构造，调用 <code>release()</code> 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。</li>
<li><strong>独占指针（unique_ptr）</strong>：独享所有权的智能指针，资源只能被一个指针占有，<strong>该指针不能拷贝构造和赋值</strong>。但可以进行移动构造和移动赋值构造（调用 <code>move()</code> 函数），即一个 <code>unique_ptr</code> 对象赋值给另一个 <code>unique_ptr</code> 对象，可以通过该方法进行赋值。</li>
<li><strong>弱指针（weak_ptr）</strong>：指向 <code>share_ptr</code> 指向的对象，能够解决由 shared_ptr 带来的循环引用问题。</li>
</ul>
<p><strong>智能指针的实现原理：</strong> 计数原理。</p>
<ol>
<li>
<p>C++中的智能指针有4种，分别为：<strong>shared_ptr、unique_ptr、weak_ptr、auto_ptr</strong>，其中auto_ptr被C++11弃用。</p>
</li>
<li>
<p>使用智能指针的原因</p>
<p>申请的空间（即new出来的空间），在使用结束时，需要delete掉，否则会形成内存碎片。在程序运行期间，new出来的对象，在析构函数中delete掉，但是这种方法不能解决所有问题，因为有时候new发生在某个全局函数里面，该方法会给程序员造成精神负担。此时，智能指针就派上了用场。使用智能指针可以很大程度上避免这个问题，因为<strong>智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源</strong>。所以，智能指针的作用原理就是在函数结束时自动释放内存空间，避免了手动释放内存空间。</p>
</li>
<li>
<p>四种指针分别解决的问题以及各自特性如下：</p>
<p>（1）auto_ptr（C++98的方案，C++11已经弃用）</p>
<p>采用所有权模式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I reigned loney as a cloud.&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; p2;</span><br><span class="line">p2=p1; <span class="comment">//auto_ptr不会报错</span></span><br></pre></td></tr></table></figure>
<p>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题。</p>
<p>（2）unique_ptr（替换auto_ptr）</p>
<p>unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露，例如，以new创建对象后因为发生异常而忘记调用delete时的情形特别有用。</p>
<p>采用所有权模式，和上面例子一样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I reigned loney as a cloud.&quot;</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;string&gt; p4;</span><br><span class="line">p4=p3; <span class="comment">//此时会报错</span></span><br></pre></td></tr></table></figure>
<p>编译器认为P4=P3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。 另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;hello world&quot;</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;string&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      <span class="comment">// #1 not allowed</span></span><br><span class="line">unique_ptr&lt;string&gt; pu3;</span><br><span class="line">pu3 = unique_ptr&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;You&quot;</span>));   <span class="comment">// #2 allowed</span></span><br></pre></td></tr></table></figure>
<p>其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</p>
<p>**注意：**如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; ps1, ps2;</span><br><span class="line">ps1 = <span class="built_in">demo</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">ps2 = <span class="built_in">move</span>(ps1);</span><br><span class="line">ps1 = <span class="built_in">demo</span>(<span class="string">&quot;alexia&quot;</span>);</span><br><span class="line">cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>（3）shared_ptr（非常好使）</p>
<p>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr , unique_ptr , weak_ptr 来构造。当我们调用 release() 时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性( auto_ptr 是独占的), 在使用<strong>引用计数</strong>的机制上提供了可以共享所有权的智能指针。</p>
<p><strong>成员函数：</strong></p>
<ul>
<li>
<p><strong>use_count</strong> 返回引用计数的个数</p>
</li>
<li>
<p><strong>unique</strong> 返回是否是独占所有权( use_count 为 1)</p>
</li>
<li>
<p><strong>swap</strong> 交换两个 shared_ptr 对象(即交换所拥有的对象)</p>
</li>
<li>
<p><strong>reset</strong> 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p>
</li>
<li>
<p><strong>get</strong>  返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr sp(new int(1)); sp 与 sp.get()是等价的</p>
</li>
</ul>
<p>（4）weak_ptr</p>
<p>weak_ptr 是一种不控制所指向对象生存期的智能指针，它指向由一个 shared_ptr 管理的对象。将一个 weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数。 一旦最后一个指向对象的 shared_ptr 被销毁，对象就会被释放。 即使有 weak_ptr 指向对象，对象也还是会被释放。</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203102152046.png" alt="image-20220222165322539" style="zoom: 67%;" />
<p>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。<strong>weak_ptr 是用来解决 shared_ptr 相互引用时的死锁问题</strong>，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0, 资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和 shared_ptr 之间可以相互转化，shared_ptr 可以直接赋值给它，它可以通过调用 lock 函数来获得 shared_ptr。</p>
<p>由于对象可能不存在，我们不能使用 weak_ptr 直接访问对象，而必须调用 lock 。此函数检查 weak_ptr 指向的对象是否仍存在。如果存在，lock 返回一个指向共享对象的 shared_ptr。与任何其他 shared_ptr 类似，只要此 shared_ptr 存在，它所指向的底层对象也就会一直存在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  shared_ptr&lt;B&gt; pb_;</span><br><span class="line">  ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A delete\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  shared_ptr&lt;A&gt; pa_;</span><br><span class="line">  ~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B delete\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">  <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">  </span><br><span class="line">  pb-&gt;pa_ = pa;</span><br><span class="line">  pa-&gt;pb_ = pb;</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fun</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的 shared_ptr pb_ ; 改为 weak_ptr pb_ ; 这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</p>
<p><strong>注意</strong>：我们不能通过 weak_ptr 直接访问对象的方法，比如 B 对象中有一个方法 print() , 我们不能这样访问 <code>pa-&gt;pb_-&gt;print()</code>; 英文 pb_ 是一个 weak_ptr，应该先把它转化为 shared_ptr，如：shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print();</p>
</li>
</ol>
<h4 id="2、new-与-malloc-的区别">2、new 与 malloc 的区别</h4>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203102152903.png" style="zoom: 67%;" />
<ol>
<li>new 是操作符，而 malloc 是函数。</li>
<li>new 在调用的时候先分配内存，再调用构造函数，释放的时候调用析构函数；而 malloc 没有构造函数和析构函数。</li>
<li>malloc 需要给定申请内存的大小，返回的指针 <code>void*</code> 需要强转；new 会调用构造函数，不用指定内存的大小，返回指针不用强转，是对象的指针类型。</li>
<li>new 可以被重载；malloc 不行</li>
<li>new 分配内存更直接和安全。</li>
<li>new 发生错误抛出异常，malloc 返回 null</li>
</ol>
<p>更多理解：</p>
<ol>
<li>
<p>分配内存的位置<br>
malloc是从堆上动态分配内存，new是从自由存储区为对象动态分配内存。<br>
自由存储区的位置取决于operator new的实现。自由存储区不仅可以为堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</p>
</li>
<li>
<p>返回类型安全性<br>
malloc内存分配成功后返回void*，然后再强制类型转换为需要的类型；new操作符分配内存成功后返回与对象类型相匹配的指针类型；因此new是符合类型安全的操作符。</p>
</li>
<li>
<p>内存分配失败返回值<br>
malloc内存分配失败后返回NULL；<br>
new分配内存失败则会抛异常（bac_alloc）。</p>
</li>
<li>
<p>分配内存的大小的计算<br>
使用 new 操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而 malloc 则需要显式地指出所需内存的尺寸。</p>
</li>
<li>
<p>是否调用构造函数/析构函数<br>
使用new操作符来分配对象内存时会经历三个步骤：</p>
<ul>
<li>第一步：调用 operator new 函数（对于数组是 operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。</li>
<li>第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。</li>
<li>第三步：对象构造完成后，返回一个指向该对象的指针。</li>
</ul>
<p>使用delete操作符来释放对象内存时会经历两个步骤：</p>
<ul>
<li>第一步：调用对象的析构函数。</li>
<li>第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。</li>
</ul>
<p>总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构；而malloc则不会。</p>
</li>
<li>
<p>对数组的处理</p>
<p>C++提供了new []和delete []用来专门处理数组类型。它会调用构造函数初始化每一个数组元素，然后释放对象时它会为每个对象调用析构函数，但是二者一定要配套使用；至于malloc，它并不知道你要在这块空间放置数组还是其他的东西，就只给一块原始的空间，再给一个内存地址就完事，如果要动态开辟一个数组的内存，还需要我们手动自定数组的大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A * ptr = <span class="keyword">new</span> A[<span class="number">10</span>];<span class="comment">//分配10个A对象</span></span><br><span class="line"><span class="keyword">delete</span> [] ptr;</span><br><span class="line"><span class="keyword">int</span> * ptr = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>( <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * <span class="number">10</span>);<span class="comment">//分配一个10个int元素的数组</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>new与malloc是否可以相互调用<br>
new/delete 的实现可以基于 malloc，而 malloc 的实现不可以去调用 new</p>
</li>
<li>
<p>是否可以被重载<br>
new/delete 可以被重载。而 malloc/free 则不能重载。</p>
</li>
<li>
<p>分配内存时内存不足<br>
malloc 动态分配内存后，如果不够用可以使用 realloc 函数重新分配实现内存的扩充；而 new 则没有这样的操作；</p>
</li>
</ol>
<p><strong>malloc 底层实现：</strong> 当开辟的空间小于 128K 时，调用 brk() 函数；当开辟的空间大于 128K 时，调用 mmap()。malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。</p>
<p>当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。</p>
<p><code>malloc</code> 的原理:</p>
<ul>
<li>当开辟的空间小于 128K 时，调用 <code>brk()</code> 函数，通过移动 <code>_enddata</code> 来实现；</li>
<li>当开辟空间大于 128K 时，调用 <code>mmap()</code> 函数，通过在虚拟地址空间中开辟一块内存空间来实现。</li>
</ul>
<p><code>malloc</code> 的底层实现：</p>
<ul>
<li><code>brk()</code> 函数实现原理：向高地址的方向移动指向数据段的高地址的指针 <code>_enddata</code>。</li>
<li><code>mmap</code> 内存映射原理：
<ol>
<li>进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域；</li>
<li>调用内核空间的系统调用函数 <code>mmap()</code>，实现文件物理地址和进程虚拟地址的一一映射关系；</li>
<li>进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝。</li>
</ol>
</li>
</ul>
<p><strong>new 底层实现：</strong>  关键字 new 在调用构造函数的时候实际上进行了如下的几个步骤：</p>
<ol>
<li>创建一个新的对象</li>
<li>将构造函数的作用域赋值给这个新的对象（因此 this 指向了这个新的对象）</li>
<li>执行构造函数中的代码（为这个新对象添加属性）</li>
<li>返回新对象</li>
</ol>
<p>堆区和自由存储区的区别与联系：<br>
（1）malloc申请的内存在堆上，使用free释放。new申请的内存在自由存储区，用delete释放<br>
（2）堆（heap）是c语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当程序运行时调用malloc()时就会从中分配，调用free可把内存交换。而自由存储区是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认用堆来实现自由存储区，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来实现，这时由new运算符分配的对象，说它在堆上也对，说它在自由存储区也对。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就不位于堆上了。</p>
<p>记住：<br>
（1）堆是c语言和操作系统的术语，是操作系统维护的一块内存。自由存储是C++中通过new和delete动态分配和释放对象的抽象概念。<br>
（2）new所申请的内存区域在C++中称为自由存储区，编译器用malloc和free实现new和delete操作符时，new申请的内存可以说是在堆上。<br>
（3）堆和自由内存区有相同之处，但并不等价。</p>
<h4 id="3、虚函数与纯虚函数的区别">3、虚函数与纯虚函数的区别</h4>
<ul>
<li>虚函数和纯虚函数可以出现在同一个类中。（含有纯虚函数的类称为抽象基类）</li>
<li>使用方式不同：虚函数可以直接使用，也可以被子类重载以后，以多态的形式调用；纯虚函数必须在派生类中实现后才能使用，纯虚函数在基类有声明而没有定义；</li>
<li>定义形式不同：虚函数在定义时在普通函数的基础上加上 <code>virtual</code> 关键字，纯虚函数定义时除了加上<code>virtual</code> 关键字还需要加上 <code>= 0</code>;</li>
<li>虚函数必须实现，否则编译器会报错；</li>
<li>对于实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在派生类中重写；</li>
</ul>
<p>在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，<strong>被static修饰的函数在编译时要求前期绑定, 然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样</strong>。</p>
<p>虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，<strong>目的是提供一个统一的接口</strong>。</p>
<p>析构函数最好定义为虚函数，特别是对于含有继承关系的类；（被多态使用的基类的析构函数应该定义为虚函数）。如果一个类没有被继承，以后也不会被继承，那么，它的析构函数不应该是虚函数。因为虚函数是由额外开销的，需要一个指针，vptr，来实现虚函数。</p>
<p>析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。</p>
<ol>
<li>
<p>我们举个虚函数的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::foo() is called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::foo() is called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  A *a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">  a-&gt;<span class="built_in">foo</span>();  <span class="comment">// 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子是虚函数的一个典型应用，通过这个例子，也许你就对虚函数有了一些概念。它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。<br>
<strong>虚函数只能借助于指针或者引用来达到多态的效果。</strong></p>
</li>
<li>
<p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”</p>
<p><code>virtual void funtion1()=0</code></p>
<p>为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。</p>
<p>在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。</p>
<p>为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：<code>virtual ReturnType Function()= 0;</code>），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。</p>
<p>声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。</p>
<p>纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。</p>
<p>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。</p>
<p>纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p>
</li>
</ol>
<h4 id="4、STL-中-vector-与-list-具体是怎么实现的？常见操作的时间复杂度是多少？">4、STL 中 vector 与 list 具体是怎么实现的？常见操作的时间复杂度是多少？</h4>
<ol>
<li>
<p>vector 一维数组（元素在内存连续存放）</p>
<p>是动态数组，在堆中分配内存，元素连续存放，有保留内存，<strong>如果减少大小后，内存也不会释放</strong>（[vector的内存释放](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/summerRQ/articles/2407974.html#:~:text=swap,(">https://www.cnblogs.com/summerRQ/articles/2407974.html#:~:text=swap,(</a>)是交换函数，使vector离开其自身的作用域，从而强制释放vector所占的内存空间，总而言之，释放vector内存最简单的方法是vector.swap (nums)。)）；如果新增大小后小于当前大小时才会重新分配内存。</p>
<p>扩容方式：</p>
<p>a. 倍放开辟2倍的内存</p>
<p>b. 旧的数据开辟到新的内存</p>
<p>c. 释放旧的内存</p>
<p>d. 指向新内存</p>
</li>
<li>
<p>list 双向链表（元素存放在堆中）</p>
<p>元素存放在堆中，每个元素都是放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点，使得它的随机存取变得非常没有效率，因此它没有提供[]操作符的重载。但是由于链表的特点，它可以很有效的支持任意地方的删除和插入操作。</p>
<p>特点：</p>
<p>a. 随机访问不方便</p>
<p>b. 删除插入操作方便</p>
</li>
<li>
<p>常见时间复杂度</p>
<p>vector:</p>
<ul>
<li>随机访问——常数 <em>𝓞(1)</em></li>
<li>在末尾插入或移除元素——均摊常数 <em>𝓞(1)</em></li>
<li>插入或移除元素：与到 vector 结尾的距离成线性 <em>𝓞(n)</em></li>
</ul>
<p>list: 插入、查找、删除时间复杂度分别为：O(1)、O(n)、O(1)。</p>
</li>
</ol>
<p><strong>vector 和 list 的区别，分别适用于什么场景？</strong></p>
<p>vector和list区别在于<strong>底层实现机理不同</strong>，因而特性和适用场景也有所不同。</p>
<p><strong>vector：一维数组</strong></p>
<ul>
<li>特点：元素在内存连续存放，动态数组，在<strong>堆</strong>中分配内存，元素连续存放，有保留内存，如果减少大小后内存也不会释放。</li>
<li>优点：和数组类似开辟一段连续的空间，并且支持随机访问，所以它的查找效率高其时间复杂度O(1)。</li>
<li>缺点：由于开辟一段连续的空间，所以插入删除会需要对数据进行移动比较麻烦，时间复杂度O（n），另外当空间不足时还需要进行扩容。</li>
<li>删除某个元素以后，该元素后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。</li>
<li><strong>对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了</strong></li>
</ul>
<p><strong>list：双向链表</strong></p>
<ul>
<li>特点：元素在<strong>堆</strong>中存放，每个元素都是存放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问。</li>
<li>优点：<strong>底层实现是双向链表</strong>，当对大量数据进行插入删除时，其时间复杂度O(1)。</li>
<li>缺点：底层没有连续的空间，只能通过指针来访问，所以查找数据需要遍历其时间复杂度O(n)，没有提供[]操作符的重载。</li>
<li><strong>在 list 内或在数个 list 间添加、移除和移动元素不会非法化迭代器或引用。迭代器仅在对应元素被删除时非法化。</strong></li>
</ul>
<p><strong>应用场景</strong></p>
<p>vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。</p>
<p>list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。</p>
<h4 id="5、vector-的实现原理">5、vector 的实现原理</h4>
<p>vector底层实现原理为<strong>一维数组</strong>（元素在空间连续存放）。</p>
<ol>
<li>
<p>新增元素</p>
<p>Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，再插入新增的元素。插入新的数据分在最后插入 push_back 和通过迭代器在任何位置插入，这里说一下通过迭代器插入，通过迭代器与第一个元素的距离知道要插入的位置，即 <code>int index = iter - begin()</code>。这个元素后面的所有元素都向后移动一个位置，在空出来的位置上存入新增的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新增元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(const_iterator iter, <span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> index = iter - <span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">if</span> (index &lt; size_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size_ == capacity_) &#123;</span><br><span class="line">      <span class="keyword">int</span> capa = <span class="built_in">calculateCapacity</span>();</span><br><span class="line">      <span class="built_in">newCapacity</span>(capa);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memmove</span>(buf + index + <span class="number">1</span>, buf + index, (size_ - index) * <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">    buf[index] = t;</span><br><span class="line">    size_++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除元素</p>
<p>删除和新增差不多，也分两种，删除最后一个元素 pop_back 和通过迭代器删除任意一个元素 erase(iter)。通过迭代器删除还是先找到要删除元素的位置，即 <code>int index = iter - begin()</code>; 这个位置后面的每个元素都想前移动一个元素的位置。同时我们知道 erase 不释放内存只初始化成默认值。</p>
<p>删除全部元素 clear：只是循环调用了 erase，所以删除全部元素的时候，不释放内存。<strong>clear、erase都不释放内存，内存是在析构函数中释放的。或者使用swap、shrink_to_fit释放内存</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator iter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> index = iter - <span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">if</span> (index &lt; size_ &amp;&amp; size_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">memmove</span>(buf + index, buf + index + <span class="number">1</span>, (size_ - index) * <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">    buf[--size_] = <span class="built_in">T</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">iterator</span>(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>迭代器iteraotr</p>
<p>迭代器iteraotr是STL的一个重要组成部分,通过iterator可以很方便的存储集合中的元素.STL为每个集合都写了一个迭代器, 迭代器其实是对一个指针的包装,实现一些常用的方法,如++,–,!=,==,*,-&gt;等, 通过这些方法可以找到当前元素或是别的元素. vector是STL集合中比较特殊的一个,因为vector中的每个元素都是连续的,所以在自己实现vector的时候可以用指针代替。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器的实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Category</span>, <span class="keyword">class</span> _<span class="title">Ty</span>, <span class="keyword">class</span> _<span class="title">Diff</span> =</span> <span class="keyword">ptrdiff_t</span>,</span><br><span class="line">          <span class="class"><span class="keyword">class</span> _<span class="title">Pointer</span> =</span> _Ty *,</span><br><span class="line">          <span class="class"><span class="keyword">class</span> _<span class="title">Reference</span> =</span> _Ty &amp;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator</span> &#123;</span>  <span class="comment">// base type for all iterator classes</span></span><br><span class="line">  <span class="keyword">typedef</span> _Category iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> _Ty value_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Diff difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Diff distance_type;  <span class="comment">// retained</span></span><br><span class="line">  <span class="keyword">typedef</span> _Pointer pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Reference reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="6、C-11-新特性">6、C++11 新特性</h4>
<p>C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：</p>
<ol>
<li>
<p>语法的改进</p>
<p>（1）统一的初始化方法（列表初始化，可以用于任何类型对象的初始化）</p>
<p>（2）成员变量默认初始化</p>
<p>（3）<strong>auto关键字</strong>用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）</p>
<p>（4）<strong>decltype</strong> 求表达式的类型</p>
<p>（5）<strong>智能指针</strong></p>
<p>（6）<strong>nullptr 空指针</strong>（原来NULL）</p>
<p>（7）<strong>范围的 for 循环</strong></p>
<p>（8）<strong>右值引用和 move 语义</strong>：让程序员有意识减少进行深拷贝操作</p>
<ul>
<li><code>delete</code> 函数：<code>= delete</code> 表示该函数不能被调用。</li>
<li><code>default</code> 函数：<code>= default</code> 表示编译器生成默认的函数，例如：生成默认的构造函数。</li>
<li><code>final</code>：final 用于修饰一个类，表示禁止该类进一步派生和虚函数的进一步重载</li>
<li><code>override</code>：用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了 override 但父类却没有这个虚函数，编译报错，使用 override 关键字可以避免开发者在重写基类函数时无意产生的错误</li>
<li><code>explicit</code>：explicit 专用于修饰构造函数，表示只能显式构造，不可以被隐式转换</li>
</ul>
</li>
<li>
<p>标准库扩充（往STL里新加进一些模板类，比较好用）</p>
<p>（9）<strong>无序容器（unordered_map,unordered_set）</strong> 用法和功能同map一模一样，区别在于哈希表的效率更高</p>
<p>（10）正则表达式 可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串</p>
<p>（11）<strong>Lambda表达式、bind</strong></p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/0c68359d19103ca2009006070">c++11新特性，所有知识点都在这了</a></p>
<h4 id="7、智能指针和指针的区别是什么？">7、智能指针和指针的区别是什么？</h4>
<p>区别：智能指针实际上是对普通指针加了一层封装机制，区别是<strong>它负责<code>自动释放</code>所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期</strong>。</p>
<ol>
<li>
<p>智能指针</p>
<p>如果在程序中使用 new 从堆（自由存储区）分配内存，等到不需要时，应使用 delete 将其释放。C++ 引用了智能指针 auto_ptr，以帮助自动完成这个过程。随后的编程体验（尤其是使用STL）表明，需要有更精致的机制。基于程序员的编程体验和BOOST库提供的解决方案，C++11 摒弃了auto_ptr，并新增了三种智能指针：unique_ptr、shared_ptr 和 weak_ptr 。所有新增的智能指针都能与STL容器和移动语义协同工作。</p>
</li>
<li>
<p>指针</p>
<p>C 语言规定所有变量在使用前必须先定义，指定其类型，并按此分配内存单元。指针变量不同于整型变量和其他类型的变量，它是专门用来存放地址的，所以必须将它定义为“指针类型”。</p>
</li>
</ol>
<h4 id="8、右值引用与移动语义">8、右值引用与移动语义</h4>
<ol>
<li>
<p>右值引用</p>
<p>一般来说，不能取地址的表达式，就是右值引用，能取地址的，就是左值。</p>
<p>右值引用主要用于移动语义和完美转发</p>
<ul>
<li><strong>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</strong></li>
<li><strong>能够更简洁明确地定义泛型函数。</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> &#125;;</span><br><span class="line">A &amp; r = <span class="built_in">A</span>(); <span class="comment">//error,A()是无名变量，是右值</span></span><br><span class="line">A &amp;&amp; r = <span class="built_in">A</span>(); <span class="comment">//ok,r是右值引用</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>移动语义</p>
<p><strong>移动语义</strong>可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。通过转移语义，临时对象中的资源能够转移其它的对象里。</p>
<p>move() 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，<strong>就是将某个左值强制转化为右值</strong>。基于 move() 函数特殊的功能，其常用于实现移动语义。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://murphypei.github.io/blog/2018/08/cpp-right-reference">C++11的右值引用和转移语义</a></p>
<ol>
<li>
<p>右值引用</p>
<p>C++98/03 标准中就有引用，使用 “&amp;” 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<p>如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用。</p>
<p>注意，虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b = num;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p>
<p>为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。</p>
<p>需要注意的，和声明左值引用一样，<strong>右值引用也必须立即进行初始化操作，且只能使用右值进行初始化</strong>，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>和常量左值引用不同的是，<strong>右值引用还可以对右值进行修改</strong>。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 100       </span></span><br></pre></td></tr></table></figure>
<p>另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; a = <span class="number">10</span>;<span class="comment">//编译器不会报错</span></span><br></pre></td></tr></table></figure>
<p>但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。</p>
</li>
<li>
<p>move语义</p>
<p>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，就是<strong>将某个左值强制转化为右值</strong>。基于 move() 函数特殊的功能，其常用于实现移动语义。move() 函数的用法也很简单，其语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">move</span>( arg ) <span class="comment">//其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序实例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">first</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">first</span>() : <span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>)) &#123; cout &lt;&lt; <span class="string">&quot;construct!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="comment">//移动构造函数</span></span><br><span class="line">  <span class="built_in">first</span>(first &amp;&amp;d) : <span class="built_in">num</span>(d.num) &#123;</span><br><span class="line">    d.num = <span class="literal">NULL</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;first move construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">  <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">second</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">second</span>() : <span class="built_in">fir</span>() &#123;&#125;</span><br><span class="line">  <span class="comment">//用 first 类的移动构造函数初始化 fir</span></span><br><span class="line">  <span class="built_in">second</span>(second &amp;&amp;sec) : <span class="built_in">fir</span>(<span class="built_in">move</span>(sec.fir)) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;second move construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">//这里也应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">  first fir;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  second oth;</span><br><span class="line">  second oth2 = <span class="built_in">move</span>(oth);</span><br><span class="line">  <span class="comment">// cout &lt;&lt; *oth.fir.num &lt;&lt; endl;   //程序报运行时错误</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    程序运行结果：</span></span><br><span class="line"><span class="comment">        construct!</span></span><br><span class="line"><span class="comment">        first move construct!</span></span><br><span class="line"><span class="comment">        second move construct</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="9、多态是怎么实现的">9、多态是怎么实现的</h4>
<p>由于派生类重写基类方法，然后用基类引用指向派生类对象，调用方法时候会进行动态绑定，这就是多态。 多态分为静态多态和动态多态：</p>
<ol>
<li>
<p>静态多态：重载。编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。</p>
<p>比如一个简单的加法函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Add</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span> </span>&#123;  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">Add</span>(<span class="number">666</span>, <span class="number">888</span>) &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">Add</span>(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>);          <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，第一条语句会调用函数1，而第二条语句会调用函数2，这绝不是因为函数的声明顺序，不信你可以将顺序调过来试试。</p>
</li>
<li>
<p>动态多态：其实要实现动态多态，需要几个条件——即动态绑定条件：</p>
<ol>
<li>虚函数。基类中必须有虚函数，在派生类中必须重写虚函数。</li>
<li>通过基类类型的指针或引用来调用虚函数。</li>
</ol>
<p>说到这，得插播一条概念：重写——也就是基类中有一个虚函数，而在派生类中也要重写一个原型（返回值、名字、参数）都相同的虚函数。不过协变例外。协变是重写的特例，基类中返回值是基类类型的引用或指针，在派生类中，返回值为派生类类型的引用或指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//协变测试函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Base* <span class="title">FunTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;victory&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Derived* <span class="title">FunTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;yeah&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Base b;</span><br><span class="line">  Derived d;</span><br><span class="line"></span><br><span class="line">  b.<span class="built_in">FunTest</span>(); <span class="comment">// victory</span></span><br><span class="line">  d.<span class="built_in">FunTest</span>(); <span class="comment">// yeah</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="什么是多态？多态如何实现？">什么是多态？多态如何实现？</h5>
<p><strong>多态</strong>：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。在基类的函数前加上 <code>virtual</code> 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。<br>
<strong>实现方法</strong>：多态是通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。</p>
<p><strong>实现过程</strong>：</p>
<ol>
<li>在类中用 <code>virtual</code> 关键字声明的函数叫做虚函数；</li>
<li>存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（虚函数表和类对应的，虚表指针是和对象对应）；</li>
<li>当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。</li>
</ol>
<h5 id="什么是多态？除了虚函数，还有什么方式能实现多态？">什么是多态？除了虚函数，还有什么方式能实现多态？</h5>
<ol>
<li>
<p>多态是面向对象的重要特性之一，它是一种行为的封装，就是不同对象对同一行为会有不同的状态。(举例 : 学生和成人都去买票时,学生会打折,成人不会)</p>
</li>
<li>
<p>多态是以封装和继承为基础的。在C++中多态分为静态多态（早绑定）和动态多态（晚绑定）两种，其中<strong>动态多态是通过虚函数实现，静态多态通过函数重载实现</strong>，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a)</span></span>;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="编译时多态和运行时多态的区别">编译时多态和运行时多态的区别</h5>
<ul>
<li>编译时多态：在程序编译过程中出现，发生在模板和函数重载中（泛型编程）。</li>
<li>运行时多态：在程序运行过程中出现，发生在继承体系中，是指通过基类的指针或引用访问派生类中的虚函数。</li>
</ul>
<p>编译时多态和运行时多态的区别：</p>
<ul>
<li>时期不同：编译时多态发生在程序编译过程中，运行时多态发生在程序的运行过程中；</li>
<li>实现方式不同：编译时多态运用泛型编程来实现，运行时多态借助虚函数来实现。</li>
</ul>
<h4 id="10、const-static-关键字有什么区别，能否同时使用">10、const, static 关键字有什么区别，能否同时使用</h4>
<h5 id="static">static</h5>
<ol>
<li>static局部变量 将一个变量声明为函数的局部变量，那么这个局部变量在函数执行完成之后不会被释放，而是继续保留在内存中</li>
<li>static 全局变量 表示一个变量在当前文件的全局内可访问</li>
<li>static 函数 表示一个函数只能在当前文件中被访问</li>
<li>static 类成员变量 表示这个成员为全类所共有</li>
<li>static 类成员函数 表示这个函数为全类所共有，而且只能访问静态成员变量</li>
</ol>
<h5 id="const">const</h5>
<ol>
<li>const 常量：定义时就初始化，以后不能更改。</li>
<li>const 形参：func(const int a){};该形参在函数里不能改变</li>
<li>const修饰类成员函数：该函数对成员变量只能进行只读操作</li>
</ol>
<h5 id="static关键字的作用">static关键字的作用</h5>
<p>（1）函数体内static变量的作用范围为该函数体，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；<br>
（2）在模块内的static全局变量和函数可以被模块内的函数访问，但不能被模块外其它函数访问；<br>
（3）在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；<br>
（4）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量，不能访问非静态成员。</p>
<h5 id="const关键字的作用">const关键字的作用</h5>
<p>（1）阻止一个变量被改变<br>
（2）声明常量指针和指针常量<br>
（3）const修饰形参，表明它是一个输入参数，在函数内部不能改变其值；<br>
（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；<br>
（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为”左值”。</p>
<h5 id="const-和-static-不能同时修饰成员函数">const 和 static 不能同时修饰成员函数</h5>
<p>const 的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。</p>
<p>我们也可以这样理解：两者的语意是矛盾的。static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态，与类型的静态变量没有关系。因此不能同时用它们。</p>
<h4 id="11、C-内存对齐">11、C++ 内存对齐</h4>
<h5 id="使用场景">使用场景</h5>
<p>内存对齐应用于三种数据类型中：<strong>struct/class/union</strong></p>
<p>struct/class/union内存对齐原则有四个：</p>
<ol>
<li>
<p>数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在 offset 为 0 的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。</p>
</li>
<li>
<p>结构体作为成员: 如果一个结构里有某些结构体成员,则结构体成员要从其内部&quot;最宽基本类型成员&quot;的整数倍地址开始存储。(struct a 里存有 struct b , b 里有 char , int , double 等元素,那 b 应该从 8 的整数倍开始存储)。</p>
</li>
<li>
<p>收尾工作: 结构体的总大小，也就是 sizeof 的结果，<strong>必须是其内部最大成员的&quot;最宽基本类型成员&quot;的整数倍</strong>。不足的要补齐。(基本类型不包括struct/class/uinon)。</p>
</li>
<li>
<p>sizeof(union)，以结构里面 size 最大元素为 union 的 size，因为在某一时刻，union 只有一个成员真正存储于该地址。</p>
</li>
</ol>
<p><strong>解析：</strong></p>
<ol>
<li>
<p><strong>什么是内存对齐？</strong></p>
<p>那么什么是字节对齐？在C语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构体、联合体等）的数据单元。在结构体中，<strong>编译器为结构体的每个成员按其自然边界（alignment）分配空间。</strong> 各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同。</p>
<p>为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，<strong>即所谓的“对齐”，比如 4 字节的 int 型，其起始地址应该位于 4 字节的边界上，即起始地址能够被 4 整除</strong>，也即“对齐”跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。</p>
<p>比如在32位cpu下，假设一个整型变量的地址为0x00000004(为4的倍数)，那它就是自然对齐的，而如果其地址为0x00000002（非4的倍数）则是非对齐的。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p>
</li>
<li>
<p><strong>为什么要字节对齐？</strong></p>
<p>需要字节对齐的根本原因在于 <strong>CPU 访问数据的效率问题</strong>。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则 CPU 如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003 的一个 short，第二次取从 0x00000004-0x00000005 的一个 short 然后组合得到所要的数据，如果变量在 0x00000003 地址上的话则要访问三次内存，第一次为 char，第二次为 short，第三次为 char，然后组合得到整型数据。</p>
<p>而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，而在x86上就不会出现错误，只是效率下降。</p>
<p>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。</p>
</li>
<li>
<p><strong>字节对齐实例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">example</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">char</span> b;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">double</span> c;  <span class="comment">// 8</span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">int</span> result = <span class="built_in"><span class="keyword">sizeof</span></span>(example); <span class="comment">// 24 </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果以最长20字节为准，内部double占8字节，这段内存的地址0x00000020并不是double的整数倍，只有当最小为0x00000024时可以满足整除double（8Byte）同时又可以容纳int a[5]的大小，所以正确的结果应该是 result=24</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];  <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">char</span> b;    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">double</span> c;  <span class="comment">// 8</span></span><br><span class="line">&#125;test_struct;</span><br><span class="line"><span class="keyword">int</span> result = <span class="built_in"><span class="keyword">sizeof</span></span>(test_struct);  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果我们不考虑字节对齐，那么内存地址0x0021不是double（8Byte）的整数倍，所以需要字节对齐，那么此时满足是double（8Byte）的整数倍的最小整数是0x0024，说明此时char b对齐int扩充了三个字节。所以最后的结果是result=32</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">char</span> b;   <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">double</span> c; <span class="comment">// 8 </span></span><br><span class="line">    <span class="keyword">int</span> a;    <span class="comment">// 4</span></span><br><span class="line">&#125;test_struct;  </span><br><span class="line"><span class="keyword">int</span> result = <span class="built_in"><span class="keyword">sizeof</span></span>(test_struct);  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，那就是占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍，所以 20 不是double（8Byte）的整数倍，我们还要扩充四个字节，最后的结果是result=24</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？">什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？</h5>
<p>内存对齐：编译器将程序中的每个“数据单元”安排在字的整数倍的地址指向的内存之中<br>
内存对齐的原则：</p>
<ol>
<li>结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；</li>
<li>结构体每个成员相对于结构体首地址的偏移量 （offset） 都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）；</li>
<li>结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）。</li>
</ol>
<p>进行内存对齐的原因：（主要是硬件设备方面的问题）</p>
<ol>
<li>某些硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常；</li>
<li>某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作；</li>
<li>相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间；</li>
<li>某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignment trap）；</li>
<li>某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。</li>
</ol>
<p>内存对齐的优点：</p>
<ol>
<li><strong>便于在不同的平台之间进行移植</strong>，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；</li>
<li><strong>提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取。</strong></li>
</ol>
<h4 id="12、指针和引用的区别是什么？">12、指针和引用的区别是什么？</h4>
<ul>
<li>是否可变：指针所指向的内存空间在程序运行过程中可以改变；而引用所绑定的对象一旦绑定就不能改变绑定的对象。</li>
<li>是否占内存：指针本身在内存中占有内存空间；引用相当于变量的别名，在内存中不占内存空间（具体取决于编译器的实现）。</li>
<li>是否可为空：指针可以为空；但是引用必须绑定对象。</li>
<li>是否能为多级：指针可以有多级；但是引用只能一级。</li>
</ul>
<p>引用是否占内存，取决于编译器的实现。<br>
如果编译器用指针实现引用，那么它占内存。<br>
如果编译器直接将引用替换为其所指的对象，则其不占内存（毕竟，替换掉之后，该引用实际就不存在了）。</p>
<p>顺便一提，你无法用 sizeof 得到引用的大小，sizeof 作用于引用时，你得到的是它对应的对象的大小。</p>
<h4 id="13、类模板和模板类的区别">13、类模板和模板类的区别</h4>
<ol>
<li>
<p>类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数</p>
</li>
<li>
<p>模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替。</p>
</li>
</ol>
<p><strong>解析</strong></p>
<ol>
<li>
<p>类模板的类型参数可以有一个或多个，每个类型前面都必须加class，如template &lt;class T1,class T2&gt;class someclass{…};在定义对象时分别代入实际的类型名，如 someclass&lt;int,double&gt; obj;</p>
</li>
<li>
<p>和使用类一样，使用类模板时要注意其作用域，只能在其有效作用域内用它定义对象。</p>
</li>
<li>
<p>模板可以有层次，一个类模板可以作为基类，派生出派生模板类。</p>
</li>
</ol>
<h4 id="14、C-内联函数">14、C++ 内联函数</h4>
<h5 id="inline-内联函数-作用及使用方法">inline 内联函数 作用及使用方法</h5>
<p><strong>内联函数的作用</strong>：</p>
<p><code>inline</code> 是一个关键字，可以用于定义内联函数。内联函数，像普通函数一样被调用，但是<strong>在调用时并不通过函数调用的机制而是直接在调用点处展开</strong>，这样可以大大<strong>减少由函数调用带来的开销</strong>，从而提高程序的运行效率。</p>
<ol>
<li>消除函数调用的开销。<br>
在内联函数出现之前，程序员通常用 #define 定义一些“函数”来消除调用这些函数的开销。内联函数设计的目的之一，就是取代 #define 的这项功能（因为使用 #define 定义的那些“函数”，编译器不会检查其参数的正确性等，而使用 inline 定义的函数，和普通函数一样，可以被编译器检查，这样有利于尽早发现错误）。</li>
<li>去除函数只能定义一次的限制。<br>
内联函数可以在头文件中被定义，并被多个 .cpp 文件 include，而不会有重定义错误。这也是设计内联函数的主要目的之一。</li>
</ol>
<p><strong>使用方法：</strong></p>
<ol>
<li>
<p><strong>类内定义成员函数默认是内联函数</strong><br>
在类内定义成员函数，可以不用在函数头部加 <code>inline</code> 关键字，因为编译器会自动将类内定义的函数（构造函数、析构函数、普通成员函数等）声明为内联函数，代码如下：</p>
</li>
<li>
<p>类外定义成员函数，若想定义为内联函数，需用关键字声明<br>
声明函数和定义函数处只要有一个地方加上 <code>inline</code> 即可，也可以都加上；只要确保在调用该函数之前把 <code>inline</code> 的信息告知编译器即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="built_in">A</span> (<span class="keyword">int</span> tmp) &#123; var = tmp; &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; var &lt;&lt; endl; &#125; <span class="comment">// 类内定义成员函数默认是内联函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">A::fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; var &lt;&lt; endl; &#125; <span class="comment">// 声明和定义只要有一处有 inline 即可，或都加上</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>关于减少函数调用的开销：</strong></p>
<ol>
<li>内联函数一定会被编译器在调用点展开吗？<br>
错，inline 只是对编译器的建议，而非命令。编译器可以选择忽视 inline。当程序员定义的 inline 函数包含复杂递归，或者 inlinie 函数本身比较长，编译器一般不会将其展开，而仍然会选择函数调用。</li>
<li>“调用” 普通函数时，一定是调用吗？<br>
错，即使是普通函数，编译器也可以选择进行优化，将普通函数在“调用”点展开。</li>
<li>既然内联函数在编译阶段已经在调用点被展开，那么程序运行时，对应的内存中不包含内联函数的定义，对吗？<br>
错。<br>
首先，如第一点所言，编译器可以选择调用内联函数，而非展开内联函数。因此，<strong>内存中仍然需要一份内联函数的定义，以供调用</strong>。<br>
而且，一致性是所有语言都应该遵守的准则。普通函数可以有指向它的函数指针，那么，内联函数也可以有指向它的函数指针，因此，内存中需要一份内联函数的定义，使得这样的函数指针可以存在。</li>
</ol>
<p><strong>关于去除函数只能定义一次的限制：</strong></p>
<ul>
<li>
<p>下述程序会报错：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;function 1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;function 2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">myPrint</span>();  <span class="comment">// error，会出现链接时错误， myPrint 函数被定义了两次。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>而下述程序不会报错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;inline function 1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;inline function 2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">myPrint</span>()<span class="comment">// 正常运行;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可见，内联函数可以在头文件中定义（即多个 .cpp 源文件可以定义函数名、参数都一样的内联函数，而不会有重定义错误）。</p>
</li>
</ul>
<h5 id="inline-函数工作原理">inline 函数工作原理</h5>
<ul>
<li>内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。</li>
<li>普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。</li>
</ul>
<h5 id="内联函数和宏函数的区别">内联函数和宏函数的区别</h5>
<ol>
<li>内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</li>
<li>内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义不是函数，编写较为复杂，常需要增加一些括号来避免歧义。</li>
<li>宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。</li>
</ol>
<p>区别：</p>
<ol>
<li><strong>宏定义不是函数</strong>，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；<strong>而内联函数本质上是一个函数</strong>，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句如 while、switch，并且内联函数本身不能直接调用自身。</li>
<li><strong>宏函数</strong>是在<strong>预编译</strong>的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；<strong>而内联函数</strong>则是在<strong>编译</strong>的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率</li>
<li><strong>宏定义是没有类型检查</strong>的，无论对还是错都是直接替换；<strong>而内联函数在编译的时候会进行类型的检查</strong>，内联函数满足函数的性质，比如有返回值、参数列表等</li>
</ol>
<p><strong>解析：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="built_in">MAX</span>(a,<span class="string">&quot;Hello&quot;</span>)； <span class="comment">//错误地比较int和字符串，没有参数类型检查</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内联函数示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+b=%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上a = add(1, 2);处在编译时将被展开为：a = (a + b);</span></span><br></pre></td></tr></table></figure>
<p><strong>1、使用时的一些注意事项：</strong></p>
<ul>
<li>使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性</li>
<li>inline 函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字 inline，即可将函数指定为 inline 函数。</li>
<li>同其它函数不同的是，最好将 inline 函数定义在头文件，而不仅仅是声明，因为编译器在处理 inline 函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。</li>
</ul>
<p><strong>2、内联函数使用的条件：</strong></p>
<ul>
<li>内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：</li>
<li>（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。</li>
<li>（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</li>
<li>内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。</li>
</ul>
<h5 id="内联函数和函数的区别，内联函数的作用。">内联函数和函数的区别，内联函数的作用。</h5>
<ol>
<li>内联函数比普通函数多了关键字<strong>inline</strong></li>
<li>内联函数避免了函数调用的<strong>开销</strong>；普通函数有调用的开销</li>
<li>普通函数在被调用的时候，需要<strong>寻址（函数入口地址）</strong>；内联函数不需要寻址。</li>
<li>内联函数有一定的限制，内联函数体要求<strong>代码简单</strong>，不能包含复杂的结构控制语句；普通函数没有这个要求。</li>
</ol>
<p><strong>内联函数的作用</strong>：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。</p>
<p><strong>解析：</strong></p>
<p>在使用内联函数时，应注意如下几点：</p>
<ol>
<li>
<p>在内联函数内不允许用循环语句和开关语句。</p>
<p>如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。</p>
</li>
<li>
<p>内联函数的定义必须出现在内联函数第一次被调用之前。</p>
</li>
</ol>
<h4 id="15、C-编译、链接的过程">15、C++ 编译、链接的过程</h4>
<p>编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接。</p>
<ul>
<li>
<p><strong>编译预处理</strong>：处理以 # 开头的指令；</p>
</li>
<li>
<p><strong>编译、优化</strong>：将源码 .cpp 文件翻译成 .s 汇编代码；</p>
</li>
<li>
<p><strong>汇编</strong>：将汇编代码 .s 翻译成机器指令 .o 文件；</p>
</li>
<li>
<p><strong>链接</strong>：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/1612676946-HVvkdR-image.png" alt="image.png" style="zoom: 50%;" />
</li>
</ul>
<p>链接分为两种：</p>
<ul>
<li><strong>静态链接</strong>：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</li>
<li><strong>动态链接</strong>：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</li>
</ul>
<p>二者的优缺点：</p>
<ul>
<li>静态链接：<strong>浪费空间</strong>，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（<strong>更新困难</strong>）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。</li>
<li>动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。</li>
</ul>
<h4 id="16、C-中哪些函数不能被声明为虚函数？">16、C++ 中哪些函数不能被声明为虚函数？</h4>
<p>常见的不不能声明为虚函数的有：普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数。</p>
<ol>
<li>
<p>为什么 C++ 不支持普通函数为虚函数？</p>
<p>普通函数（非成员函数）只能被 overload，不能被 override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。</p>
</li>
<li>
<p>为什么 C++ 不支持构造函数为虚函数？</p>
<ul>
<li>从存储空间的角度考虑：构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。</li>
<li>从使用的角度考虑：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用；构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用。</li>
<li>从实现上考虑：虚表指针是在创建对象之后才有的，因此构造函数不能定义成虚函数。创建对象需要调用构造函数，此时构造函数如果是虚函数，而虚函数的调用需要通过虚函数指针寻址才能调用，悖论；</li>
<li>从类型上考虑：在创建对象时需要明确其类型。<strong>构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数</strong>。</li>
</ul>
</li>
<li>
<p>为什么 C++ 不支持内联成员函数为虚函数？</p>
<p>其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。</p>
<p><strong>内联函数是在编译时期展开, 而虚函数的特性是运行时才动态绑定, 两者矛盾, 不能定义内联函数为虚函数</strong></p>
</li>
<li>
<p>为什么 C++ 不支持静态成员函数为虚函数？</p>
<p>这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。</p>
<p>静态成员函数属于一个类而非某一对象, 没有 this 指针, 它无法进行对象的判别</p>
</li>
<li>
<p>为什么 C++ 不支持友元函数为虚函数？</p>
<p>因为 C++ 不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。</p>
</li>
</ol>
<h4 id="17、C-内存管理">17、C++ 内存管理</h4>
<p><a target="_blank" rel="noopener" href="http://chenqx.github.io/2014/09/25/Cpp-Memory-Management/">C/C++内存管理详解 | ShinChan’s Blog (chenqx.github.io)</a></p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202112131243545.png" style="zoom: 67%;" />
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203112121258.png" alt="image-20211118095816959" style="zoom: 67%;" />
<ol>
<li>
<p><strong>内存分配方式</strong>：</p>
<p>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。</p>
<p><strong>栈</strong>，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。</p>
<p><strong>堆</strong>，就是那些由malloc等分配的内存块，和自由存储区是十分相似的，不过是用free来结束自己的生命。</p>
<p><strong>全局/静态存储区</strong>，全局变量和静态变量被分配到同一块内存中</p>
<p><strong>常量存储区</strong>，这是一块比较特殊的存储区，里面存放的是常量，不允许修改。</p>
<p>（<strong>自由存储区</strong>，就是那些由new分配的内存块，一般一个new就要对应一个delete。）</p>
</li>
<li>
<p><strong>常见的内存错误及其对策</strong>：</p>
<p>（1）分配失败：内存分配未成功，却使用了它。</p>
<p>（2）未初始化：内存分配虽然成功，但是尚未初始化就引用它。</p>
<p>（3）访问越界：内存分配成功并且已经初始化，但操作越过了内存的边界。</p>
<p>（4）忘记释放：忘记了释放内存，造成内存泄露。</p>
<p>（5）释放还使用：释放了内存却继续使用它。</p>
<p>对策：</p>
<p>（1）定义指针时，先初始化为 NULL。</p>
<p>（2）用malloc或new申请内存之后，应该<strong>立即检查</strong>指针值是否为NULL。防止使用指针值为NULL的内存。</p>
<p>（3）不要忘记为数组和动态内存<strong>赋初值</strong>。防止将未被初始化的内存作为右值使用。</p>
<p>（4）避免数字或指针的下标<strong>越界</strong>，特别要当心发生“多1”或者“少1”操作</p>
<p>（5）动态内存的申请与释放必须配对，防止<strong>内存泄漏</strong></p>
<p>（6）用free或delete释放了内存之后，立即将指针<strong>设置为NULL</strong>，防止“野指针”</p>
<p>（7）使用智能指针。</p>
</li>
<li>
<p><strong>内存泄露及解决办法</strong>：</p>
<p><strong>什么是内存泄露？</strong></p>
<p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。</p>
<p><strong>怎么检测？</strong></p>
<p>第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕, 要记得使用其相应的函数释放掉。</p>
<p>第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。</p>
<p>第三：使用智能指针。</p>
<p>第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。</p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202112131236456.png" style="zoom: 67%;" />
<p><strong>内存模型（内存布局）：</strong></p>
<p>如上图，<strong>从低地址到高地址，一个程序由代码段、数据段、</strong> <strong>BSS</strong> <strong>段组成。</strong></p>
<ol>
<li>
<p><strong>代码区：</strong> 存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。</p>
</li>
<li>
<p><strong>全局区/静态区</strong></p>
<ol>
<li><strong>数据段：</strong> 存放程序中已初始化的全局变量和静态变量的一块内存区域。</li>
<li><strong>BSS</strong> 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。</li>
</ol>
</li>
<li>
<p>可执行程序在运行时又会多出两个区域：堆区和栈区。</p>
<p><strong>堆区：</strong> 动态申请内存用。堆从低地址向高地址增长。</p>
<p><strong>栈区：</strong> 存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。</p>
</li>
<li>
<p>最后还有一个<strong>文件映射区</strong>，位于堆和栈之间。</p>
</li>
</ol>
<p><strong>堆 heap</strong> ：一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收 。分配方式类似于链表。</p>
<p><strong>栈 stack</strong> ：由编译器自动分配释放，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等。其操作方式类似于数据结构中的栈。</p>
<p><strong>常量存储区</strong> ：存放常量，不允许修改。</p>
<h4 id="18、C-的重载和重写？">18、C++ 的重载和重写？</h4>
<h5 id="C-的重载和重写是如何实现的">C++ 的重载和重写是如何实现的</h5>
<p>重载：C++ 利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在编译阶段完成的。</p>
<p>C++ 定义同名重载函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b)</span> </span>&#123; <span class="keyword">return</span> ((a)+(b)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">float</span> b)</span> </span>&#123; <span class="keyword">return</span> ((a)+(b)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">float</span> a,<span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> ((a)+(b)); &#125;</span><br></pre></td></tr></table></figure>
<p>重写：在基类的函数前加上 virtual 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p>
<ol>
<li>用 virtual 关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。</li>
<li>存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。</li>
<li>多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。</li>
<li>重写用虚函数来实现，结合动态绑定。</li>
<li>纯虚函数是虚函数再加上 = 0。</li>
<li>抽象类是指包括至少一个纯虚函数的类。</li>
</ol>
<p>纯虚函数：<code>virtual void fun() = 0</code>。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。</p>
<h5 id="重载、重写、隐藏的区别">重载、重写、隐藏的区别</h5>
<ul>
<li>
<p>重载：是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据<strong>参数列表</strong>确定调用哪个函数，<strong>重载不关心函数返回类型</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">float</span> tmp)</span></span>;        <span class="comment">// 重载 参数类型不同（相对于上一个函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp, <span class="keyword">float</span> tmp1)</span></span>; <span class="comment">// 重载 参数个数不同（相对于上一个函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">float</span> tmp, <span class="keyword">int</span> tmp1)</span></span>; <span class="comment">// 重载 参数顺序不同（相对于上一个函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span></span>;            <span class="comment">// error: &#x27;int A::fun(int)&#x27; cannot be overloaded 错误：注意重载不关心函数返回类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重写(覆盖)：是指派生类中存在重新定义的函数。<strong>函数名、参数列表、返回值类型(协变返回类型除外)都必须同基类中被重写的函数一致，只有函数体不同</strong>。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 <code>virtual</code> 修饰。</p>
<p>在 C++ 中，只要原来的返回类型是指向基类的指针或引用，新的返回类型是指向派生类的指针或引用，覆盖的方法就可以改变返回类型。这样的类型称为协变返回类型（Covariant returns type)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; &#125; <span class="comment">// 重写基类中的 fun 函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    p-&gt;<span class="built_in">fun</span>(<span class="number">3</span>); <span class="comment">// Derived::fun(int) : 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>隐藏：是<strong>指派生类的函数屏蔽了与其同名的基类函数，只要函数名相同</strong>，不管参数列表是否相同，基类函数都会被隐藏。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp, <span class="keyword">float</span> tmp1)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun(int tmp, float tmp1)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::fun(int tmp)&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 隐藏基类中的同名函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derive ex;</span><br><span class="line">    ex.<span class="built_in">fun</span>(<span class="number">1</span>);       <span class="comment">// Derive::fun(int tmp)</span></span><br><span class="line">    ex.<span class="built_in">fun</span>(<span class="number">1</span>, <span class="number">0.01</span>); <span class="comment">// error: candidate expects 1 argument, 2 provided</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：上述代码中 <code>ex.fun(1, 0.01);</code> 出现错误，说明派生类中将基类的同名函数隐藏了。若是想调用基类中的同名函数，可以加上类型名指明 <code>ex.Base::fun(1, 0.01);</code>，这样就可以调用基类中的同名函数。</p>
</li>
</ul>
<p><strong>重写和重载的区别</strong>：</p>
<ul>
<li>范围区别：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间（子类和父类之间）。</li>
<li>参数区别：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型（协变返回类型除外）都需要和原函数相同，父类中被重写的函数需要有 <code>virtual</code> 修饰。</li>
<li><code>virtual</code> 关键字：重写的函数基类中必须有 <code>virtual</code>关键字的修饰，重载的函数可以有 <code>virtual</code> 关键字的修饰也可以没有。</li>
</ul>
<p><strong>隐藏和重写，重载的区别</strong>：</p>
<ul>
<li>范围区别：隐藏与重载范围不同，隐藏发生在不同类中。</li>
<li>参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被 <code>virtual</code> 修饰，基类函数都是被隐藏，而不是重写。</li>
</ul>
<h4 id="19、内存中堆与栈的区别是什么？">19、内存中堆与栈的区别是什么？</h4>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">堆</th>
<th style="text-align:center">栈</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">申请方式</td>
<td style="text-align:center">堆是程序员主动申请</td>
<td style="text-align:center">栈是系统自动分配</td>
</tr>
<tr>
<td style="text-align:center">申请效率</td>
<td style="text-align:center">堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片</td>
<td style="text-align:center">栈是有系统自动分配，申请效率高，但程序员无法控制</td>
</tr>
<tr>
<td style="text-align:center">内存分配</td>
<td style="text-align:center">堆在内存中的空间（向高地址扩展）是不连续的</td>
<td style="text-align:center">栈在内存中是连续的一块空间（向低地址扩展），最大容量是系统预定好的</td>
</tr>
<tr>
<td style="text-align:center">存放内容</td>
<td style="text-align:center">堆中存放的内容由程序员控制</td>
<td style="text-align:center">栈中存放的是局部变量，函数的参数</td>
</tr>
<tr>
<td style="text-align:center">申请后系统响应</td>
<td style="text-align:center">申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除。大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。</td>
<td style="text-align:center">分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出</td>
</tr>
</tbody>
</table>
<ol>
<li><strong>堆栈空间分配不同</strong>。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。</li>
<li><strong>堆栈缓存方式不同</strong>。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。</li>
<li><strong>堆栈数据结构不同</strong>。堆类似数组结构；栈类似栈结构，先进后出。</li>
</ol>
<h4 id="20、STL-中的内存分配器原理">20、STL 中的内存分配器原理</h4>
<p><strong>一、STL泛型容器 与 内存管理</strong></p>
<p><strong>1.1 STL泛型容器中隐藏了内存管理工作</strong></p>
<ul>
<li>STL提供了很多泛型容器，如vector，list，map等。程序员使用时之关心如何存放对象，不用关心如何管理内存。</li>
<li>容器会根据需要自动增长内存，在退出其作用域时，也会自动销毁占有的内存。</li>
<li>STL容器巧妙的避开了繁琐而且容易出错的内存管理工作。</li>
</ul>
<p><strong>二、STL默认的内存分配器</strong></p>
<p><strong>2.1 STL默认的内存分配器</strong></p>
<ul>
<li>隐藏在容器后的内存管理工作是通过STL提供的 一个默认的allocator实现的。</li>
</ul>
<p><strong>2.2 定制allocator</strong></p>
<ul>
<li>
<p>用户可以定制自己的allocator，只需要实现allocator模板所定义的接口方法即可，然后通过将自定义的allocator作为模板参数传递给STL容器。</p>
</li>
<li>
<p>创建一个使用自定义allocator的STL容器对象，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>, UserDefinedAllocator&gt;  vec;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>大多数情况下，STL默认的allocator就已经足够了。</p>
</li>
</ul>
<p><strong>三、STL默认内存分配器实现原理</strong></p>
<p><strong>3.1 分配器原理：两级分配器</strong></p>
<p>allocator是一个由两级分配器构成的内存管理器。</p>
<ol>
<li>
<p>当申请的内存大小 &gt; 128 byte时，启动第一级内存分配器，通过malloc直接向系统的堆空间分配。</p>
</li>
<li>
<p>当申请的内存大小 &lt; 128 byte时，启动第二级内存分配器，从一个预先分配好的内存池中取一块内存交给用户。</p>
<p>这个内存池由16个不同大小(8个倍数，8~128byte)的空闲列表组成，allocator会 申请 的大小(将这个大小round up成8的倍数)，从对应的空闲块列表取头块给用户。</p>
</li>
</ol>
<p><strong>3.2 优点</strong></p>
<ol>
<li>小对象的快速分配。</li>
<li>避免了内存碎片的生成</li>
</ol>
<h4 id="21、构造函数和析构函数可以被声明为虚函数吗？">21、构造函数和析构函数可以被声明为虚函数吗？</h4>
<p>构造函数不能定义为虚函数，原因：</p>
<ul>
<li>从存储空间的角度考虑：构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。</li>
<li>从使用的角度考虑：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用；构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用。</li>
<li>从实现上考虑：虚表指针是在创建对象之后才有的，因此构造函数不能定义成虚函数。创建对象需要调用构造函数，此时构造函数如果是虚函数，而虚函数的调用需要通过虚函数指针寻址才能调用，悖论；</li>
<li>从类型上考虑：在创建对象时需要明确其类型。<strong>构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数</strong>。</li>
</ul>
<p>析构函数一般定义成虚函数，原因：</p>
<ul>
<li><strong>析构函数定义成虚函数是为了防止内存泄漏</strong>，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。</li>
<li>析构函数最好定义为虚函数，特别是对于含有继承关系的类；（被多态使用的基类的析构函数应该定义为虚函数）。如果一个类没有被继承，以后也不会被继承，那么，它的析构函数不应该是虚函数。因为虚函数是由额外开销的，需要一个指针，vptr，来实现虚函数。</li>
</ul>
<ol>
<li>
<p>虚析构：将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生来无法被析构。</p>
<ol>
<li>用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构</li>
<li>用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。</li>
</ol>
<p><strong>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存</strong>。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
</li>
</ol>
<h4 id="22、类默认的构造函数是什么？">22、类默认的构造函数是什么？</h4>
<p>默认构造函数是可以不用实参进行调用的构造函数，它包括了以下两种情况：</p>
<ol>
<li><strong>没有带明显形参的构造函数。</strong></li>
<li><strong>提供了默认实参的构造函数。</strong></li>
</ol>
<p>类设计者可以自己写一个默认构造函数。编译器帮我们写的默认构造函数，称为“合成的默认构造函数”。</p>
<p>强调“没有带明显形参”的原因是，编译器总是会为我们的构造函数形参表插入一个隐含的this指针，所以”本质上”是没有不带形参的构造函数的，只有不带明显形参的构造函数，它就是默认构造函数。</p>
<p>只有当一个类没有定义构造函数时，编译器才会自动生成一个默认构造函数。但惟有当这些函数被需要（被调用），它们才会被编译器创建出来。（“这些函数“指的是编译器版本的复制构造函数、赋值操作符和析构函数，还包括了默认构造函数。）</p>
<p><strong>编译器需要默认构造函数的四种情况，总结起来就是:</strong></p>
<p><strong>a) 调用对象成员或基类的默认构造函数。</strong></p>
<p><strong>b) 为对象初始化虚表指针与虚基类指针。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203121144375.png" alt="image-20220312114443244"></p>
<h4 id="23、lambda-函数的特点，和普通函数相比有什么优点？">23、lambda 函数的特点，和普通函数相比有什么优点？</h4>
<ul>
<li>lambda 表达式是一个可调度的代码单元，可以视为一个未命名的内部函数</li>
<li><strong>lambda 函数是一个函数对象，编译器在编译时会生成一个 lambda 对象的类，然后再生成一个该命令未命名的对象</strong></li>
<li>比如你代码里有一些小函数，而这些函数一般只被调用一次（比如函数指针），这时你就可以用lambda表达式替代他们，这样代码看起来更简洁些，用起来也方便</li>
<li>距离：定义离使用的地方更近</li>
<li>简洁：代码简洁</li>
<li>效率：函数指针方法阻止了内联。而lambda通常不会阻止内联</li>
<li>功能：可以访问作用域内的任何动态变量，自动捕获上下文中的变量，比普通函数更方便</li>
<li>Lambda表达式的作用域更容易控制，有助于减少命名冲突</li>
</ul>
<p>lambda 的形式如下：<br>
[捕获列表] (参数列表) -&gt; 返回类型 { 函数部分 }<br>
[capture list] (parameter list) -&gt; return type { function body }</p>
<ol>
<li>
<p>capture list 捕获列表是 lambda 函数所定义的函数的局部变量列表， 通常为空</p>
<ul>
<li>
<p>一个 lambda 只有在其捕获列表中捕获一个所在函数中的局部变量，才能在函数体中使用该变量。</p>
</li>
<li>
<p>捕获列表只用于局部非 static 变量。 lambda 可以直接使用局部 static 变量 和在它所在函数之外的声明的名字。</p>
</li>
<li>
<p>捕获列表的变量可以分为 值 或 引用传递。</p>
</li>
<li>
<p>值传递： lambda 捕获的变量在 lambda 函数 创建时 就发生了拷贝而非调用时。</p>
</li>
<li>
<p>隐式捕获：<br>
编译器可以根据 lambda 中的代码推导使用的变量，为指示编译器推断捕获列表，应该在捕获列表中写一个 &amp; 或 =</p>
<ul>
<li>&amp; 告知编译器采用引用传递方式</li>
<li>= 告知编译器采用值传递方式</li>
</ul>
</li>
<li>
<p>当混合使用时，捕获列表第一个参数必须是 &amp; 或 = ，此符号指定了默认捕获方式为引用或值。且显示捕获的变量必须和隐式捕获使用不同的传递方式。</p>
</li>
</ul>
</li>
<li>
<p>pameter list</p>
<p>参数列表和普通函数类似，但是 <strong>lambda 不能有默认参数</strong>【lambda 实参和形参数目一定相等】</p>
</li>
<li>
<p>return type</p>
<ul>
<li>
<p>与普通函数不同的是: lambda 必须使用 <strong>尾置返回</strong> 来指定返回类型。</p>
</li>
<li>
<p>如果忽略返回类型，lambda 表达式会根据函数体中的代码推断出返回类型</p>
</li>
<li>
<p>若函数体只有一个 return 语句， 则返回类型从返回表达式的类型推断而来，否则，若未指定返回类型，返回类型为 void</p>
</li>
<li>
<p>Note: 如果 lambda 的函数体包含任意单一 return 之外的内容， 且未指定返回类型，则返回 void</p>
</li>
<li>
<p>当需要为 lambda 定义返回类型时，必须使用尾置返回类型</p>
</li>
</ul>
</li>
<li>
<p>function body</p>
<ul>
<li>与常规函数类似</li>
</ul>
</li>
</ol>
<p>所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。</p>
<p>我们可以忽略参数列表和返回类型，但<strong>必须永远包含捕获列表和函数体</strong>，不能有默认参数</p>
<p>定义</p>
<p>lambda 匿名函数很简单，可以套用如下的语法格式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[外部变量访问方式说明符] (参数) <span class="keyword">mutable</span> <span class="keyword">noexcept</span>/<span class="keyword">throw</span>() -&gt; 返回值类型  &#123;  </span><br><span class="line">	函数体;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中各部分的含义分别为：</p>
<ol>
<li>
<p>[外部变量方位方式说明符]<br>
[ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。<br>
所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。</p>
</li>
<li>
<p>(参数)<br>
和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；</p>
</li>
<li>
<p><strong>mutable</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203121149683.png" alt="image-20220222163614001" style="zoom:67%;" />
<p>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的原来值，修改的是拷贝的值。而如果想修改它们，就必须使用 mutable 关键字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">auto</span> f = [v]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ++v;</span><br><span class="line">	&#125;;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl; <span class="comment">// 21</span></span><br><span class="line">	cout &lt;&lt; v &lt;&lt; endl;   <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**注意:**对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/image-20220222163418189.png" alt="image-20220222163418189" style="zoom:80%;" />
</li>
<li>
<p>noexcept/throw()<br>
可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。</p>
</li>
<li>
<p>-&gt; 返回值类型<br>
指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略&quot;-&gt; 返回值类型&quot;。</p>
</li>
<li>
<p>函数体<br>
和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。</p>
</li>
</ol>
<h4 id="24、父类和子类是不是在同一个虚函数表">24、父类和子类是不是在同一个虚函数表</h4>
<p><strong>父类的虚函数表和子类的虚函数表不是同一个表</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36359022/article/details/81870219">C++多态虚函数表详解(多重继承、多继承情况)</a></p>
<h4 id="25、STL-中的-map-的实现原理">25、STL 中的 map 的实现原理</h4>
<p>map是关联式容器，它们的底层容器都是<strong>红黑树</strong>。map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。</p>
<ol>
<li>
<p>map的特性如下</p>
<p>（1）map以 <code>RBTree</code> 作为底层容器；</p>
<p>（2）所有元素都是 <code>键 + 值</code> 存在；</p>
<p>（3）不允许键重复；</p>
<p>（4）所有元素是通过键进行自动排序的；</p>
<p>（5）map的键是不能修改的，但是其键对应的值是可以修改的。</p>
</li>
</ol>
<h4 id="26、红黑树相关">26、红黑树相关</h4>
<p><strong>1.stl中的set底层用的什么数据结构？</strong></p>
<p>红黑树</p>
<p><strong>2.红黑树的数据结构怎么定义？</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span> RED = <span class="number">0</span>, BLACK = <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span> *<span class="title">left</span>, *<span class="title">right</span>, *<span class="title">parent</span>;</span></span><br><span class="line">  <span class="keyword">int</span> key;</span><br><span class="line">  <span class="keyword">int</span> data;</span><br><span class="line">  Color color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>3.红黑树有哪些性质？</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203121441480.png" alt="img" style="zoom: 50%;" />
<p>一般的，红黑树，满足以下性质，即只有满足以下全部性质的树，我们才称之为红黑树：<br>
1）每个结点要么是红的，要么是黑的。<br>
2）根结点是黑的。<br>
3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。<br>
4）如果一个结点是红的，那么它的俩个儿子都是黑的。<br>
5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。</p>
<p>正是红黑树的这5条性质，使一棵n个结点的红黑树始终保持了 <code>logn</code> 的高度，从而也就解释了上面所说的“红黑树的查找、插入、删除的时间复杂度最坏为 <code>O(log n)</code>”这一结论成立的原因。</p>
<p>（注：上述第3、5点性质中所说的NULL结点，包括wikipedia.算法导论上所认为的叶子结点即为树尾端的NIL指针，或者说NULL结点。然百度百科以及网上一些其它博文直接说的叶结点，则易引起误会，因，此叶结点非子结点）</p>
<p><strong>4.红黑树的各种操作的时间复杂度是多少？</strong></p>
<p>能保证在最坏情况下，基本的动态几何操作的时间均为 <code>O(logn)</code></p>
<p><strong>5.红黑树相比于BST和AVL树有什么优点？</strong></p>
<p>红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。红黑树能够以 <code>O(logn)</code> 的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。</p>
<p>相比于BST，因为红黑树可以能确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证O(logN)的，这是要好于二叉查找树的。因为二叉查找树最坏情况可以让查找达到O(N)。</p>
<p>红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高，所以AVL在插入和删除中所做的后期维护操作肯定会比红黑树要耗时好多，但是他们的查找效率都是O(logN)，所以红黑树应用还是高于AVL树的。 实际上插入 AVL 树和红黑树的速度取决于你所插入的数据：如果你的数据分布较好, 则比较宜于采用 AVL树(例如随机产生系列数), 但是如果你想处理比较杂乱的情况, 则红黑树是比较快的。</p>
<p><strong>6.红黑树相对于哈希表，在选择使用的时候有什么依据？</strong></p>
<p>权衡三个因素: 查找速度, 数据量, 内存使用，可扩展性。<br>
　　总体来说，hash 查找速度会比 map 快，而且查找速度基本和数据量大小无关，属于常数级别; 而 map 的查找速度是log(n)级别。并不一定常数就比log(n) 小，hash还有hash函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑hash。但若你对内存使用特别严格， 希望程序尽可能少消耗内存，那么一定要小心，hash可能会让你陷入尴尬，特别是当你的hash对象特别多时，你就更无法控制了，而且 hash的构造速度较慢。</p>
<p>红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。</p>
<p>在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。Linux内核在管理vm_area_struct时就是采用了红黑树来维护内存块的。</p>
<p>红黑树通过扩展节点域可以在不改变时间复杂度的情况下得到结点的秩。</p>
<p><strong>7.如何扩展红黑树来获得比某个结点小的元素有多少个？</strong></p>
<p>这其实就是求节点元素的顺序统计量，当然任意的顺序统计量都可以需要在O(lgn)时间内确定。</p>
<p>在每个节点添加一个size域，表示以结点 x 为根的子树的结点树的大小，则有</p>
<p>size[x] = size[[left[x]] + size [right[x]] + 1;</p>
<p>这时候红黑树就变成了一棵顺序统计树。</p>
<p>利用size域可以做两件事：</p>
<p>1). 找到树中第i小的结点；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OS-<span class="built_in">SELECT</span>(x;,i)  </span><br><span class="line">r = size[left[x]] + <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">if</span> i == r  </span><br><span class="line">     <span class="keyword">return</span> x  </span><br><span class="line">elseif i &lt; r  </span><br><span class="line">     <span class="keyword">return</span> OS-<span class="built_in">SELECT</span>(left[x], i)  </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> OS-<span class="built_in">SELECT</span>(right[x],  i)  </span><br></pre></td></tr></table></figure>
<p>思路：size[left[x]]表示在对x为根的子树进行中序遍历时排在x之前的个数，递归调用的深度不会超过O(lgn);</p>
<p>2).确定某个结点之前有多少个结点，也就是我们要解决的问题；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OS-<span class="built_in">RANK</span>(T,x)  </span><br><span class="line">r = x.left.size + <span class="number">1</span>;  </span><br><span class="line">y = x;  </span><br><span class="line"><span class="keyword">while</span> y != T.root  </span><br><span class="line">         <span class="keyword">if</span> y == y.p.right  </span><br><span class="line">                 r = r + y.p.left.size +<span class="number">1</span>  </span><br><span class="line">         y = y.p  </span><br><span class="line"><span class="keyword">return</span> r  </span><br></pre></td></tr></table></figure>
<p>思路：x的秩可以视为在对树的中序遍历种，排在x之前的结点个数加上一。最坏情况下，OS-RANK运行时间与树高成正比，所以为O (lgn).</p>
<h4 id="27、C-的内存分区">27、C++ 的内存分区</h4>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mehome/p/13616182.html">C++内存分区</a></p>
<h4 id="28、vector-和-list-中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？">28、vector 和 list 中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？</h4>
<ol>
<li>
<p>迭代器和指针之间的区别</p>
<p>**迭代器不是指针，是类模板，表现的像指针。**他只是模拟了指针的一些功能，重载了指针的一些操作符，–&gt;、++、–等。迭代器封装了指针，是一个”可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象，<strong>本质是封装了原生指针</strong>，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p>
<p><strong>迭代器返回的是对象引用而不是对象的值</strong>，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。</p>
</li>
<li>
<p>vector和list特性</p>
<p><strong>vector特性</strong> 动态数组。元素在内存连续存放。随机存取任何元素都在常数时间完成。在尾端增删元素具有较大的性能（大部分情况下是常数时间）。</p>
<p><strong>list特性</strong> 双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。</p>
</li>
<li>
<p>vector增删元素</p>
<p>对于vector而言，删除某个元素以后，该元素后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。</p>
</li>
<li>
<p>list增删元素</p>
<p>对于list而言，删除某个元素，只有“指向被删除元素”的那个迭代器失效，其它迭代器不受任何影响。</p>
</li>
</ol>
<h4 id="29、菱形继承问题">29、菱形继承问题</h4>
<p>上述程序的继承关系如下：（菱形继承）</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202241911112.png" alt="image.png" style="zoom: 50%;" />
<p><strong>上述代码中存的问题：</strong><br>
对于派生类 <code>Derive</code> 上述代码中存在直接继承关系和间接继承关系。</p>
<ul>
<li>
<p>直接继承：<code>Base2</code> 、<code>Base3</code></p>
</li>
<li>
<p>间接继承：<code>Base1</code></p>
</li>
<li>
<p>问题：对于派生类中继承的的成员变量 <code>var1</code> ，从继承关系来看，实际上保存了两份，一份是来自基类 <code>Base2</code>，一份来自基类 <code>Base3</code>。因此，出现了<strong>命名冲突，二义性问题</strong>。</p>
</li>
</ul>
<p><strong>解决方法 1：</strong> <strong>声明出现冲突的成员变量来源于哪个类</strong></p>
<p><strong>解决方法 2：</strong> <strong>虚继承</strong></p>
<p>使用虚继承的目的：保证存在命名冲突的成员变量在派生类中只保留一份，即让间接基类中的成员在派生类中只保留一份。解决二义性问题。在菱形继承关系中，间接基类称为虚基类，直接基类和间接基类之间的继承关系称为虚继承。</p>
<p>实现方式：在继承方式前面加上 <code>virtual</code> 关键字。</p>
<p>类之间的继承关系：</p>
<img src="https://pic.leetcode-cn.com/1612681729-IhAKvb-image.png" alt="image.png" style="zoom:50%;" />
<ol>
<li>下面的图表可以用来解释菱形继承问题。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/C657A418177A4F4E2EC51FE4261953DD" style="zoom: 33%;" />
<ul>
<li>
<p>假设我们有类B和类C，它们都继承了相同的类A。另外我们还有类D，类D通过多重继承机制继承了类B和类C。因为上述图表的形状类似于菱形，因此这个问题被形象地称为菱形继承问题。现在，我们将上面的图表翻译成具体的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Animal类对应于图表的类A*</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span>  <span class="comment">// 基类</span></span><br><span class="line">  <span class="keyword">int</span> weight;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> weight; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> :</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> :</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Liger</span> :</span> <span class="keyword">public</span> Tiger, <span class="keyword">public</span> Lion &#123; <span class="comment">/* ... */</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们给出了一个具体的菱形继承问题例子。Animal类对应于最顶层类（图表中的A），Tiger和Lion分别对应于图表的B和C，Liger类（狮虎兽，即老虎和狮子的杂交种)对应于D。</p>
<p>现在，问题是如果我们有这种继承结构会出现什么样的问题。</p>
<p>看看下面的代码后再来回答问题吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Liger lg;</span><br><span class="line">  <span class="comment">/*编译错误，下面的代码不会被任何C++编译器通过 */</span></span><br><span class="line">  <span class="keyword">int</span> weight = lg.<span class="built_in">getWeight</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在我们的继承结构中，我们可以看出Tiger和Lion类都继承自Animal基类。所以问题是：因为Liger多重继承了Tiger和Lion类，因此Liger类会有两份Animal类的成员（数据和方法），Liger对象&quot;lg&quot;会包含Animal基类的两个子对象。</p>
<p>所以，你会问Liger对象有两个Animal基类的子对象会出现什么问题？再看看上面的代码-调用 <code>lg.getWeight()</code>将会导致一个编译错误。这是因为编译器并不知道是调用 Tiger 类的 <code>getWeight()</code> 还是调用 Lion 类的 <code>getWeight()</code> 。所以，调用 <code>getWeight</code> 方法是不明确的，因此不能通过编译。</p>
</li>
</ul>
<ol start="2">
<li>
<p>我们给出了菱形继承问题的解释，但是现在我们要给出一个菱形继承问题的解决方案。如果Lion类和Tiger类在分别继承Animal类时都用virtual来标注，对于每一个Liger对象，C++会保证只有一个Animal类的子对象会被创建。看看下面的代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>
<p>你可以看出唯一的变化就是我们在类Tiger和类Lion的声明中增加了&quot;virtual&quot;关键字。现在类Liger对象将会只有一个Animal子对象，下面的代码编译正常:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Liger lg;</span><br><span class="line">  <span class="comment">//既然我们已经在Tiger和Lion类的定义中声明了&quot;virtual&quot;关键字，于是下面的代码编译OK </span></span><br><span class="line">  <span class="keyword">int</span> weight = lg.<span class="built_in">getWeight</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="30、内存泄漏，怎么确定内存泄漏？">30、内存泄漏，怎么确定内存泄漏？</h4>
<p><strong>什么是内存泄露？</strong></p>
<p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）<strong>子类继承父类时，父类析构函数不是虚函数</strong>。（3）Windows句柄资源使用后没有释放。</p>
<p><strong>怎么检测？</strong></p>
<p>第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。</p>
<p>第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。</p>
<p>第三：使用智能指针。</p>
<p>第四：一些常见的工具插件，如 ccmalloc、Dmalloc、Leaky、Valgrind 等等。</p>
<p><strong>内存泄漏</strong>：由于疏忽或错误导致的程序未能释放已经不再使用的内存。<br>
进一步解释：</p>
<ul>
<li>
<p>并非指内存从物理上消失，而是指程序在运行过程中，<strong>由于疏忽或错误而失去了对该内存的控制</strong>，从而造成了内存的浪费。</p>
</li>
<li>
<p>常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。</p>
</li>
<li>
<p>使用 <code>malloc</code>、<code>calloc</code>、<code>realloc</code>、<code>new</code> 等分配内存时，使用完后要调用相应的 <code>free</code> 或 <code>delete</code> 释放内存，否则这块内存就会造成内存泄漏。</p>
</li>
<li>
<p>指针重新赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">char</span> *p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">p = np;</span><br></pre></td></tr></table></figure>
<p>开始时，指针 <code>p</code> 和 <code>p1</code> 分别指向一块内存空间，但指针 <code>p</code> 被重新赋值，导致 <code>p</code> 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。</p>
</li>
</ul>
<p><strong>防止内存泄漏的方法：</strong></p>
<ol>
<li><strong>内部封装：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。</strong></li>
<li><strong>智能指针</strong><br>
智能指针是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用</li>
</ol>
<h4 id="31、只定义析构函数，会自动生成哪些构造函数？">31、只定义析构函数，会自动生成哪些构造函数？</h4>
<p><strong>只定义了析构函数，编译器将自动为我们生成默认构造函数和拷贝构造函数、拷贝赋值运算符。</strong></p>
<ol>
<li>
<p>默认构造函数和初始化构造函数。<br>
在定义类的对象的时候，完成对象的初始化工作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Student</span>() &#123;  <span class="comment">//默认构造函数</span></span><br><span class="line">    num = <span class="number">1001</span>;</span><br><span class="line">    age = <span class="number">18</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Student</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> a) : <span class="built_in">num</span>(n), <span class="built_in">age</span>(a) &#123;&#125;  <span class="comment">//初始化构造函数</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Student s1;            <span class="comment">//用默认构造函数初始化对象S1</span></span><br><span class="line">  <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">1002</span>, <span class="number">18</span>)</span></span>;  <span class="comment">//用初始化构造函数初始化对象S2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>拷贝构造函数、拷贝赋值运算符<br>
有了有参的构造了，编译器就不提供默认的构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span>* p;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test</span>(<span class="keyword">int</span> ai, <span class="keyword">int</span> value) &#123;</span><br><span class="line">    i = ai;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Test</span>() &#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line">  <span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;i = t.i;</span><br><span class="line">    <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*t.p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//复制构造函数用于复制本类的对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;  <span class="comment">//将对象t1复制给t2。注意复制和赋值的概念不同。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拷贝构造函数默认实现的是值拷贝（浅拷贝）。<br>
如果类外面有这样一个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HasPtr <span class="title">f</span><span class="params">(HasPtr hp)</span> </span>&#123;</span><br><span class="line">    HasPtr ret = hp;</span><br><span class="line">    <span class="comment">///... 其他操作</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>当函数执行完了之后，将会调用 hp 和 ret 的析构函数，将 hp 和 ret 的成员 ps 给 delete 掉，但是由于 ret 和 hp 指向了同一个对象，因此该对象的 ps 成员被 delete 了两次，这样产生一个未定义的错误，所以说，如果一个类定义了析构函数，那么它要定义自己的拷贝构造函数和默认构造函数。</p>
</li>
</ol>
<h4 id="32、变量的声明和定义区别？">32、变量的声明和定义区别？</h4>
<p>一、变量的声明和定义</p>
<p>1.1 声明</p>
<p>声明是用来告诉编译器变量的名称和类型，而不分配内存。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> var; <span class="comment">// 声明 </span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> ble = <span class="number">10</span>; <span class="comment">// 定义 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> INT; <span class="comment">// 声明 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span> <span class="comment">// 声明</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，语句 extern int var；表示 var 在别的文件中已经定义，提示编译器遇到此变量时在其它模块中寻找其定义。语句 extern int ble = 10；表示定义了变量 ble，这一点需要注意。</p>
<p>**注意：**即使是 extern ，<strong>如果给变量赋值了，就是定义了</strong>。</p>
<p>1.2 定义</p>
<p>定义是为了给变量分配内存，可以为变量赋初值。</p>
<p>**注意：**全局变量或静态变量初始值为0，局部变量初始化为随机值。</p>
<p>在 C/C++ 中，变量的声明和定义区别并不大，定义和声明往往是同时发生，变量定义时，会根据变量类型分配空间，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value ; <span class="comment">//声明 + 定义 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="comment">// 声明 + 定义    </span></span><br><span class="line">    <span class="keyword">int</span> left;    </span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>上面代码中，变量名为 value，类型为 int ，分配 4 字节的内存（不同编译器会有差异）。</p>
<p>1.3 区分定义和声明</p>
<p>通常变量的定义和声明是同时发生的，注意：<strong>extern 变量类型 变量名</strong> 仅是声明。</p>
<p>二、函数的声明和定义</p>
<p>2.1 函数声明</p>
<p>函数的声明是通知编译器函数名称、参数数量和类型以及函数返回类型，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>；</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，函数名为 Max，返回类型为 int 、参数为 int x，int y</p>
<p>2.2 函数定义</p>
<p>函数的定义是为函数分配内存，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt; y ? x : y； &#125;</span><br></pre></td></tr></table></figure>
<p>函数定义包含了函数的具体实现。</p>
<p>2.3 函数声明和定义区分</p>
<p>函数只要有实现（存在函数体 { …… } ）即为定义，否则为声明。可以这样理解：函数声明是说明函数是什么，函数定义是说明函数做什么。</p>
<p>三、声明和定义的区别</p>
<p><strong>3.1 声明可多次，定义只一次</strong></p>
<p>变量/函数可以声明多次，变量/函数的定义只能一次。</p>
<p><strong>3.2 分配内存</strong></p>
<p>声明不会分配内存，定义会分配内存。</p>
<p><strong>3.3 做了什么</strong></p>
<p>声明是告诉编译器变量或函数的类型和名称等，定义是告诉编译器变量的值，函数具体干什么。</p>
<h4 id="33、C-从代码到可执行二进制文件的过程">33、C++ 从代码到可执行二进制文件的过程</h4>
<p>C++ 和 C 语言类似，一个 C++ 程序从源码到执行文件，有四个过程，<strong>预编译、编译、汇编、链接</strong>。</p>
<p><strong>解析：</strong></p>
<ol>
<li>
<p>预编译：这个过程主要的处理操作如下：</p>
<p>（1） 将所有的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">#</mi><mi>d</mi><mi>e</mi><mi>f</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">\#define</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">#</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">in</span><span class="mord mathnormal">e</span></span></span></span> 删除，并且展开所有的宏定义</p>
<p>（2） 处理所有的条件预编译指令，如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">#</mi><mi>i</mi><mi>f</mi><mtext>、</mtext><mi mathvariant="normal">#</mi><mi>i</mi><mi>f</mi><mi>d</mi><mi>e</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">\#if、\#ifdef</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">#</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord cjk_fallback">、</span><span class="mord">#</span><span class="mord mathnormal">i</span><span class="mord mathnormal">fd</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></p>
<p>（3） 处理 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">#</mi><mi>i</mi><mi>n</mi><mi>c</mi><mi>l</mi><mi>u</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">\# include</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">#</span><span class="mord mathnormal">in</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span></span></span></span> 预编译指令，将被包含的文件插入到该预编译指令的位置。</p>
<p>（4） 过滤所有的注释</p>
<p>（5） 添加行号和文件名标识。</p>
</li>
<li>
<p>编译：这个过程主要的处理操作如下：</p>
<p>（1） 词法分析：将源代码的字符序列分割成一系列的记号。</p>
<p>（2） 语法分析：对记号进行语法分析，产生语法树。</p>
<p>（3） 语义分析：判断表达式是否有意义。</p>
<p>（4） 代码优化：</p>
<p>（5） 目标代码生成：生成汇编代码。</p>
<p>（6） 目标代码优化：</p>
</li>
<li>
<p>汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。</p>
</li>
<li>
<p>链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。</p>
<p>链接分为静态链接和动态链接。</p>
<p><strong>静态链接</strong>，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows 下以. lib 为后缀，Linux 下以. a 为后缀。</p>
<p><strong>动态链接</strong>，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows 下以. dll 为后缀，Linux 下以. so 为后缀。</p>
</li>
</ol>
<h3 id="语言基础">语言基础</h3>
<h4 id="简述下-C-语言的特点">简述下 C++ 语言的特点</h4>
<p>面向对象，三大特性（封装、继承、多态），更安全，复用性高</p>
<ol>
<li>C++ 在 C 语言基础上引入了<strong>面对对象</strong>的机制，同时也<strong>兼容 C 语言</strong>。</li>
<li>C++ 有三大特性（1）<code>封装</code>。（2）<code>继承</code>。（3）<code>多态</code>；</li>
<li>C++ 语言编写出的程序结构清晰、易于扩充，程序<strong>可读性好</strong>。</li>
<li>C++ 生成的代码<strong>质量高</strong>，运行<strong>效率高</strong>，仅比汇编语言慢 10%～20%；</li>
<li>C++ 更加安全，增加了 const 常量、引用、四类 cast 转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try—catch 等等；</li>
<li>C++ <strong>可复用性</strong>高，C++ 引入了<strong>模板</strong>的概念，后面在此基础上，实现了方便开发的标准模板库 STL（Standard Template Library）。</li>
<li>同时，C++ 是<strong>不断在发展</strong>的语言。C++ 后续版本更是发展了不少新特性，如 C++11 中引入了 nullptr、auto 变量、Lambda 匿名函数、右值引用、智能指针。</li>
</ol>
<h4 id="C-语言和-C-的区别">C 语言和 C++ 的区别</h4>
<ol>
<li>C 语言是 C++ 的子集，C++ 可以很好兼容 C 语言。但是 C++ 又有很多<strong>新特性</strong>，如引用、智能指针、auto 变量等。</li>
<li>C++ 是<strong>面向对象</strong>的编程语言；C 语言是<strong>面向过程</strong>的编程语言。</li>
<li>C 语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而 C++ 对此增加了不少新特性来<strong>改善安全性</strong>，如 const 常量、引用、cast 转换、智能指针、try—catch 等等；</li>
<li>C++ <strong>可复用性</strong>高，C++ 引入了<strong>模板</strong>的概念，后面在此基础上，实现了方便开发的标准模板库 STL。C++ 的 STL 库相对于 C 语言的函数库<strong>更灵活、更通用</strong>。</li>
</ol>
<h4 id="C-中-struct-和-class-的区别">C++ 中 struct 和 class 的区别</h4>
<ul>
<li>默认的访问、继承权限</li>
<li>定义模板参数</li>
</ul>
<ol>
<li>
<p>struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装；</p>
</li>
<li>
<p><strong>struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的</strong>，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> iNum;    <span class="comment">// 默认访问控制权限是 public</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> iNum;    <span class="comment">// 默认访问控制权限是 private</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在继承关系中，<strong>struct 默认是公有继承，而 class 是私有继承</strong>；</p>
</li>
<li>
<p><strong>class 关键字可以用于定义模板参数，就像 typename</strong>，而 struct 不能用于定义模板参数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Y&gt;    <span class="comment">// 可以把typename 换成 class </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> T&amp; t, <span class="keyword">const</span> Y&amp; y)</span> </span>&#123; </span><br><span class="line">	<span class="comment">//TODO </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="include-头文件的顺序以及双引号-“”-和尖括号-的区别">include 头文件的顺序以及双引号 “” 和尖括号 &lt;&gt; 的区别</h4>
<ol>
<li>
<p>区别：</p>
<p>（1）尖括号 &lt;&gt; 的头文件是<strong>系统文件</strong>，双引号 “” 的头文件是<strong>自定义文件</strong>。</p>
<p>（2）编译器预处理阶段查找头文件的路径不一样。</p>
</li>
<li>
<p>查找路径：</p>
<p>（1）使用尖括号 &lt;&gt; 的头文件的查找路径：编译器设置的头文件路径 --&gt; 系统变量。</p>
<p>（2）使用双引号 “” 的头文件的查找路径：<strong>当前头文件目录</strong> --&gt; 编译器设置的头文件路径 --&gt; 系统变量。</p>
</li>
</ol>
<h4 id="C-结构体和-C-结构体的区别">C++ 结构体和 C 结构体的区别</h4>
<ol>
<li>
<p>C 的结构体内不允许有函数存在，C++ 允许有内部成员函数，且允许该函数是虚函数。</p>
</li>
<li>
<p>C 的结构体对内部成员变量的访问权限只能是 public，而 C++ 允许 public,protected,private 三种。</p>
</li>
<li>
<p>C 语言的结构体是不可以继承的，C++ 的结构体是可以从其他的结构体或者类继承过来的。</p>
</li>
<li>
<p>C++ 中的 struct 是对 C 中的 struct 进行了扩充，它们在声明时的区别如下：</p>
<table><thead><tr><th align="left"></th><th align="center">C</th><th align="center">C++</th></tr></thead><tbody><tr><td align="left">成员函数</td><td align="center">不能有</td><td align="center">可以</td></tr><tr><td align="left">静态成员</td><td align="center">不能有</td><td align="center">可以</td></tr><tr><td align="left">访问控制</td><td align="center">默认public，不能修改</td><td align="center">public/private/protected</td></tr><tr><td align="left">继承关系</td><td align="center">不可以继承</td><td align="center">可从类或者其他结构体继承</td></tr><tr><td align="left">初始化</td><td align="center">不能直接初始化数据成员</td><td align="center">可以</td></tr></tbody></table>
</li>
<li>
<p>使用时的区别：C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  iAgeNum;</span><br><span class="line">    string strName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">Student2</span>;</span>    <span class="comment">//C中取别名</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>;</span>    <span class="comment">// C 中正常使用</span></span><br><span class="line">Student2 stu2;            <span class="comment">// C 中通过取别名的使用</span></span><br><span class="line"></span><br><span class="line">Student stu3;            <span class="comment">// C++ 中使用</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="导入-C-函数的关键字是什么，C-编译时和-C-有什么不同？">导入 C 函数的关键字是什么，C++ 编译时和 C 有什么不同？</h4>
<ol>
<li>
<p><strong>关键字：</strong> 在 C++ 中，导入 C 函数的关键字是 <strong>extern</strong>，表达形式为 <strong>extern “C”</strong>， extern “C” 的主要作用就是为了能够正确实现 C++ 代码调用其他 C 语言代码。加上 extern “C” 后，会指示编译器这部分代码按 <strong>C 语言</strong>的进行编译，而不是 C++ 的。</p>
</li>
<li>
<p><strong>编译区别：</strong> 由于 C++ 支持函数重载，因此编译器编译函数的过程中会将函数的<strong>参数类型</strong>也加到编译后的代码中，而不仅仅是<strong>函数名</strong>；而 <strong>C 语言并不支持函数重载</strong>，因此编译 C 语言代码的函数时不会带上函数的参数类型，一般只包括<strong>函数名</strong>。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//extern示例</span></span><br><span class="line"><span class="comment">//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在C++程序里边声明该函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span><span class="comment">//string.h里边包含了要调用的C函数的声明</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两种不同的语言，有着不同的编译规则，比如一个函数fun，可能C语言编译的时候为_fun，而C++则是__fun__</span></span><br></pre></td></tr></table></figure>
<h4 id="C-从代码到可执行二进制文件的过程">C++ 从代码到可执行二进制文件的过程</h4>
<p>C++ 和 C 语言类似，一个 C++ 程序从源码到执行文件，有四个过程，<strong>预编译、编译、汇编、链接</strong>。</p>
<p><strong>解析：</strong></p>
<ol>
<li>
<p>预编译：这个过程主要的处理操作如下：</p>
<p>（1） 将所有的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">#</mi><mi>d</mi><mi>e</mi><mi>f</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">\#define</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">#</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">in</span><span class="mord mathnormal">e</span></span></span></span> 删除，并且展开所有的宏定义</p>
<p>（2） 处理所有的条件预编译指令，如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">#</mi><mi>i</mi><mi>f</mi><mtext>、</mtext><mi mathvariant="normal">#</mi><mi>i</mi><mi>f</mi><mi>d</mi><mi>e</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">\#if、\#ifdef</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">#</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord cjk_fallback">、</span><span class="mord">#</span><span class="mord mathnormal">i</span><span class="mord mathnormal">fd</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></p>
<p>（3） 处理 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">#</mi><mi>i</mi><mi>n</mi><mi>c</mi><mi>l</mi><mi>u</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">\# include</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">#</span><span class="mord mathnormal">in</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span></span></span></span> 预编译指令，将被包含的文件插入到该预编译指令的位置。</p>
<p>（4） 过滤所有的注释</p>
<p>（5） 添加行号和文件名标识。</p>
</li>
<li>
<p>编译：这个过程主要的处理操作如下：</p>
<p>（1） 词法分析：将源代码的字符序列分割成一系列的记号。</p>
<p>（2） 语法分析：对记号进行语法分析，产生语法树。</p>
<p>（3） 语义分析：判断表达式是否有意义。</p>
<p>（4） 代码优化：</p>
<p>（5） 目标代码生成：生成汇编代码。</p>
<p>（6） 目标代码优化：</p>
</li>
<li>
<p>汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。</p>
</li>
<li>
<p>链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。</p>
<p>链接分为静态链接和动态链接。</p>
<p><strong>静态链接</strong>，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows 下以. lib 为后缀，Linux 下以 . a 为后缀。</p>
</li>
</ol>
<p><strong>动态链接</strong>，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows 下以 .dll 为后缀，Linux 下以 .so 为后缀。</p>
<h4 id="static-关键字的作用">static 关键字的作用</h4>
<p>（1）内存只分配一次，维护前值：函数体内static变量的作用范围为该函数体，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；<br>
（2）本源文件范围：在模块内的static全局变量和函数可以被模块内的函数访问，但不能被模块外其它函数访问；<br>
（3）类中只有一份，全类共有：在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；<br>
（4）无this,不能访问非静态成员：在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量，不能访问非静态成员。</p>
<ol>
<li>
<p><strong>定义全局静态变量和局部静态变量</strong>：在变量前面加上 static 关键字。初始化的静态变量会在数据段分配内存，未初始化的静态变量会在 BSS 段分配内存。直到程序结束，静态变量始终会维持前值。只不过全局静态变量和局部静态变量的作用域不一样；</p>
</li>
<li>
<p><strong>定义静态函数</strong>：在函数返回类型前加上 static 关键字，函数即被定义为静态函数。静态函数只能在<strong>本源文件</strong>中使用；</p>
</li>
<li>
<p>在变量类型前加上 static 关键字，变量即被定义为静态变量。<strong>静态变量只能在本源文件中使用</strong>；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 c++ 中，<strong>static 关键字可以用于定义类中的静态成员变量</strong>：使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的 static 静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都<strong>共享</strong>这一块静态存储空间。</p>
</li>
<li>
<p>在 c++ 中，<strong>static 关键字可以用于定义类中的静态成员函数</strong>：与静态成员变量类似，类里面同样可以定义静态成员函数。只需要在函数前加上关键字 static 即可。如静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据成员都<strong>共享</strong>这一块静态存储空间。</p>
</li>
</ol>
<p><strong>为什么静态成员函数不能访问非静态成员？</strong></p>
<p>当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的 this 指针。<strong>而静态成员函数不属于任何一个对象，因此 C++ 规定静态成员函数没有 this 指针</strong>。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。</p>
<h4 id="数组和指针的区别">数组和指针的区别</h4>
<ol>
<li>
<p>概念：</p>
<p>（1）数组：数组是用于储存多个相同类型数据的集合。数组名是首元素的地址。</p>
<p>（2）指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在<strong>内存中的地址</strong>。指针名指向了内存的首地址。</p>
</li>
<li>
<p>区别：</p>
<p>（1）<strong>赋值</strong>：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝</p>
<p>（2）<strong>存储方式</strong>：</p>
<p>数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下标进行访问的，数组的存储空间，不是在静态区就是在栈上。</p>
<p>指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。</p>
<p>（3）<strong>求 sizeof</strong>：</p>
<p>整个数组占用内存大小：sizeof（数组名）</p>
<p>数组中元素个数：sizeof（数组名）/ sizeof（数据类型）</p>
<p>在 32 位平台下，无论指针的类型是什么，sizeof（指针名）都是 4，在 64 位平台下，无论指针的类型是什么，sizeof（指针名）都是 8。</p>
<p>（4）<strong>初始化</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> b[] = <span class="string">&quot;Hello&quot;</span>;    <span class="comment">// 按字符串初始化，大小为6</span></span><br><span class="line"><span class="keyword">char</span> c[] = &#123; <span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;\0&#x27;</span> &#125;;    <span class="comment">// 按字符初始化</span></span><br><span class="line"><span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];    <span class="comment">// 动态创建一维数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="comment">// 指向对象的指针</span></span><br><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="comment">// 指向数组的指针</span></span><br><span class="line"><span class="keyword">int</span>* p1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] p1;</span><br><span class="line"><span class="comment">// 指向类的指针：</span></span><br><span class="line">string* p2 = <span class="keyword">new</span> string;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line"><span class="comment">// 指向指针的指针（二级指针）</span></span><br><span class="line"><span class="keyword">int</span>** pp = &amp;p;</span><br><span class="line">**pp = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>（5）指针操作：</p>
<p>数组名的指针操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];  </span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">4</span>];  <span class="comment">//该语句是定义一个数组指针，指向含4个元素的一维数组</span></span><br><span class="line">p = a;        <span class="comment">//将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0]</span></span><br><span class="line">p++;          <span class="comment">//该语句执行过后，也就是p=p+1；p跨过行a[0][]指向了行a[1][]</span></span><br><span class="line">              <span class="comment">//所以数组指针也称指向一维数组的指针，亦称行指针。</span></span><br><span class="line"><span class="comment">//访问数组中第i行j列的一个元素，有几种操作方式：</span></span><br><span class="line"><span class="comment">//*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]。其中，优先级：()&gt;[]&gt;*。</span></span><br><span class="line"><span class="comment">//这几种操作方式都是合法的。</span></span><br></pre></td></tr></table></figure>
<p>指针变量的数据操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">char</span> *str = <span class="string">&quot;hello,douya!&quot;</span>;</span><br><span class="line">   str[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">*(str+<span class="number">2</span>) = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="comment">//这两种操作方式都是合法的。</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="什么是函数指针，如何定义函数指针，有什么使用场景">什么是函数指针，如何定义函数指针，有什么使用场景</h4>
<ol>
<li>
<p><strong>概念：</strong> 函数指针就是<strong>指向函数</strong>的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。</p>
</li>
<li>
<p><strong>定义</strong>形式如下：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>;  </span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*f)(<span class="keyword">int</span> a);  </span><br><span class="line">f = &amp;func;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>函数指针的<strong>应用场景</strong>：<strong>回调</strong>（callback）。我们调用别人提供的 API 函数 (Application Programming Interface, 应用程序编程接口)，称为 Call；如果别人的库里面调用我们的函数，就叫 Callback。</li>
</ol>
<p><strong>解析：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以库函数qsort排序函数为例，它的原型如下：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base,<span class="comment">//void*类型，代表原始数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">size_t</span> nmemb, <span class="comment">//第二个是size_t类型，代表数据数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">size_t</span> size, <span class="comment">//第三个是size_t类型，代表单个数据占用空间大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">int</span>(*compar)(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *)<span class="comment">//第四个参数是函数指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">          )</span></span>;</span><br><span class="line"><span class="comment">//第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp_int</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* _a , <span class="keyword">const</span> <span class="keyword">void</span>* _b)</span></span>&#123;<span class="comment">//参数格式固定</span></span><br><span class="line">    <span class="keyword">int</span> *a = (<span class="keyword">int</span>*)_a;    <span class="comment">//强制类型转换</span></span><br><span class="line">    <span class="keyword">int</span> *b = (<span class="keyword">int</span>*)_b;</span><br><span class="line">    <span class="keyword">return</span> *a - *b;　　</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">qsort</span>(num,<span class="number">100</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(num[<span class="number">0</span>]),cmp_int); <span class="comment">//回调</span></span><br></pre></td></tr></table></figure>
<h4 id="静态变量什么时候初始化？">静态变量什么时候初始化？</h4>
<p><font color = "red">C 语言：全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。</font></p>
<p><font color = 'red'>C++ 标准：全局或静态对象当且仅当对象首次用到时才进行构造。</font></p>
<p><strong>解析：</strong></p>
<ol>
<li>
<p><strong>作用域</strong>：C++ 里作用域可分为 6 种：全局，局部，类，语句，命名空间和文件作用域。</p>
<p>静态全局变量 ：全局作用域 + 文件作用域，所以无法在其他文件中使用。</p>
<p>静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。</p>
<p>类静态成员变量：类作用域。</p>
</li>
<li>
<p><strong>所在空间</strong>：都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。</p>
</li>
<li>
<p><strong>生命周期</strong>：静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存。</p>
</li>
</ol>
<h4 id="nullptr-调用成员函数可以吗？为什么？">nullptr 调用成员函数可以吗？为什么？</h4>
<p>能。</p>
<p>原因：因为在<strong>编译时对象</strong>就绑定了<strong>函数地址</strong>，和指针空不空没关系。</p>
<p><strong>解析：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给出实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;animal sleep&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">breathe</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;animal breathe haha&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fish</span> :</span><span class="keyword">public</span> animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">breathe</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;fish bubble&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    animal *pAn=<span class="literal">nullptr</span>;</span><br><span class="line">    pAn-&gt;<span class="built_in">breathe</span>();   <span class="comment">// 输出：animal breathe haha</span></span><br><span class="line">    fish *pFish = <span class="literal">nullptr</span>;</span><br><span class="line">    pFish-&gt;<span class="built_in">breathe</span>(); <span class="comment">// 输出：fish bubble</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因：因为在<strong>编译时对象</strong>就绑定了<strong>函数地址</strong>，和指针空不空没关系。pAn-&gt;breathe(); 编译的时候，函数的地址就和指针 pAn 绑定了；调用 breathe(*this), this 就等于 pAn。由于函数中没有需要解引用 this 的地方，所以函数运行不会出错，但是若用到 this，因为 this=nullptr，运行出错。</p>
<h4 id="什么是野指针，怎么产生的，如何避免？">什么是野指针，怎么产生的，如何避免？</h4>
<ol>
<li>
<p><strong>概念：</strong> 野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）</p>
</li>
<li>
<p><strong>产生原因</strong>：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。</p>
</li>
<li>
<p><strong>避免办法：</strong></p>
<p>（1）初始化置 NULL</p>
<p>（2）申请内存后判空</p>
<p>（3）指针释放后置 NULL</p>
<p>（4）使用智能指针</p>
</li>
</ol>
<p><strong>解析：</strong></p>
<p><strong>产生原因</strong>：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>)*<span class="number">100</span>);  </span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;Douya&quot;</span>);  </span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//p所指向的内存被释放，但是p所指的地址仍然不变  </span></span><br><span class="line">...  </span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)&#123;<span class="comment">//没有起到防错作用  </span></span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;hello, Douya!&quot;</span>);<span class="comment">//出错  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>避免办法：</strong></p>
<p>（1）初始化置 NULL</p>
<p>（2）申请内存后判空</p>
<p>（3）指针释放后置 NULL</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*n); <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line">p = (<span class="keyword">int</span> *) <span class="built_in">realloc</span>(p, <span class="number">25</span>);<span class="comment">//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址</span></span><br><span class="line"><span class="built_in">free</span>(p);  </span><br><span class="line">p = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p1 = (<span class="keyword">int</span> *)<span class="built_in">calloc</span>(n, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)); <span class="comment">//申请n个int内存空间同时初始化为0 </span></span><br><span class="line"><span class="built_in">assert</span>(p1 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="built_in">free</span>(p1);  </span><br><span class="line">p1 = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p2 = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p2 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="keyword">delete</span> []p2;  </span><br><span class="line">p2 = <span class="literal">nullptr</span>; <span class="comment">//释放后置空</span></span><br></pre></td></tr></table></figure>
<h4 id="静态局部变量，全局变量，局部变量的特点，以及使用场景">静态局部变量，全局变量，局部变量的特点，以及使用场景</h4>
<ol>
<li>
<p><strong>首先从作用域考虑</strong>：C++ 里作用域可分为 6 种：全局，局部，类，语句，命名空间和文件作用域。</p>
<p>全局变量：全局作用域，可以通过 extern 作用于其他非定义的源文件。</p>
<p>静态全局变量 ：全局作用域 + 文件作用域，所以无法在其他文件中使用。</p>
<p>局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。</p>
<p>静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。</p>
</li>
<li>
<p><strong>从所在空间考虑</strong>：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。</p>
</li>
<li>
<p><font color='red'>生命周期</font>： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。</p>
</li>
<li>
<p><strong>使用场景</strong>：从它们各自特点就可以看出各自的应用场景，不再赘述。</p>
</li>
</ol>
<h4 id="内联函数和宏函数的区别-2">内联函数和宏函数的区别</h4>
<p>区别：</p>
<ol>
<li><strong>宏定义不是函数</strong>，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；<strong>而内联函数本质上是一个函数</strong>，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。</li>
<li><strong>宏函数</strong>是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；<strong>而内联函数</strong>则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率</li>
<li><strong>宏定义</strong>是没有类型检查的，无论对还是错都是直接替换；<strong>而内联函数</strong>在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等</li>
</ol>
<p><strong>解析：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="built_in">MAX</span>(a,<span class="string">&quot;Hello&quot;</span>)； <span class="comment">//错误地比较int和字符串，没有参数类型检查</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内联函数示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+b=%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上a = add(1, 2);处在编译时将被展开为：a = (a + b);</span></span><br></pre></td></tr></table></figure>
<p><strong>1、使用时的一些注意事项：</strong></p>
<ul>
<li>使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性</li>
<li>inline 函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字 inline，即可将函数指定为 inline 函数。</li>
<li>同其它函数不同的是，最好将 inline 函数定义在头文件，而不仅仅是声明，因为编译器在处理 inline 函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。</li>
</ul>
<p><strong>2、内联函数使用的条件：</strong></p>
<ul>
<li>内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：</li>
<li>（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。</li>
<li>（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</li>
<li>内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。</li>
</ul>
<h4 id="运算符-i-和-i-的区别">运算符 i++ 和 ++i 的区别</h4>
<p><strong>先看到实现代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">    j += i++; <span class="comment">//先赋值后加</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i= %d, j= %d\n&quot;</span>,i, j); <span class="comment">//i= 3, j= 4</span></span><br><span class="line">    i = <span class="number">2</span>;</span><br><span class="line">    j = <span class="number">2</span>;</span><br><span class="line">    j += ++i; <span class="comment">//先加后赋值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i= %d, j= %d&quot;</span>,i, j); <span class="comment">//i= 3, j= 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><strong>赋值顺序不同</strong>：++ i 是先加后赋值；i ++ 是先赋值后加；++i 和 i++ 都是分两步完成的。</p>
</li>
<li>
<p><strong>效率不同</strong>：后置 ++ 执行速度比前置的慢。</p>
</li>
<li>
<p><strong>i++ 不能作为左值，而 ++i 可以</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;(++i);<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> *p2 = &amp;(i++);<span class="comment">//错误</span></span><br><span class="line">++i = <span class="number">1</span>; <span class="comment">//正确</span></span><br><span class="line">i++ = <span class="number">1</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>两者都不是原子操作。</p>
</li>
</ol>
<h4 id="new-和-malloc-的区别，各自底层实现原理。">new 和 malloc 的区别，各自底层实现原理。</h4>
<p>在使用的时候 <code>new</code>、<code>delete</code> 搭配使用，<code>malloc</code>、<code>free</code> 搭配使用。</p>
<ul>
<li><code>malloc</code>、<code>free</code> 是库函数，而<code>new</code>、<code>delete</code> 是关键字。<br>
-<code>new</code> 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；<code>malloc</code> 在申请空间时，需要确定所申请空间的大小。</li>
<li><code>new</code> 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；<code>malloc</code> 申请空间时，返回的是 <code>void*</code> 类型，需要进行强制类型的转换，转换为对象类型的指针。</li>
<li><code>new</code> 分配失败时，会抛出 <code>bad_alloc</code> 异常，<code>malloc</code> 分配失败时返回空指针。</li>
<li>对于自定义的类型，<code>new</code> 首先调用 <code>operator new()</code> 函数申请空间（底层通过 <code>malloc</code> 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；<code>delete</code> 首先调用析构函数，然后调用 <code>operator delete()</code> 释放空间（底层通过 <code>free</code> 实现）。<code>malloc</code>、<code>free</code> 无法进行自定义类型的对象的构造和析构。</li>
<li><code>new</code> 操作符从自由存储区上为对象动态分配内存，而 <code>malloc</code> 函数从堆上动态分配内存。（自由存储区不等于堆）</li>
</ul>
<ol>
<li>new 是操作符，而 malloc 是函数。</li>
<li>new 在调用的时候先分配内存，再调用构造函数，释放的时候调用析构函数；而 malloc 没有构造函数和析构函数。</li>
<li>malloc 需要给定申请内存的大小，返回的指针需要强转；new 会调用构造函数，不用指定内存的大小，返回指针不用强转。</li>
<li>new 可以被重载；malloc 不行</li>
<li>new 分配内存更直接和安全。</li>
<li>new 发生错误抛出异常，malloc 返回 null</li>
</ol>
<p><strong>解析：</strong></p>
<p><strong>malloc 底层实现：</strong> 当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用 mmap（）。malloc 采用的是内存池的管理方式，以减少内存碎片。Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。</p>
<p>当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。</p>
<p><strong>new 底层实现：</strong>  关键字 new 在调用构造函数的时候实际上进行了如下的几个步骤：</p>
<ol>
<li>创建一个新的对象</li>
<li>将构造函数的作用域赋值给这个新的对象（因此 this 指向了这个新的对象）</li>
<li>执行构造函数中的代码（为这个新对象添加属性）</li>
<li>返回新对象</li>
</ol>
<h4 id="const-和-define-的区别。">const 和 define 的区别。</h4>
<p>const 用于定义常量；而 define 用于定义宏，而宏也可以用于定义常量。都用于常量定义时，它们的区别有：</p>
<ol>
<li>const 生效于编译的阶段；define 生效于预处理阶段。</li>
<li>const 定义的常量，在 C 语言中是存储在内存中、需要额外的内存空间的；define 定义的常量，运行时是直接的操作数，并不会存放在内存中。</li>
<li>const 定义的常量是带类型的；define 定义的常量不带类型。因此 define 定义的常量不利于类型检查。</li>
</ol>
<h4 id="C-中函数指针和指针函数的区别。">C++中函数指针和指针函数的区别。</h4>
<ol>
<li>
<p><strong>定义不同</strong><br>
指针函数本质是一个函数，其返回值为指针。<br>
函数指针本质是一个指针，其指向一个函数。</p>
</li>
<li>
<p><strong>写法不同</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指针函数：<span class="function"><span class="keyword">int</span> *<span class="title">fun</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">函数指针：<span class="built_in"><span class="keyword">int</span></span> (*fun)(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>用法不同</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针函数示例</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Data</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">&#125;Data;</span><br><span class="line"><span class="comment">//指针函数</span></span><br><span class="line"><span class="function">Data *<span class="title">f</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	Data *data = <span class="keyword">new</span> Data;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//调用指针函数</span></span><br><span class="line">	Data *myData = <span class="built_in">f</span>(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">	<span class="comment">//Data *myData = static_cast&lt;Data*&gt;(f(4,5));</span></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数指针示例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数指针</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*fun)(<span class="keyword">int</span> x,<span class="keyword">int</span> y); </span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">fun = add;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;(*fun)(1,2) = &quot;</span> &lt;&lt; (*fun)(<span class="number">1</span>,<span class="number">2</span>) ;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//(*fun)(1,2) =  3</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="const-int-a-int-const-a-const-int-a-int-const-a-const-int-const-a分别是什么，有什么特点。">const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;     <span class="comment">//指的是a是一个常量，不允许修改。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a;    <span class="comment">//a指针所指向的内存里的值不变，即（*a）不变</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *a;    <span class="comment">//同const int *a;</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> a;    <span class="comment">//a指针所指向的内存地址不变，即a不变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> a;   <span class="comment">//都不变，即（*a）不变，a也不变</span></span><br></pre></td></tr></table></figure>
<h4 id="使用指针需要注意什么？">使用指针需要注意什么？</h4>
<ol>
<li>定义指针时，先初始化为NULL。</li>
<li>用malloc或new申请内存之后，应该<strong>立即检查</strong>指针值是否为NULL。防止使用指针值为NULL的内存。</li>
<li>不要忘记为数组和动态内存<strong>赋初值</strong>。防止将未被初始化的内存作为右值使用。</li>
<li>避免数字或指针的下标<strong>越界</strong>，特别要当心发生“多1”或者“少1”操作</li>
<li>动态内存的申请与释放必须配对，防止<strong>内存泄漏</strong></li>
<li>用free或delete释放了内存之后，立即将指针<strong>设置为NULL</strong>，防止“野指针”</li>
</ol>
<p><strong>解析：</strong></p>
<p>（1）初始化置NULL</p>
<p>（2）申请内存后判空</p>
<p>（3）指针释放后置NULL</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*n); <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line">p = (<span class="keyword">int</span> *) <span class="built_in">realloc</span>(p, <span class="number">25</span>);<span class="comment">//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址</span></span><br><span class="line"><span class="built_in">free</span>(p);  </span><br><span class="line">p = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p1 = (<span class="keyword">int</span> *)<span class="built_in">calloc</span>(n, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)); <span class="comment">//申请n个int内存空间同时初始化为0 </span></span><br><span class="line"><span class="built_in">assert</span>(p1 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="built_in">free</span>(p1);  </span><br><span class="line">p1 = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p2 = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p2 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="keyword">delete</span> []p2;  </span><br><span class="line">p2 = <span class="literal">nullptr</span>; <span class="comment">//释放后置空  </span></span><br></pre></td></tr></table></figure>
<h4 id="内联函数和函数的区别，内联函数的作用。-2">内联函数和函数的区别，内联函数的作用。</h4>
<ol>
<li>内联函数比普通函数多了关键字<strong>inline</strong></li>
<li>内联函数避免了函数调用的<strong>开销</strong>；普通函数有调用的开销</li>
<li>普通函数在被调用的时候，需要<strong>寻址（函数入口地址）</strong>；内联函数不需要寻址。</li>
<li>内联函数有一定的限制，内联函数体要求<strong>代码简单</strong>，不能包含复杂的结构控制语句；普通函数没有这个要求。</li>
</ol>
<p><strong>内联函数的作用</strong>：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。</p>
<p><strong>解析：</strong></p>
<p>在使用内联函数时，应注意如下几点：</p>
<ol>
<li>
<p>在内联函数内不允许用循环语句和开关语句。</p>
<p>如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。</p>
</li>
<li>
<p>内联函数的定义必须出现在内联函数第一次被调用之前。</p>
</li>
</ol>
<h4 id="C-有几种传值方式，之间的区别是什么？">C++有几种传值方式，之间的区别是什么？</h4>
<p>传参方式有这三种：<strong>值传递、引用传递、指针传递</strong></p>
<ol>
<li>
<p>值传递：形参即使在函数体内值发生变化，也不会影响实参的值；</p>
</li>
<li>
<p>引用传递：形参在函数体内值发生变化，会影响实参的值；</p>
</li>
<li>
<p>指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；</p>
</li>
</ol>
<p><strong>解析：</strong></p>
<p>值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。</p>
<p>代码示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testfunc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> *b, <span class="keyword">int</span> &amp;c)</span></span>&#123;<span class="comment">//形参a值发生了改变，但是没有影响实参i的值；但形参*b、c的值发生了改变，影响到了实参*j、k的值</span></span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line">    (*b) += <span class="number">1</span>;</span><br><span class="line">    c += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a= %d, b= %d, c= %d\n&quot;</span>,a,*b,c);<span class="comment">//a= 2, b= 2, c= 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *j = &amp;a;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">testfunc</span>(i, j, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i= %d, j= %d, k= %d\n&quot;</span>,i,*j,k);<span class="comment">//i= 1, j= 2, k= 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="const（星号）和（星号）const的区别">const（星号）和（星号）const的区别</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const* 是常量指针，*const 是指针常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *a;    <span class="comment">//a指针所指向的内存里的值不变，即（*a）不变</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> a;    <span class="comment">//a指针所指向的内存地址不变，即a不变</span></span><br></pre></td></tr></table></figure>
<h3 id="C-内存">C++内存</h3>
<h4 id="C-程序编译过程">C++ 程序编译过程</h4>
<p>编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接。</p>
<ul>
<li>
<p><strong>编译预处理</strong>：处理以 # 开头的指令；</p>
</li>
<li>
<p><strong>编译、优化</strong>：将源码 .cpp 文件翻译成 .s 汇编代码；</p>
</li>
<li>
<p><strong>汇编</strong>：将汇编代码 .s 翻译成机器指令 .o 文件；</p>
</li>
<li>
<p><strong>链接</strong>：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/1612676946-HVvkdR-image.png" alt="image.png" style="zoom:67%;" />
</li>
</ul>
<p>链接分为两种：</p>
<ul>
<li><strong>静态链接</strong>：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</li>
<li><strong>动态链接</strong>：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</li>
</ul>
<p>二者的优缺点：</p>
<ul>
<li>静态链接：<strong>浪费空间</strong>，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（<strong>更新困难</strong>）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。</li>
<li>动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。</li>
</ul>
<h4 id="全局变量、局部变量、静态全局变量、静态局部变量的区别">全局变量、局部变量、静态全局变量、静态局部变量的区别</h4>
<p>C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。</p>
<p>从作用域看：</p>
<ul>
<li><strong>全局变量</strong>：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用 <code>extern</code> 关键字再次声明这个全局变量。</li>
<li><strong>静态全局变量</strong>：具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 <code>static</code> 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</li>
<li><strong>局部变量</strong>：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</li>
<li><strong>静态局部变量</strong>：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。</li>
</ul>
<p>从分配内存空间看：</p>
<ul>
<li>静态存储区：全局变量，静态局部变量，静态全局变量。</li>
<li>栈：局部变量。</li>
</ul>
<p>说明：</p>
<ul>
<li>静态变量和栈变量（存储在栈中的变量）、堆变量（存储在堆中的变量）的区别：静态变量会被放在程序的静态数据存储区（.data 段）中（静态变量会自动初始化），这样可以在下一次调用的时候还可以保持原来的赋值。而栈变量或堆变量不能保证在下一次调用的时候依然保持原来的值。</li>
<li>静态变量和全局变量的区别：静态变量用 <code>static</code> 告知编译器，自己仅仅在变量的作用范围内可见。</li>
</ul>
<h4 id="全局变量定义在头文件中有什么问题？">全局变量定义在头文件中有什么问题？</h4>
<p>如果在头文件中定义全局变量，当该头文件被多个文件 <code>include</code> 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能头文件中定义全局变量。</p>
<h4 id="简述一下堆和栈的区别">简述一下堆和栈的区别</h4>
<ul>
<li>申请方式：栈是系统自动分配，堆是程序员主动申请。</li>
<li>申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，<strong>否则分配失败栈溢出</strong>；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。</li>
<li>栈在内存中是连续的一块空间（向低地址扩展），最大容量是系统预定好的；堆在内存中的空间（向高地址扩展）是不连续的。</li>
<li>申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用方便但是容易产生碎片。</li>
<li>存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。</li>
</ul>
<ol>
<li><strong>堆栈空间分配不同</strong>。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。</li>
<li><strong>堆栈缓存方式不同</strong>。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。</li>
<li><strong>堆栈数据结构不同</strong>。堆类似数组结构；栈类似栈结构，先进后出。</li>
</ol>
<h4 id="C-的内存管理">C++的内存管理</h4>
<p><a target="_blank" rel="noopener" href="http://chenqx.github.io/2014/09/25/Cpp-Memory-Management/">C/C++内存管理详解 | ShinChan’s Blog (chenqx.github.io)</a></p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203112121258.png" alt="image-20211118095816959" style="zoom: 67%;" />
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202112131243545.png" style="zoom: 67%;" />
<ol>
<li>
<p><strong>内存分配方式</strong>：</p>
<p>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。</p>
<p><strong>栈</strong>，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。</p>
<p><strong>堆</strong>，就是那些由malloc等分配的内存块，和自由存储区是十分相似的，不过是用free来结束自己的生命。</p>
<p><strong>全局/静态存储区(数据段)</strong>，全局变量和静态变量被分配到同一块内存中</p>
<p><strong>常量存储区（代码段）</strong>，这是一块比较特殊的存储区，里面存放的是常量，不允许修改。</p>
<p>（<strong>自由存储区</strong>，就是那些由new分配的内存块，一般一个new就要对应一个delete。）</p>
</li>
<li>
<p><strong>常见的内存错误及其对策</strong>：</p>
<p>（1）分配失败：内存分配未成功，却使用了它。</p>
<p>（2）未初始化：内存分配虽然成功，但是尚未初始化就引用它。</p>
<p>（3）访问越界：内存分配成功并且已经初始化，但操作越过了内存的边界。</p>
<p>（4）忘记释放：忘记了释放内存，造成内存泄露。</p>
<p>（5）释放还使用：释放了内存却继续使用它。</p>
<p>对策：</p>
<p>（1）定义指针时，先初始化为 NULL。</p>
<p>（2）用malloc或new申请内存之后，应该<strong>立即检查</strong>指针值是否为NULL。防止使用指针值为NULL的内存。</p>
<p>（3）不要忘记为数组和动态内存<strong>赋初值</strong>。防止将未被初始化的内存作为右值使用。</p>
<p>（4）避免数字或指针的下标<strong>越界</strong>，特别要当心发生“多1”或者“少1”操作</p>
<p>（5）动态内存的申请与释放必须配对，防止<strong>内存泄漏</strong></p>
<p>（6）用free或delete释放了内存之后，立即将指针<strong>设置为NULL</strong>，防止“野指针”</p>
<p>（7）使用智能指针。</p>
</li>
<li>
<p><strong>内存泄露及解决办法</strong>：</p>
<p><strong>什么是内存泄露？</strong></p>
<p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。</p>
<p><strong>怎么检测？</strong></p>
<p>第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕, 要记得使用其相应的函数释放掉。</p>
<p>第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。</p>
<p>第三：使用智能指针。</p>
<p>第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。</p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202112131236456.png" style="zoom: 67%;" />
<p><strong>内存模型（内存布局）：</strong></p>
<p>如上图，<strong>从低地址到高地址，一个程序由代码段、数据段、</strong> <strong>BSS</strong> <strong>段组成。</strong></p>
<ol>
<li>
<p><strong>代码区：</strong> 存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。</p>
</li>
<li>
<p><strong>全局区/静态区</strong></p>
<ol>
<li><strong>数据段：</strong> 存放程序中已初始化的全局变量和静态变量的一块内存区域。</li>
<li><strong>BSS</strong> 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。</li>
</ol>
</li>
<li>
<p>可执行程序在运行时又会多出两个区域：堆区和栈区。</p>
<p><strong>堆区：</strong> 动态申请内存用。堆从低地址向高地址增长。</p>
<p><strong>栈区：</strong> 存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。</p>
</li>
<li>
<p>最后还有一个<strong>文件映射区</strong>，位于堆和栈之间。</p>
</li>
</ol>
<p><strong>堆 heap</strong> ：一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收 。分配方式类似于链表。</p>
<p><strong>栈 stack</strong> ：由编译器自动分配释放，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等。其操作方式类似于数据结构中的栈。</p>
<p><strong>常量存储区</strong> ：存放常量，不允许修改。</p>
<h4 id="malloc和局部变量分配在堆还是栈？">malloc和局部变量分配在堆还是栈？</h4>
<ul>
<li>
<p>malloc是在<strong>堆上分配内存</strong>，需要程序员自己回收内存，操作系统中有一个记录空闲内存地址的链表，当操作系统收到程序的申请时，就会遍历链表；</p>
</li>
<li>
<p>局部变量是在<strong>栈中分配内存</strong>，超过作用域就自动回收。</p>
</li>
</ul>
<h4 id="如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？">如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？</h4>
<p>说明：C++ 中的类的对象的建立分为两种：静态建立、动态建立。</p>
<ul>
<li>静态建立（栈上）：由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：<code>A a;</code></li>
<li>动态建立（堆上）：使用 <code>new</code> 关键字在堆空间上创建对象，底层首先调用 <code>operator new()</code> 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：<code>A *p = new A();</code></li>
</ul>
<ol>
<li>
<p>限制对象只能建立在堆上：</p>
<ul>
<li>
<p>最直观的思想：<strong>避免直接调用类的构造函数</strong>，因为对象静态建立时，会调用类的构造函数创建对象。</p>
<p>注意：但是直接将类的构造函数设为私有并不可行，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 <code>new</code> 来建立对象。但是由于 <code>new</code> 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 <code>new</code> 创建对象了。因此，这种方法不可行。</p>
</li>
<li>
<p>解决方法 1：</p>
<ul>
<li>
<p><strong>将析构函数设置为私有</strong>。</p>
</li>
<li>
<p>原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即<strong>编译器会检查析构函数的访问性</strong>。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该方法存在的问题：</p>
<ul>
<li>用 <code>new</code> 创建的对象，通常会使用 <code>delete</code> 释放该对象的内存空间，但此时类的外部无法调用析构函数，因此类内必须定义一个 <code>destory()</code> 函数，用来释放 <code>new</code> 创建的对象。</li>
<li>无法解决继承问题，因为如果这个类作为基类，析构函数要设置成 <code>virtual</code>，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>解决方法 2：</p>
<ul>
<li>
<p>构造函数设置为 <code>protected</code>，并提供一个 <code>public</code> 的静态函数来完成构造，而不是在类的外部使用 <code>new</code> 构造；</p>
</li>
<li>
<p>将析构函数设置为 <code>protected</code>。</p>
</li>
<li>
<p>原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 create() 函数在堆上创建对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> A *<span class="title">create</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">A</span>(); &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>限制对象只能建立在栈上：</p>
<ul>
<li>
<p>解决方法：将 <code>operator new()</code> 设置为私有。原因：当对象建立在堆上时，是采用 <code>new</code> 的方式进行建立，其底层会调用 <code>operator new()</code> 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> t)</span> </span>&#123;&#125;    <span class="comment">// 注意函数的第一个参数和返回值都是固定的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;&#125; <span class="comment">// 重载了 new 就需要重载 delete</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？">程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？</h4>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202112131226047.png" style="zoom: 67%;" />
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202112131243545.png" style="zoom: 67%;" />
<p><strong>一个程序有哪些section：</strong></p>
<ol>
<li>
<p><strong>代码区：</strong> 存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。</p>
</li>
<li>
<p><strong>全局区/静态区</strong></p>
<ol>
<li><strong>数据段：</strong> 存放程序中已初始化的全局变量和静态变量的一块内存区域。</li>
<li><strong>BSS</strong> 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。</li>
</ol>
</li>
<li>
<p>可执行程序在运行时又会多出两个区域：堆区和栈区。</p>
<p><strong>堆区：</strong> 动态申请内存用。堆从低地址向高地址增长。</p>
<p><strong>栈区：</strong> 存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。</p>
</li>
<li>
<p>最后还有一个<strong>文件映射区</strong>，位于堆和栈之间。</p>
</li>
</ol>
<p><strong>堆 heap</strong> ：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收 。分配方式类似于链表。</p>
<p><strong>栈 stack</strong> ：由编译器自动分配释放，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等。其操作方式类似于数据结构中的栈。</p>
<p><strong>常量存储区</strong> ：存放常量，不允许修改。</p>
<p><strong>程序启动的过程：</strong></p>
<ol>
<li>操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。</li>
<li>加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。</li>
<li>加载器针对该程序的每一个动态链接库调用LoadLibrary<br>
（1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。<br>
（2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。<br>
（3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3<br>
（4）调用该动态链接库的初始化函数</li>
<li>初始化应用程序的全局变量，对于全局对象自动调用构造函数。</li>
<li>进入应用程序入口点函数开始执行。</li>
</ol>
<p><strong>怎么判断数据分配在栈上还是堆上：</strong> 首先局部变量分配在栈上；而通过 malloc 和 new 申请的空间是在堆上。</p>
<h4 id="初始化为-0-的全局变量在-bss-还是-data">初始化为 0 的全局变量在 bss 还是 data</h4>
<p>在 BSS 段</p>
<p>BSS 段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清 0。</p>
<h4 id="什么是内存泄露，内存泄露怎么检测？">什么是内存泄露，内存泄露怎么检测？</h4>
<p><strong>什么是内存泄露？</strong></p>
<p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。</p>
<p>（1）new和malloc申请资源使用后，没有用delete和free释放；</p>
<p>（2）子类继承父类时，父类析构函数不是虚函数。</p>
<p>（3）Windows句柄资源使用后没有释放。</p>
<p><strong>怎么检测？</strong></p>
<p>第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。</p>
<p>第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。</p>
<p>第三：使用智能指针。</p>
<p>第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。</p>
<h4 id="请简述一下-atomoic-内存顺序。">请简述一下 atomoic 内存顺序。</h4>
<p>有六个内存顺序选项可应用于对原子类型的操作：</p>
<ol>
<li>
<p>memory_order_relaxed：在原子类型上的操作以自由序列执行，没有任何同步关系，仅对此操作要求原子性。</p>
</li>
<li>
<p>memory_order_consume：memory_order_consume只会对其标识的对象保证该对象存储先行于那些需要加载该对象的操作。</p>
</li>
<li>
<p>memory_order_acquire：使用memory_order_acquire的原子操作，当前线程的读写操作都不能重排到此操作之前。</p>
</li>
<li>
<p>memory_order_release：使用memory_order_release的原子操作，当前线程的读写操作都不能重排到此操作之后。</p>
</li>
<li>
<p>memory_order_acq_rel：memory_order_acq_rel在此内存顺序的读-改-写操作既是获得加载又是释放操作。没有操作能够从此操作之后被重排到此操作之前，也没有操作能够从此操作之前被重排到此操作之后。</p>
</li>
<li>
<p>memory_order_seq_cst：memory_order_seq_cst比std::memory_order_acq_rel更为严格。memory_order_seq_cst不仅是一个&quot;获取释放&quot;内存顺序，它还会对所有拥有此标签的内存操作建立一个单独全序。</p>
</li>
</ol>
<p>除非你为特定的操作指定一个顺序选项，否则内存顺序选项对于所有原子类型默认都是 memory_order_seq_cst。</p>
<h4 id="简述C-中内存对齐的使用场景">简述C++中内存对齐的使用场景</h4>
<p>内存对齐应用于三种数据类型中：<strong>struct/class/union</strong></p>
<p>struct/class/union内存对齐原则有四个：</p>
<ol>
<li>
<p>数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在 offset 为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。</p>
</li>
<li>
<p>结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部&quot;最宽基本类型成员&quot;的整数倍地址开始存储。(struct a 里存有 struct b , b 里有 char , int , double 等元素,那b应该从8的整数倍开始存储)。</p>
</li>
<li>
<p>收尾工作: 结构体的总大小，也就是 sizeof 的结果，<strong>必须是其内部最大成员的&quot;最宽基本类型成员&quot;的整数倍</strong>。不足的要补齐。(基本类型不包括struct/class/uinon)。</p>
</li>
<li>
<p>sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。</p>
</li>
</ol>
<p><strong>解析：</strong></p>
<ol>
<li>
<p><strong>什么是内存对齐？</strong></p>
<p>那么什么是字节对齐？在C语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构体、联合体等）的数据单元。在结构体中，<strong>编译器为结构体的每个成员按其自然边界（alignment）分配空间。</strong> 各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同。</p>
<p>为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，<strong>即所谓的“对齐”，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除</strong>，也即“对齐”跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。</p>
<p>比如在32位cpu下，假设一个整型变量的地址为0x00000004(为4的倍数)，那它就是自然对齐的，而如果其地址为0x00000002（非4的倍数）则是非对齐的。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p>
</li>
<li>
<p><strong>为什么要字节对齐？</strong></p>
<p>需要字节对齐的<strong>根本原因在于 CPU 访问数据的效率问题</strong>。对齐后一次访存，非对齐需要两次访存。</p>
<p>假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。</p>
<p>而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果<strong>取未对齐的数据会发生错误</strong>，而在x86上就不会出现错误，只是效率下降。</p>
<p>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。</p>
</li>
<li>
<p><strong>字节对齐实例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">example</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];  </span><br><span class="line">    <span class="keyword">char</span> b;  </span><br><span class="line">    <span class="keyword">double</span> c;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">int</span> result = <span class="built_in"><span class="keyword">sizeof</span></span>(example);  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果以最长20字节为准，内部double占8字节，这段内存的地址0x00000020并不是double的整数倍，只有当最小为0x00000024时可以满足整除double（8Byte）同时又可以容纳int a[5]的大小，所以正确的结果应该是result=24</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];  </span><br><span class="line">    <span class="keyword">char</span> b;  </span><br><span class="line">    <span class="keyword">double</span> c;  </span><br><span class="line">&#125;test_struct;</span><br><span class="line"><span class="keyword">int</span> result = <span class="built_in"><span class="keyword">sizeof</span></span>(test_struct);  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果我们不考虑字节对齐，那么内存地址0x0021不是double（8Byte）的整数倍，所以需要字节对齐，那么此时满足是double（8Byte）的整数倍的最小整数是0x0024，说明此时char b对齐int扩充了三个字节。所以最后的结果是result=32</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">example</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">char</span> b;  </span><br><span class="line">    <span class="keyword">double</span> c;  </span><br><span class="line">    <span class="keyword">int</span> a;  </span><br><span class="line">&#125;test_struct;  </span><br><span class="line"><span class="keyword">int</span> result = <span class="built_in"><span class="keyword">sizeof</span></span>(test_struct);  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，那就是占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍，所以20不是double（8Byte）的整数倍，我们还要扩充四个字节，最后的结果是result=24</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？-2">什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？</h4>
<p>内存对齐：<strong>编译器将程序中的每个“数据单元”安排在字的整数倍的地址指向的内存之中</strong></p>
<p>内存对齐的原则：</p>
<ol>
<li>结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；</li>
<li>结构体每个成员相对于结构体首地址的偏移量 （offset） 都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）；</li>
<li>结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）。</li>
</ol>
<p>进行内存对齐的原因：（主要是硬件设备方面的问题）</p>
<ol>
<li>某些硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常；</li>
<li>某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作；</li>
<li>相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间；</li>
<li>某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignment trap）；</li>
<li>某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。</li>
</ol>
<p>内存对齐的优点：</p>
<ol>
<li><strong>便于在不同的平台之间进行移植</strong>，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；</li>
<li><strong>提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取</strong>。</li>
</ol>
<h4 id="malloc-和-new-区别">malloc 和 new 区别</h4>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202112131255734.png" style="zoom: 67%;" />
<ol>
<li>malloc/free 是标准库函数；new/delete 是C++运算符</li>
<li>malloc 失败返回空；new 失败抛异常</li>
<li>new/delete 会调用构造、析构函数；malloc/free不会，所以他们无法满足动态对象的要求。</li>
<li>new返回有类型的指针；malloc返回无类型的指针</li>
</ol>
<p>更多理解：</p>
<ol>
<li>
<p>分配内存的位置<br>
malloc 是从堆上动态分配内存，new 是从自由存储区为对象动态分配内存。<br>
自由存储区的位置取决于 operator new 的实现。自由存储区不仅可以为堆，还可以是静态存储区，这都看 operator new 在哪里为对象分配内存。</p>
</li>
<li>
<p>返回类型安全性<br>
malloc 内存分配成功后返回 void*，然后再强制类型转换为需要的类型；new 操作符分配内存成功后返回与对象类型相匹配的指针类型；因此 new 是符合类型安全的操作符。</p>
</li>
<li>
<p>内存分配失败返回值<br>
malloc 内存分配失败后返回 NULL；<br>
new 分配内存失败则会抛异常（bac_alloc）。</p>
</li>
<li>
<p>分配内存的大小的计算<br>
使用 new 操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而 malloc 则需要显式地指出所需内存的尺寸。</p>
</li>
<li>
<p>是否调用构造函数/析构函数<br>
使用new操作符来分配对象内存时会经历三个步骤：</p>
<ul>
<li>第一步：调用 operator new 函数（对于数组是 operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。</li>
<li>第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。</li>
<li>第三步：对象构造完成后，返回一个指向该对象的指针。</li>
</ul>
<p>使用delete操作符来释放对象内存时会经历两个步骤：</p>
<ul>
<li>第一步：调用对象的析构函数。</li>
<li>第二步：编译器调用 operator delete(或operator delete[]) 函数释放内存空间。</li>
</ul>
<p>总之来说，new/delete 会调用对象的构造函数/析构函数以完成对象的构造/析构；而 malloc 则不会。</p>
</li>
<li>
<p>对数组的处理</p>
<p>C++ 提供了 new [] 和 delete [] 用来专门处理数组类型。它会调用构造函数初始化每一个数组元素，然后释放对象时它会为每个对象调用析构函数，但是二者一定要配套使用；至于 malloc，它并不知道你要在这块空间放置数组还是其他的东西，就只给一块原始的空间，再给一个内存地址就完事，如果要动态开辟一个数组的内存，还需要我们手动自定数组的大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A * ptr = <span class="keyword">new</span> A[<span class="number">10</span>];<span class="comment">//分配10个A对象</span></span><br><span class="line"><span class="keyword">delete</span> [] ptr;</span><br><span class="line"><span class="keyword">int</span> * ptr = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * <span class="number">10</span>);<span class="comment">//分配一个10个int元素的数组</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>new与malloc是否可以相互调用<br>
new/delete 的实现可以基于 malloc，而 malloc 的实现不可以去调用 new</p>
</li>
<li>
<p>是否可以被重载<br>
new/delete 可以被重载。而 malloc/free 则不能重载。</p>
</li>
<li>
<p>分配内存时内存不足<br>
malloc 动态分配内存后，如果不够用可以使用 realloc 函数重新分配实现内存的扩充；而 new 则没有这样的操作；</p>
</li>
</ol>
<h4 id="有了-malloc-free-为什么还要-new-delete">有了 malloc/free 为什么还要 new/delete?</h4>
<ol>
<li>new 运算不需要进行强制类型转换，使用简单方便；</li>
<li>new 运算是通过调用构造函数初始化动态创建的对象，执行效率更高；</li>
<li>使用 new 能够进行异常处理，使用更安全</li>
</ol>
<h4 id="类大小的计算">类大小的计算</h4>
<p>说明：类的大小是指类的实例化对象的大小，用 <code>sizeof</code> 对类型名操作时，结果是该类型的对象的大小。</p>
<p><strong>每个对象所占用的存储空间只是该对象的数据部分（虚函数指针和虚基类指针也属于数据部分）所占用的存储空间，而不包括函数代码所占用的存储空间</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203152102428.jpeg" alt="img" style="zoom:50%;" />
<p>计算原则：</p>
<ul>
<li>遵循结构体的对齐原则。</li>
<li><strong>与普通成员变量有关，与成员函数和静态成员无关</strong>。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响。因为静态数据成员被类的对象共享，并不属于哪个具体的对象。</li>
<li><strong>虚函数对类的大小有影响，是因为虚函数表指针的影响</strong>。</li>
<li><strong>虚继承对类的大小有影响，是因为虚基表指针带来的影响</strong>。</li>
<li>空类的大小是一个特殊情况，<strong>空类的大小为 1</strong>，当用 <code>new</code> 来创建一个空类的对象时，<strong>为了保证不同对象的地址不同（用于区分对象）</strong>，空类也占用存储空间。</li>
</ul>
<h4 id="什么是内存泄露">什么是内存泄露</h4>
<p><strong>内存泄漏</strong>：<strong>由于疏忽或错误导致的程序未能释放已经不再使用的内存</strong>。</p>
<p>进一步解释：</p>
<ul>
<li>并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。</li>
<li>常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。</li>
</ul>
<ol>
<li>
<p>使用 <code>malloc</code>、<code>calloc</code>、<code>realloc</code>、<code>new</code> 等分配内存时，使用完后要调用相应的 <code>free</code> 或 <code>delete</code> 释放内存，否则这块内存就会造成内存泄漏。</p>
</li>
<li>
<p>指针重新赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">char</span> *p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">p = np;</span><br></pre></td></tr></table></figure>
<p>开始时，指针 <code>p</code> 和 <code>p1</code> 分别指向一块内存空间，但指针 <code>p</code> 被重新赋值，导致 <code>p</code> 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。</p>
</li>
</ol>
<p><strong>防止内存泄漏的方法：</strong></p>
<ol>
<li><strong>内部封装</strong>：<strong>将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存</strong>。</li>
<li><strong>智能指针</strong>：智能指针是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用</li>
</ol>
<h3 id="面向对象">面向对象</h3>
<h4 id="什么是面向对象">什么是面向对象</h4>
<p>面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。</p>
<p>任何东西看作一个对象进行封装：对象属性 + 操作属性的函数</p>
<ol>
<li>
<p>面向对象是一种编程思想，把一切东西看成是一个个对象，比如人、耳机、鼠标、水杯等，他们各自都有属性，比如：耳机是白色的，鼠标是黑色的，水杯是圆柱形的等等，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示</p>
</li>
<li>
<p>面向过程和面向对象的区别</p>
<p>面向过程：根据业务逻辑从上到下写代码</p>
<p>面向对象：<strong>将数据与函数绑定到一起，进行封装</strong>，这样能够更快速的开发程序，减少了重复代码的重写过程</p>
</li>
</ol>
<h4 id="面向对象的三大特征">面向对象的三大特征</h4>
<p><strong>封装、继承、多态</strong>。</p>
<ol>
<li>
<p>封装：<strong>将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互</strong>。</p>
<p>封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通 道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，不想给别人看到的，我们使用 protected/private 把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。</p>
</li>
<li>
<p>继承：<strong>可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</strong></p>
<p>三种继承方式</p>
<table>
<thead>
<tr>
<th style="text-align:center">继承方式</th>
<th style="text-align:center">private继承</th>
<th style="text-align:center">protected继承</th>
<th style="text-align:center">public继承</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">基类的private成员</td>
<td style="text-align:center">不可见</td>
<td style="text-align:center">不可见</td>
<td style="text-align:center">不可见</td>
</tr>
<tr>
<td style="text-align:center">基类的protected成员</td>
<td style="text-align:center">变为private成员</td>
<td style="text-align:center">仍为protected成员</td>
<td style="text-align:center">仍为protected成员</td>
</tr>
<tr>
<td style="text-align:center">基类的public成员</td>
<td style="text-align:center">变为private成员</td>
<td style="text-align:center">变为protected成员</td>
<td style="text-align:center">仍为public成员仍为public成员</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>多态：用基类的指针指向其派生类的实例，然后通过基类的指针调用实际派生类类的成员函数。</p>
<p>实现多态，有二种方式，重写，重载。</p>
</li>
</ol>
<h4 id="重载和重写，以及它们的区别">重载和重写，以及它们的区别</h4>
<ol>
<li>
<p>重写</p>
<p>是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。<strong>只有函数体不同（花括号内）</strong>，派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 virtual 修饰。</p>
<p>注意：协变的返回类型可以不同。协变是重写的特例，基类中返回值是基类类型的引用或指针，在派生类中，返回值为派生类类型的引用或指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    a-&gt;<span class="built_in">fun</span>();<span class="comment">//输出B，A类中的fun在B类中重写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重载</p>
<p>函数重载是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，<strong>根据参数列表确定调用哪个函数，重载不关心函数返回类型</strong>。</p>
<p>我们在平时写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double) 这些个类型。在 C 语言中我们是利用不同的函数名来加以区分。这样的代码不美观而且给程序猿也带来了很多的不便。于是在 C++ 中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="重载、重写、隐藏的区别-2">重载、重写、隐藏的区别</h4>
<p>重载：函数名相同，根据参数列表区分。同一个类内部。</p>
<p>重写（覆盖）：必须是虚函数，只有函数体不同，其他都相同（协变返回类型可以不同）</p>
<p>隐藏：函数名相同，其他可同可不同。不同类之间。</p>
<ul>
<li>
<p>重载：是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据<strong>参数列表</strong>确定调用哪个函数，重载不关心函数返回类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">float</span> tmp)</span></span>;        <span class="comment">// 重载 参数类型不同（相对于上一个函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp, <span class="keyword">float</span> tmp1)</span></span>; <span class="comment">// 重载 参数个数不同（相对于上一个函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">float</span> tmp, <span class="keyword">int</span> tmp1)</span></span>; <span class="comment">// 重载 参数顺序不同（相对于上一个函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span></span>;            <span class="comment">// error: &#x27;int A::fun(int)&#x27; cannot be overloaded 错误：注意重载不关心函数返回类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>隐藏：是<strong>指派生类的函数屏蔽了与其同名的基类函数，只要函数名相同，不管参数列表是否相同，基类函数都会被隐藏</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp, <span class="keyword">float</span> tmp1)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun(int tmp, float tmp1)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::fun(int tmp)&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 隐藏基类中的同名函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derive ex;</span><br><span class="line">    ex.<span class="built_in">fun</span>(<span class="number">1</span>);       <span class="comment">// Derive::fun(int tmp)</span></span><br><span class="line">    ex.<span class="built_in">fun</span>(<span class="number">1</span>, <span class="number">0.01</span>); <span class="comment">// error: candidate expects 1 argument, 2 provided</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：上述代码中 <code>ex.fun(1, 0.01);</code> 出现错误，说明派生类中将基类的同名函数隐藏了。若是想调用基类中的同名函数，可以加上类型名指明 <code>ex.Base::fun(1, 0.01);</code>，这样就可以调用基类中的同名函数。</p>
</li>
<li>
<p>重写(覆盖)：是指派生类中存在重新定义的函数。<strong>函数名、参数列表、返回值类型都必须同基类中被重写的函数一致</strong>，<strong>只有函数体不同</strong>。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 <code>virtual</code> 修饰。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; &#125; <span class="comment">// 重写基类中的 fun 函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    p-&gt;<span class="built_in">fun</span>(<span class="number">3</span>); <span class="comment">// Derived::fun(int) : 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>重写和重载的区别</strong>：</p>
<ul>
<li>范围区别：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间（子类和父类之间）。</li>
<li>参数区别：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 <code>virtual</code> 修饰。</li>
<li><code>virtual</code> 关键字：重写的函数基类中必须有 <code>virtual</code>关键字的修饰，重载的函数可以有 <code>virtual</code> 关键字的修饰也可以没有。</li>
</ul>
<p><strong>隐藏和重写，重载的区别</strong>：</p>
<ul>
<li>范围区别：隐藏与重载范围不同，隐藏发生在不同类中。</li>
<li>参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被 <code>virtual</code> 修饰，基类函数都是被隐藏，而不是重写。</li>
</ul>
<h4 id="C-的重载和重写是如何实现的-2">C++ 的重载和重写是如何实现的</h4>
<ol>
<li>
<p>C++ 利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在编译阶段完成的。</p>
<p>C++ 定义同名重载函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((a)+(b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((a)+(b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">float</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((a)+(b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在基类的函数前加上 virtual 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p>
<ol>
<li>用 virtual 关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。</li>
<li>存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。</li>
<li>多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。</li>
<li>重写用虚函数来实现，结合动态绑定。</li>
<li>纯虚函数是虚函数再加上 = 0。</li>
<li>抽象类是指包括至少一个纯虚函数的类。</li>
</ol>
<p>纯虚函数：virtual void fun()=0 。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。</p>
</li>
</ol>
<h4 id="C-语言如何实现-C-语言中的重载">C 语言如何实现 C++ 语言中的重载</h4>
<p>c 语言中不允许有同名函数，因为编译时函数命名是一样的，不像 c++ 会添加参数类型和返回类型作为函数编译后的名称，进而实现重载。如果要用 c 语言显现函数重载，可通过以下方式来实现：</p>
<ol>
<li>使用函数指针来实现，重载的函数不能使用同名称，只是类似的实现了函数重载功能</li>
<li>重载函数使用可变参数，方式如打开文件 open 函数</li>
<li>gcc 有内置函数，程序使用编译函数可以实现函数重载</li>
</ol>
<p>示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_int</span><span class="params">(<span class="keyword">void</span> * a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(<span class="keyword">int</span>*)a);  <span class="comment">//输出int类型，注意 void * 转化为int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_double</span><span class="params">(<span class="keyword">void</span> * b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,*(<span class="keyword">double</span>*)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ptr)</span><span class="params">(<span class="keyword">void</span> *)</span></span>;  <span class="comment">//typedef申明一个函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">c_func</span><span class="params">(ptr p,<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">     <span class="built_in">p</span>(param);                <span class="comment">//调用对应函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">23</span>;</span><br><span class="line">    <span class="keyword">double</span> b = <span class="number">23.23</span>;</span><br><span class="line">    <span class="built_in">c_func</span>(func_int,&amp;a);</span><br><span class="line">    <span class="built_in">c_func</span>(func_double,&amp;b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造函数有几种，分别什么作用">构造函数有几种，分别什么作用</h4>
<p>C++ 中的构造函数可以分为 4 类：默认构造函数、一般（重载）构造函数、拷贝构造函数、移动构造函数。</p>
<ol>
<li>
<p>默认构造函数和一般（重载）构造函数。 在定义类的对象的时候，完成对象的初始化工作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//默认构造函数</span></span><br><span class="line">  <span class="built_in">Student</span>() &#123;</span><br><span class="line">    num = <span class="number">1001</span>;</span><br><span class="line">    age = <span class="number">18</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//初始化构造函数</span></span><br><span class="line">  <span class="built_in">Student</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> a) : <span class="built_in">num</span>(n), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//用默认构造函数初始化对象S1</span></span><br><span class="line">  Student s1;</span><br><span class="line">  <span class="comment">//用初始化构造函数初始化对象S2</span></span><br><span class="line">  <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">1002</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了自定义的构造了，编译器就不提供默认的构造函数。</p>
</li>
<li>
<p>拷贝构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span>* p;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test</span>(<span class="keyword">int</span> ai, <span class="keyword">int</span> value) &#123;</span><br><span class="line">    i = ai;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Test</span>() &#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line">  <span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;i = t.i;</span><br><span class="line">    <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*t.p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//复制构造函数用于复制本类的对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;  <span class="comment">//将对象t1复制给t2。注意复制和赋值的概念不同</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拷贝构造函数默认实现的是值拷贝（浅拷贝）。如果类外面有这样一个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HasPtr <span class="title">f</span><span class="params">(HasPtr hp)</span> </span>&#123;</span><br><span class="line">    HasPtr ret = hp;</span><br><span class="line">    <span class="comment">///... 其他操作</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>当函数执行完了之后，将会调用 hp 和 ret 的析构函数，将 hp 和 ret 的成员 ps 给 delete 掉，但是由于 ret 和 hp 指向了同一个对象，因此该对象的 ps 成员被 delete 了两次，这样产生一个未定义的错误，所以说，如果一个类定义了析构函数，那么它要定义自己的拷贝构造函数和默认构造函数。</p>
</li>
<li>
<p>移动构造函数。用于将其他类型的变量，隐式转换为本类对象。下面的转换构造函数，将 int 类型的 r 转换为 Student 类型的对象，对象的 age 为 r，num 为 1004.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Student</span>(<span class="keyword">int</span> r) &#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">1004</span>;</span><br><span class="line">  <span class="keyword">int</span> age = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="只定义析构函数，会自动生成哪些构造函数">只定义析构函数，会自动生成哪些构造函数</h4>
<p><strong>只定义了析构函数，编译器将自动为我们生成默认构造函数和拷贝构造函数、拷贝赋值运算符。</strong></p>
<p><strong>注意：需要析构函数的类也需要拷贝和赋值操作，因为默认生成的拷贝和赋值操作是浅拷贝，易照成错误（如指针浅拷贝，重复释放同一块内存的错误)</strong></p>
<ol>
<li>
<p>默认构造函数和初始化构造函数。<br>
在定义类的对象的时候，完成对象的初始化工作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Student</span>() &#123;  <span class="comment">//默认构造函数</span></span><br><span class="line">    num = <span class="number">1001</span>;</span><br><span class="line">    age = <span class="number">18</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Student</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> a) : <span class="built_in">num</span>(n), <span class="built_in">age</span>(a) &#123;&#125;  <span class="comment">//初始化构造函数</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Student s1;            <span class="comment">//用默认构造函数初始化对象S1</span></span><br><span class="line">  <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">1002</span>, <span class="number">18</span>)</span></span>;  <span class="comment">//用初始化构造函数初始化对象S2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了有参的构造了，编译器就不提供默认的构造函数。</p>
</li>
<li>
<p>拷贝构造函数、拷贝赋值运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span>* p;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test</span>(<span class="keyword">int</span> ai, <span class="keyword">int</span> value) &#123;</span><br><span class="line">    i = ai;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Test</span>() &#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line">  <span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;i = t.i;</span><br><span class="line">    <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*t.p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//复制构造函数用于复制本类的对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;  <span class="comment">//将对象t1复制给t2。注意复制和赋值的概念不同。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拷贝构造函数默认实现的是值拷贝（浅拷贝）。<br>
如果类外面有这样一个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HasPtr <span class="title">f</span><span class="params">(HasPtr hp)</span> </span>&#123;</span><br><span class="line">    HasPtr ret = hp;</span><br><span class="line">    <span class="comment">///... 其他操作</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>当函数执行完了之后，将会调用 hp 和 ret 的析构函数，将 hp 和 ret 的成员 ps 给 delete 掉，但是由于 ret 和 hp 指向了同一个对象，因此该对象的 ps 成员被 delete 了两次，这样产生一个未定义的错误，所以说，如果一个类定义了析构函数，那么它要定义自己的拷贝构造函数和默认构造函数。</p>
</li>
</ol>
<h4 id="一个类默认会生成哪些函数">一个类默认会生成哪些函数</h4>
<p>定义一个空类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>默认会生成以下几个函数</p>
<ol>
<li>
<p>默认构造函数</p>
<p>在定义类的对象的时候，完成对象的初始化工作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Empty</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>拷贝构造函数</p>
<p>拷贝构造函数用于复制本类的对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Empty</span>(<span class="keyword">const</span> Empty&amp; copy) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>拷贝赋值运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Empty&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Empty&amp; copy) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>析构函数（非虚）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Empty</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="C-类对象的初始化顺序，有多重继承情况下的顺序">C++ 类对象的初始化顺序，有多重继承情况下的顺序</h4>
<ol>
<li>
<p>创建派生类的对象，基类的构造函数优先被调用（也优先于派生类里的成员类）；</p>
</li>
<li>
<p>如果类里面有成员类，成员类的构造函数优先被调用；(也优先于该类本身的构造函数）</p>
</li>
<li>
<p>基类构造函数如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序而不是它们在成员初始化表中的顺序；</p>
</li>
<li>
<p>成员类对象构造函数如果有多个成员类对象，则构造函数的调用顺序是对象在类中被声明的顺序而不是它们出现在成员初始化表中的顺序；</p>
</li>
<li>
<p>派生类构造函数，作为一般规则派生类构造函数应该不能直接向一个基类数据成员赋值而是把值传递给适当的基类构造函数,否则两个类的实现变成紧耦合的（tightly coupled）将更加难于正确地修改或扩展基类的实现。（基类设计者的责任是提供一组适当的基类构造函数）</p>
</li>
<li>
<p>综上可以得出，初始化顺序：</p>
<p><strong>父类构造函数–&gt;成员类对象构造函数–&gt;自身构造函数</strong></p>
<p>其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序。</p>
<p>析构顺序和构造顺序相反。</p>
</li>
</ol>
<h4 id="向上转型和向下转型">向上转型和向下转型</h4>
<ol>
<li>
<p>子类转换为父类：向上转型，这种转换相对来说比较安全不会有数据的丢失；</p>
</li>
<li>
<p>父类转换为子类：向下转型，可以使用强制转换，这种转换是不安全的，会导致数据的丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存。</p>
</li>
</ol>
<h4 id="深拷贝和浅拷贝，如何实现深拷贝">深拷贝和浅拷贝，如何实现深拷贝</h4>
<ol>
<li>
<p>浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。</p>
</li>
<li>
<p>深拷贝：拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置。即每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。</p>
</li>
<li>
<p>深拷贝的实现：深拷贝的拷贝构造函数和赋值运算符的重载传统实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">STRING</span>(<span class="keyword">const</span> STRING&amp; s) &#123;</span><br><span class="line">  <span class="comment">//_str = s._str;</span></span><br><span class="line">  _str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s._str) + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">strcpy_s</span>(_str, <span class="built_in">strlen</span>(s._str) + <span class="number">1</span>, s._str);</span><br><span class="line">&#125;</span><br><span class="line">STRING&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> STRING&amp; s) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s) &#123;</span><br><span class="line">    <span class="comment">// this-&gt;_str = s._str;</span></span><br><span class="line">    <span class="keyword">delete</span>[] _str;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s._str) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy_s</span>(<span class="keyword">this</span>-&gt;_str, <span class="built_in">strlen</span>(s._str) + <span class="number">1</span>, s._str);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的拷贝构造函数我们很容易理解，先开辟出和源对象一样大的内存区域，然后将需要拷贝的数据复制到目标拷贝对象 ， 那么这里的赋值运算符的重载是怎么样做的呢？</p>
<p>这种方法解决了我们的指针悬挂问题，通过不断的开空间让不同的指针指向不同的内存，以防止同一块内存被释放两次的问题。</p>
</li>
</ol>
<h4 id="C-中的多态">C++ 中的多态</h4>
<p>派生类重写基类方法，然后用基类引用指向派生类对象，调用方法时候会进行动态绑定，这就是多态。</p>
<p>多态分为静态多态和动态多态：</p>
<ol>
<li>
<p>静态多态：重载。编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。</p>
</li>
<li>
<p>动态多态：重写。其实要实现动态多态，需要几个条件——即动态绑定条件：</p>
<ol>
<li>虚函数。基类中必须有虚函数，在派生类中必须重写虚函数。</li>
<li>通过基类类型的指针或引用来调用虚函数。</li>
</ol>
<p>说到这，得插播一条概念：重写——也就是基类中有一个虚函数，而在派生类中也要重写一个原型（返回值、名字、参数）都相同的虚函数。不过协变例外。协变是重写的特例，基类中返回值是基类类型的引用或指针，在派生类中，返回值为派生类类型的引用或指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//协变测试函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Base* <span class="title">FunTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;victory&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Derived* <span class="title">FunTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;yeah&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Base b;</span><br><span class="line">  Derived d;</span><br><span class="line"></span><br><span class="line">  b.<span class="built_in">FunTest</span>(); <span class="comment">// victory</span></span><br><span class="line">  d.<span class="built_in">FunTest</span>(); <span class="comment">// yeah</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="为什么要虚析构，为什么不能虚构造">为什么要虚析构，为什么不能虚构造</h4>
<ol>
<li>
<p>虚析构：将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们 new 一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生来无法被析构。</p>
<ol>
<li>用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构</li>
<li><strong>用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏</strong>。为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。</li>
</ol>
<p><strong>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存</strong>。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此 C++ 默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
</li>
<li>
<p>不能虚构造：</p>
<ol>
<li>存储空间的角度：构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。</li>
<li>实现角度：虚表指针是在创建对象之后才有的，因此构造函数不能定义成虚函数。创建对象需要调用构造函数，此时构造函数如果是虚函数，而虚函数的调用需要通过虚函数指针寻址才能调用，悖论；</li>
<li>使用角度：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用；构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用。</li>
<li>类型角度：在创建对象时需要明确其类型。<strong>构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数</strong>。</li>
</ol>
</li>
</ol>
<h4 id="模板类是在什么时候实现的">模板类是在什么时候实现的</h4>
<ol>
<li>
<p>模板实例化：</p>
<ul>
<li>显示实例化：研发人员明确的告诉模板应该使用什么样的类型去生成具体的类或函数</li>
<li>隐式实例化：在编译的过程中由编译器来决定使用什么类型来实例化一个模板</li>
<li>不管是显示实例化或隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的</li>
</ul>
</li>
<li>
<p>模板具体化：当模板使用某种类型类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化。具体化时可以修改原模板的定义，当使用该类型时，按照具体化后的定义实现，具体化相当于对某种类型进行特殊处理。</p>
</li>
<li>
<p>代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #1 模板定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TemplateStruct</span> &#123;</span></span><br><span class="line">  <span class="built_in">TemplateStruct</span>() &#123; cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(T) &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #2 模板显示实例化</span></span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">struct</span> <span class="title">TemplateStruct</span>&lt;</span><span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #3 模板具体化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TemplateStruct</span>&lt;</span><span class="keyword">double</span>&gt; &#123;</span><br><span class="line">  <span class="built_in">TemplateStruct</span>() &#123; cout &lt;&lt; <span class="string">&quot;--8--&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  TemplateStruct&lt;<span class="keyword">int</span>&gt; intStruct;</span><br><span class="line">  TemplateStruct&lt;<span class="keyword">double</span>&gt; doubleStruct;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// #4 模板隐式实例化</span></span><br><span class="line">  TemplateStruct&lt;<span class="keyword">char</span>&gt; llStruct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">--8--</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="类继承时，派生类对不同关键字修饰的基类方法的访问权限">类继承时，派生类对不同关键字修饰的基类方法的访问权限</h4>
<p>public:用该关键字修饰的成员表示公有成员，该成员不仅可以在类内可以被访问，在类外也是可以被访问的，是类对外提供的可访问接口，在派生类中可以被访问；</p>
<p>private:用该关键字修饰的成员表示私有成员，该成员仅在类内可以被访问，在类体外是隐藏状态，在派生类中也是隐藏的，在派生类中不可以被访问；</p>
<p>protected:用该关键字修饰的成员表示保护成员，保护成员在类体外同样是隐藏状态，但是对于该类的派生类来说，相当于公有成员，在派生类中可以被访问。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/image-20220222124023852.png" alt="image-20220222124023852"></p>
<p>类中的成员可以分为三种类型，分别为public成员、protected成员、public成员。类中可以直接访问自己类的public、protected、private成员，但类对象只能访问自己类的public成员。</p>
<table>
<thead>
<tr>
<th>基类成员权限</th>
<th style="text-align:center">public继承<br />派生类的成员及友元</th>
<th style="text-align:center">public继承<br />派生类对象</th>
<th style="text-align:center">protected继承<br />派生类的成员及友元</th>
<th style="text-align:center">protected继承<br />派生类对象</th>
<th style="text-align:center">private继承<br />派生类的成员及友元</th>
<th style="text-align:center">private继承<br />派生类对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td style="text-align:center">public</td>
<td style="text-align:center">public</td>
<td style="text-align:center">public</td>
<td style="text-align:center">protected，无法访问</td>
<td style="text-align:center">public</td>
<td style="text-align:center">private，无法访问</td>
</tr>
<tr>
<td>protected</td>
<td style="text-align:center">protected</td>
<td style="text-align:center">protected，无法访问</td>
<td style="text-align:center">protected</td>
<td style="text-align:center">protected，无法访问</td>
<td style="text-align:center">protected</td>
<td style="text-align:center">private，无法访问</td>
</tr>
<tr>
<td>private</td>
<td style="text-align:center">private，无法访问</td>
<td style="text-align:center">private，无法访问</td>
<td style="text-align:center">private，无法访问</td>
<td style="text-align:center">private，无法访问</td>
<td style="text-align:center">private，无法访问</td>
<td style="text-align:center">private，无法访问</td>
</tr>
</tbody>
</table>
<ol>
<li>public继承：
<ul>
<li>派生类可以访问基类的public、protected成员，不可以访问基类的private成员；</li>
<li>派生类对象可以访问基类的public成员，不可以访问基类的protected、private成员。</li>
</ul>
</li>
<li>protected继承：
<ul>
<li>派生类可以访问基类的public、protected成员，不可以访问基类的private成员；</li>
<li>派生类对象不可以访问基类的public、protected、private成员。</li>
</ul>
</li>
<li>private继承：
<ul>
<li>派生类可以访问基类的public、protected成员，不可以访问基类的private成员；</li>
<li>派生类对象不可以访问基类的public、protected、private成员。</li>
</ul>
</li>
</ol>
<h4 id="移动构造函数，什么库用到了这个函数？">移动构造函数，什么库用到了这个函数？</h4>
<p>C++11 中新增了移动构造函数。与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作。</p>
<p>移动操作的概念对对象管理它们使用的存储空间很有用的，诸如对象使用 new 和 delete 分配内存的时候。在这类对象中，拷贝和移动是不同的操作：从 A 拷贝到 B 意味着，B 分配了新内存，A 的整个内容被拷贝到为 B 分配的新内存上。而从 A 移动到 B 意味着分配给 A 的内存转移给了 B，没有分配新的内存，它仅仅包含简单地拷贝指针。</p>
<p>看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动构造函数和赋值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example6</span> &#123;</span></span><br><span class="line">  string* ptr;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Example6</span>(<span class="keyword">const</span> string&amp; str) : <span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">string</span>(str)) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">Example6</span>() &#123; <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line">  <span class="comment">// 移动构造函数，参数x不能是const Pointer&amp;&amp; x，</span></span><br><span class="line">  <span class="comment">// 因为要改变x的成员数据的值；</span></span><br><span class="line">  <span class="comment">// C++98不支持，C++0x（C++11）支持</span></span><br><span class="line">  <span class="built_in">Example6</span>(Example6&amp;&amp; x) : <span class="built_in">ptr</span>(x.ptr) &#123; x.ptr = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">  <span class="comment">// move assignment</span></span><br><span class="line">  Example6&amp; <span class="keyword">operator</span>=(Example6&amp;&amp; x) &#123;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    ptr = x.ptr;</span><br><span class="line">    x.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// access content:</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> string&amp; <span class="title">content</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">  <span class="comment">// addition:</span></span><br><span class="line">  Example6 <span class="keyword">operator</span>+(<span class="keyword">const</span> Example6&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Example6</span>(<span class="built_in">content</span>() + rhs.<span class="built_in">content</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Example6 <span class="title">foo</span><span class="params">(<span class="string">&quot;Exam&quot;</span>)</span></span>;  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="comment">// Example6 bar = Example6(&quot;ple&quot;); // 拷贝构造函数</span></span><br><span class="line">  <span class="function">Example6 <span class="title">bar</span><span class="params">(move(foo))</span></span>;  <span class="comment">// 移动构造函数</span></span><br><span class="line">                            <span class="comment">// 调用move之后，foo变为一个右值引用变量，</span></span><br><span class="line">                            <span class="comment">// 此时，foo所指向的字符串已经被&quot;掏空&quot;，</span></span><br><span class="line">                            <span class="comment">// 所以此时不能再调用foo</span></span><br><span class="line">  bar = bar + bar;  <span class="comment">// 移动赋值，在这儿&quot;=&quot;号右边的加法操作，</span></span><br><span class="line">                    <span class="comment">// 产生一个临时值，即一个右值</span></span><br><span class="line">                    <span class="comment">// 所以此时调用移动赋值语句</span></span><br><span class="line">  cout &lt;&lt; bar.<span class="built_in">content</span>() &lt;&lt; endl; <span class="comment">// ExamExam</span></span><br><span class="line">  cout &lt;&lt; foo.<span class="built_in">content</span>() &lt;&lt; endl; <span class="comment">// 出错，foo中的ptr已经被置空为nullptr</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-类内可以定义引用数据成员吗？">C++ 类内可以定义引用数据成员吗？</h4>
<p>c++类内可以定义引用成员变量，但要遵循以下三个规则：</p>
<ol>
<li>不能用默认构造函数初始化，<strong>必须提供构造函数来初始化引用成员变量</strong>。否则会造成引用未初始化错误。</li>
<li><strong>构造函数的形参也必须是引用类型</strong>。</li>
<li>不能在构造函数里初始化，<strong>必须在初始化列表中进行初始化</strong>。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">int</span> &amp;target) : <span class="built_in">a</span>(target) &#123; cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;a is:&quot;</span> &lt;&lt; a &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> &amp;a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">  <span class="function">A <span class="title">r</span><span class="params">(a)</span></span>;  <span class="comment">//依旧使用自定义的构造函数</span></span><br><span class="line">  r.<span class="built_in">printA</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> &amp;b = a;</span><br><span class="line">  <span class="function">A <span class="title">r1</span><span class="params">(b)</span></span>;</span><br><span class="line">  r1.<span class="built_in">printA</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造函数为什么不能被声明为虚函数？">构造函数为什么不能被声明为虚函数？</h4>
<ol>
<li>存储空间的角度：构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。</li>
<li>实现角度：虚表指针是在创建对象之后才有的，因此构造函数不能定义成虚函数。创建对象需要调用构造函数，此时构造函数如果是虚函数，而虚函数的调用需要通过虚函数指针寻址才能调用，悖论；</li>
<li>使用角度：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用；构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用。</li>
<li>类型角度：在创建对象时需要明确其类型。<strong>构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数</strong>。</li>
</ol>
<h4 id="什么是常函数，有什么作用">什么是常函数，有什么作用</h4>
<p><strong>类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变</strong>。</p>
<p><strong>常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数。</strong></p>
<p>在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加const，而对于改变数据成员的成员函数不能加 const。所以 const 关键字对成员函数的行为作了更明确的限定：有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。除此之外，在类的成员函数后面加 const 还有什么好处呢？<strong>那就是常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数</strong>。正如非const类型的数据可以给const类型的变量赋值一样，反之则不成立。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CStu</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="built_in">CStu</span>() &#123; a = <span class="number">12</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// a = 13; //常函数不能修改数据成员</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot;I am show()&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  CStu st;</span><br><span class="line">  st.<span class="built_in">Show</span>();</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="什么是虚继承，解决什么问题，如何实现？">什么是虚继承，解决什么问题，如何实现？</h4>
<p>虚继承是解决 C++ 多重继承问题的一种手段，<strong>从不同途径继承来的同一基类，会在子类中存在多份拷贝</strong>。</p>
<p>这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。虚继承可以解决多种继承前面提到的两个问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> _d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//菱形继承和菱形虚继承的对象模型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  D d;</span><br><span class="line">  d.B::_a = <span class="number">1</span>;</span><br><span class="line">  d.C::_a = <span class="number">2</span>;</span><br><span class="line">  d._b = <span class="number">3</span>;</span><br><span class="line">  d._c = <span class="number">4</span>;</span><br><span class="line">  d._d = <span class="number">5</span>;</span><br><span class="line">  cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(D) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别从菱形继承和虚继承来分析：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/1-2006291I602320.png" alt="菱形继承" style="zoom: 50%;" />
<p>菱形继承中 A 在 B,C,D 中各有一份，虚继承中，A共享。</p>
<p>上面的虚继承表实际上是一个指针数组。B、C 实际上是虚基表指针，指向虚基表。</p>
<p><strong>虚基表：存放相对偏移量，用来找虚基类</strong></p>
<h4 id="简述一下虚函数和纯虚函数，以及实现原理"><strong>简述一下虚函数和纯虚函数，以及实现原理</strong></h4>
<ol>
<li>
<p>C++中的<strong>虚函数的作用主要是实现了多态的机制</strong>。关于多态，简而言之就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。</p>
<ul>
<li>如果调用非虚函数，则无论实际对象是什么类型，都执行基类类型所定义的函数。非虚函数总是在编译时根据调用该函数的对象，引用或指针的类型而确定。</li>
<li>如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定或指针所指向的对象所属类型定义的版本。</li>
<li>虚函数必须是基类的非静态成员函数。虚函数的作用是实现动态联编，也就是在程序的运行阶段动态地选择合适的成员函数，在定义了虚函数后，可以在基类的派生类中对虚函数重新定义，在派生类中重新定义的函数应与虚函数具有相同的形参个数和形参类型。以实现统一的接口，不同定义过程。如果在派生类中没有对虚函数重新定义，则它继承其基类的虚函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//虚函数</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetName</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;PersonName:xiaosi&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetName</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;StudentName:xiaosi&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//指针</span></span><br><span class="line">  Person *person = <span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line">  <span class="comment">//基类调用子类的函数</span></span><br><span class="line">  person-&gt;<span class="built_in">GetName</span>();  <span class="comment">// StudentName:xiaosi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。</p>
</li>
<li>
<p><strong>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法</strong>。在基类中实现纯虚函数的方法是在函数原型后加 <code>=0</code> <code>virtual void GetName() = 0</code>。在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。为了解决上述问题，将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。同时<strong>含有纯虚拟函数的类称为抽象类，它不能生成对象</strong>。这样就很好地解决了上述两个问题。将函数定义为纯虚函数能够说明，该函数为后代类型提供了可以覆盖的接口，但是这个类中的函数绝不会调用。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。<strong>必须在继承类中重新声明函数（不要后面的＝0）否则该派生类也不能实例化，而且它们在抽象类中往往没有定义</strong>。定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//纯虚函数</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Student</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetName</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;StudentName:xiaosi&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; Student student; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？">纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？</h4>
<ol>
<li>
<p>纯虚函数不可以实例化，但是可以用其派生类实例化，示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;哈哈&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Base *b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">  b-&gt;<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>虚函数的原理采用 vtable。类中含有纯虚函数时，其 vtable 不完全，有个空位。</p>
<p><strong>即“纯虚函数在类的 vtable 表中对应的表项被赋值为 0。也就是指向一个不存在的函数</strong>。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。<strong>在它的派生类中，除非重写此函数，否则也不能生成对象</strong>。”</p>
<p>所以纯虚函数不能实例化。</p>
</li>
<li>
<p>纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。</p>
</li>
<li>
<p>定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p>
</li>
</ol>
<h4 id="C-中虚函数与纯虚函数的区别">C++中虚函数与纯虚函数的区别</h4>
<ol>
<li>
<p>虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。</p>
</li>
<li>
<p>虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。</p>
</li>
<li>
<p>虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。</p>
</li>
<li>
<p>虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。</p>
</li>
<li>
<p>虚函数的定义形式：<code>virtual&#123;&#125;</code>;纯虚函数的定义形式：<code>virtual &#123;&#125; = 0</code>; <strong>在虚函数和纯虚函数的定义中不能有static标识符</strong>，原因很简单，<strong>被static修饰的函数在编译时要求前期绑定, 然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样</strong>。</p>
</li>
</ol>
<p><strong>解析</strong></p>
<ol>
<li>
<p>我们举个虚函数的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::foo() is called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::foo() is called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  A *a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">  a-&gt;<span class="built_in">foo</span>();  <span class="comment">// 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子是虚函数的一个典型应用，通过这个例子，也许你就对虚函数有了一些概念。它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。<br>
<strong>虚函数只能借助于指针或者引用来达到多态的效果。</strong></p>
</li>
<li>
<p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”</p>
<p><code>virtual void funtion1()=0</code></p>
<p>为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。</p>
<p>在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。</p>
<p>为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：<code>virtual ReturnType Function()= 0;</code>），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。</p>
<p>声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。</p>
<p>纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。</p>
<p><strong>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。</strong></p>
<p>纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p>
</li>
</ol>
<h4 id="C-中什么是菱形继承问题，如何解决">C++ 中什么是菱形继承问题，如何解决</h4>
<ol>
<li>下面的图表可以用来解释菱形继承问题。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/C657A418177A4F4E2EC51FE4261953DD" style="zoom: 33%;" />
<ul>
<li>
<p>假设我们有类B和类C，它们都继承了相同的类A。另外我们还有类D，类D通过多重继承机制继承了类B和类C。因为上述图表的形状类似于菱形，因此这个问题被形象地称为菱形继承问题。现在，我们将上面的图表翻译成具体的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*Animal类对应于图表的类A*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span> <span class="comment">/* ... */</span>  &#125;; <span class="comment">// 基类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> weight;&#125;;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> :</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> :</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span>  &#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Liger</span> :</span> <span class="keyword">public</span> Tiger, <span class="keyword">public</span> Lion &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们给出了一个具体的菱形继承问题例子。Animal类对应于最顶层类（图表中的A），Tiger和Lion分别对应于图表的B和C，Liger类（狮虎兽，即老虎和狮子的杂交种)对应于D。</p>
<p>现在，问题是如果我们有这种继承结构会出现什么样的问题。</p>
<p>看看下面的代码后再来回答问题吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Liger lg ;</span><br><span class="line"><span class="comment">/*编译错误，下面的代码不会被任何C++编译器通过 */</span></span><br><span class="line"><span class="keyword">int</span> weight = lg.<span class="built_in">getWeight</span>();  </span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在我们的继承结构中，我们可以看出Tiger和Lion类都继承自Animal基类。所以问题是：因为Liger多重继承了Tiger和Lion类，因此Liger类会有两份Animal类的成员（数据和方法），Liger对象&quot;lg&quot;会包含Animal基类的两个子对象。</p>
<p>所以，你会问Liger对象有两个Animal基类的子对象会出现什么问题？再看看上面的代码-调用 <code>lg.getWeight()</code>将会导致一个编译错误。这是因为编译器并不知道是调用 Tiger 类的 <code>getWeight()</code> 还是调用 Lion 类的 <code>getWeight()</code> 。所以，调用 <code>getWeight</code> 方法是不明确的，因此不能通过编译。</p>
</li>
</ul>
<ol start="2">
<li>
<p>我们给出了菱形继承问题的解释，但是现在我们要给出一个菱形继承问题的解决方案。如果Lion类和Tiger类在分别继承Animal类时都用virtual来标注，对于每一个Liger对象，C++会保证只有一个Animal类的子对象会被创建。看看下面的代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>
<p>你可以看出唯一的变化就是我们在类Tiger和类Lion的声明中增加了&quot;virtual&quot;关键字。现在类Liger对象将会只有一个Animal子对象，下面的代码编译正常:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Liger lg ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*既然我们已经在Tiger和Lion类的定义中声明了&quot;virtual&quot;关键字，于是下面的代码编译OK */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> weight = lg.<span class="built_in">getWeight</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="构造函数中能不能调用虚方法">构造函数中能不能调用虚方法</h4>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203161058922.png" alt="image-20220316105809759"></p>
<p><strong>在构造或析构函数中调用虚函数会执行与之所属类型相对应的虚函数版本</strong></p>
<p>构造函数中调用虚函数,虚函数表现为该类中虚函数的行为，即在父类构造函数中调用虚函数，虚函数的表现就是父类定义的函数的表现</p>
<p>【09】绝不在构造和析构过程中调用virtual方法</p>
<p>1、原因很简单，对于前者，这种情况下，子类专有成分还没有构造，对于后者，子类专有成分已经销毁，因此调用的并不是子类重写的方法，这不是程序员所期望的。</p>
<p>2、在构造方法和析构方法中，直接调用virtual方法，很容易识别。还有一种情况要注意，那就是间接调用。比如：构造方法调用init方法，而init方法调用virtual方法。</p>
<p>3、在构造过程中，不能使用virtual从上到下调用，哪有什么办法弥补呢？  可以将子类必要的信息向上传递给父类构造方法。</p>
<h4 id="拷贝构造函数的参数是什么传递方式（引用传递），为什么">拷贝构造函数的参数是什么传递方式（引用传递），为什么</h4>
<ol>
<li>
<p>拷贝构造函数的参数必须使用<strong>引用传递</strong></p>
</li>
<li>
<p>如果拷贝构造函数中的参数不是一个引用，即形如 <code>CClass(const CClass c_class)</code>，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成<strong>无穷递归地调用拷贝构造函数</strong>。因此拷贝构造函数的参数必须是一个引用。</p>
<p>需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成<code>CClass(const CClass* c_class)</code>，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。</p>
</li>
</ol>
<h4 id="类方法和数据的权限有哪几种">类方法和数据的权限有哪几种</h4>
<ol>
<li>
<p>C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。</p>
<table><thead><tr><th align="left">关键字</th><th align="left">权限</th></tr></thead><tbody><tr><td align="left">public</td><td align="left">可以被任意实体访问</td></tr><tr><td align="left">protected</td><td align="left">只允许子类及本类的成员函数访问</td></tr><tr><td align="left">private</td><td align="left">只允许本类的成员函数访问</td></tr></tbody></table>
</li>
<li>
<p>下面介绍一个例子。</p>
<p>父类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">const</span> string&amp; name, <span class="keyword">int</span> age) : <span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ShowInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; m_name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; m_age &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  string m_name;  <span class="comment">//姓名</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_age;  <span class="comment">//年龄</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>子类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Teacher</span>(<span class="keyword">const</span> string&amp; name, <span class="keyword">int</span> age, <span class="keyword">const</span> string&amp; title)</span><br><span class="line">      : <span class="built_in">Person</span>(name, age), <span class="built_in">m_title</span>(title) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ShowTeacherInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ShowInfo</span>();                          <span class="comment">//正确，public属性子类可见</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; m_name &lt;&lt; endl;  <span class="comment">//正确，protected属性子类可见</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; m_age &lt;&lt; endl;   <span class="comment">//错误，private属性子类不可见</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;职称：&quot;</span> &lt;&lt; m_title &lt;&lt; endl;  <span class="comment">//正确，本类中可见自己的所有成员</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  string m_title;  <span class="comment">//职称</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用方：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">person</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">22</span>)</span></span>;</span><br><span class="line">    person.<span class="built_in">ShowInfo</span>();                  <span class="comment">//public属性,对外部可见</span></span><br><span class="line">    cout &lt;&lt; person.m_name &lt;&lt; endl;      <span class="comment">//错误，protected属性,对外部不可见</span></span><br><span class="line">    cout &lt;&lt; person.m_age &lt;&lt; endl;       <span class="comment">//错误，private属性,对外部不可见</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="如何理解抽象类？">如何理解抽象类？</h4>
<ol>
<li>
<p>抽象类的定义如下：</p>
<p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”，有纯虚函数的类就叫做抽象类。</p>
</li>
<li>
<p>抽象类有如下几个特点：</p>
<p>1）<strong>抽象类只能用作其他类的基类，不能建立抽象类对象。</strong></p>
<p>2）抽象类不能用作参数类型、函数返回类型或显式转换的类型。</p>
<p>3）<strong>可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。</strong></p>
</li>
</ol>
<h4 id="什么是多态？多态如何实现？-2">什么是多态？多态如何实现？</h4>
<p><strong>多态</strong>：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。在基类的函数前加上 <code>virtual</code> 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p>
<p><strong>实现方法</strong>：多态是通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。</p>
<p><strong>实现过程</strong>：</p>
<ol>
<li>在类中用 <code>virtual</code> 关键字声明的函数叫做虚函数；</li>
<li>存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（虚函数表和类对应的，虚表指针是和对象对应）；</li>
<li>当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。</li>
</ol>
<h4 id="什么是多态？除了虚函数，还有什么方式能实现多态？-2">什么是多态？除了虚函数，还有什么方式能实现多态？</h4>
<ol>
<li>
<p>多态是面向对象的重要特性之一，它是一种行为的封装，就是不同对象对同一行为会有不同的状态。(举例 : 学生和成人都去买票时,学生会打折,成人不会)</p>
</li>
<li>
<p>多态是以封装和继承为基础的。在C++中多态分为静态多态（早绑定）和动态多态（晚绑定）两种，其中<strong>动态多态是通过虚函数实现，静态多态通过函数重载实现</strong>，代码如下：</p>
</li>
</ol>
<h4 id="虚析构函数，什么作用">虚析构函数，什么作用</h4>
<ol>
<li>
<p>虚析构函数，是将基类的析构函数声明为virtual，举例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeKeeper</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">TimeKeeper</span>() &#123;&#125;        </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TimeKeeper</span>() &#123;&#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>虚析构函数的主要作用是防止内存泄露</strong>。</p>
<p>定义一个基类的指针p，在delete p时，如果基类的析构函数是虚函数，这时只会看p所赋值的对象，如果p赋值的对象是派生类的对象，就会调用派生类的析构函数（毫无疑问，在这之前也会先调用基类的构造函数，再调用派生类的构造函数，然后调用派生类的析构函数，基类的析构函数，所谓先构造的后释放）；如果p赋值的对象是基类的对象，就会调用基类的析构函数，这样就不会造成内存泄露。</p>
<p>如果基类的析构函数不是虚函数，在delete p时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象，这样就会造成内存泄露。</p>
</li>
</ol>
<p><strong>解析</strong></p>
<ul>
<li>
<p>我们创建一个TimeKeeper基类和一些及其它的派生类作为不同的计时方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeKeeper</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TimeKeeper</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">TimeKeeper</span>() &#123;&#125;  <span class="comment">//非virtual的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//都继承与TimeKeeper</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicClock</span> :</span><span class="keyword">public</span> TimeKeeper&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterClock</span> :</span><span class="keyword">public</span> TimeKeeper &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WristWatch</span> :</span><span class="keyword">public</span> TimeKeeper &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果客户想要在程序中使用时间，不想操作时间如何计算等细节，这时候我们可以设计factory（工厂）函数，让函数返回指针指向一个计时对象。该函数返回一个基类指针，这个基类指针是指向于派生类对象的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimeKeeper* <span class="title">getTimeKeeper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回一个指针，指向一个TimeKeeper派生类的动态分配对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>因为函数返回的对象存在于堆中，因此为了<strong>在不使用时我们需要使用释放该对象（delete）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TimeKeeper* ptk = <span class="built_in">getTimeKeeper</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> ptk;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>此处基类的析构函数是非virtual的，因此<strong>通过一个基类指针删除派生类对象是错误的</strong></p>
</li>
<li>
<p><strong>解决办法：</strong> 将基类的析构函数改为virtual就正确了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeKeeper</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TimeKeeper</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TimeKeeper</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>声明为virtual之后，通过<strong>基类指针删除派生类对象就会释放整个对象（基类+派生类）</strong></p>
</li>
</ul>
<h4 id="什么是虚基类，可否被实例化？">什么是虚基类，可否被实例化？</h4>
<ol>
<li>
<p><strong>在被继承的类前面加上virtual关键字，这时被继承的类称为虚基类</strong>，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> A;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> A;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B1,<span class="keyword">public</span> B2;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>虚继承的类可以被实例化</strong>，举例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span><span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">Liger lg ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*既然我们已经在Tiger和Lion类的定义中声明了&quot;virtual&quot;关键字，于是下面的代码编译OK */</span></span><br><span class="line"><span class="keyword">int</span> weight = lg.<span class="built_in">getWeight</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="拷贝赋值和移动赋值？">拷贝赋值和移动赋值？</h4>
<ol>
<li>
<p>拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一类中之前创建的对象来初始化新创建的对象。</p>
</li>
<li>
<p>移动赋值是通过移动构造函数来赋值，二者的主要区别在于</p>
<p>1）<strong>拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用</strong>；</p>
<p>2）拷贝构造函数完成的是整个对象或变量的拷贝，而<strong>移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存</strong>，相对于大量数据的拷贝节省时间和内存空间。</p>
</li>
</ol>
<h4 id="仿函数-函数对象？有什么作用">仿函数/函数对象？有什么作用</h4>
<ol>
<li>
<p>仿函数（functor）又称为函数对象（function object）<strong>是一个能行使函数功能的类</strong>。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载 <code>operator()</code> 运算符，举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Func</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> string&amp; str)</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// 仿函数必须重载 operator()</span></span><br><span class="line">            cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Func myFunc;</span><br><span class="line"><span class="built_in">myFunc</span>(<span class="string">&quot;helloworld!&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>仿函数既能像普通函数一样传入给定数量的参数，还能存储或者处理更多我们需要的有用信息。我们可以举个例子：</p>
<p>假设有一个<code>vector&lt;string&gt;</code>，你的任务是统计长度小于5的string的个数，如果使用<code>count_if</code>函数的话，你的代码可能长成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LengthIsLessThanFive</span><span class="params">(<span class="keyword">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> str.<span class="built_in">length</span>() &lt; <span class="number">5</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="built_in">count_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), LengthIsLessThanFive);</span><br></pre></td></tr></table></figure>
<p>其中<code>count_if</code>函数的第三个参数是一个函数指针，返回一个bool类型的值。一般的，如果需要将特定的阈值长度也传入的话，我们可能将函数写成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LenthIsLessThan</span><span class="params">(<span class="keyword">const</span> string&amp; str, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="built_in">length</span>() &lt; len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数看起来比前面一个版本更具有一般性，但是他不能满足<code>count_if</code>函数的参数要求：<code>count_if</code>要求的是 unary function（仅带有一个参数）作为它的最后一个参数。如果我们使用仿函数，是不是就豁然开朗了呢：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShorterThan</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">ShorterThan</span><span class="params">(<span class="keyword">int</span> maxLength)</span> : length(maxLength) &#123;</span>&#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> string&amp; str)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> str.<span class="built_in">length</span>() &lt; length;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="C-中哪些函数不能被声明为虚函数？">C++ 中哪些函数不能被声明为虚函数？</h4>
<p>常见的不不能声明为虚函数的有：非成员函数，静态成员函数（仅一份，无需要），内联成员函数（编译时展开），构造函数，友元函数（不能被继承）。</p>
<ol>
<li>
<p>为什么C++不支持普通函数为虚函数？</p>
<p>普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。</p>
</li>
<li>
<p>为什么C++不支持构造函数为虚函数？</p>
<ol>
<li>存储空间的角度：构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。</li>
<li>实现角度：虚表指针是在创建对象之后才有的，因此构造函数不能定义成虚函数。创建对象需要调用构造函数，此时构造函数如果是虚函数，而虚函数的调用需要通过虚函数指针寻址才能调用，悖论；</li>
<li>使用角度：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用；构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用。</li>
<li>类型角度：在创建对象时需要明确其类型。<strong>构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数</strong>。</li>
</ol>
</li>
<li>
<p>为什么C++不支持内联成员函数为虚函数？</p>
<p>其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，<em><strong>inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数</strong></em>）</p>
<p><strong>内联函数是在编译时期展开, 而虚函数的特性是运行时才动态联编, 所以两者矛盾, 不能定义内联函数为虚函数</strong></p>
</li>
<li>
<p>为什么C++不支持静态成员函数为虚函数？</p>
<p>这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。</p>
<p>静态成员函数属于一个类而非某一对象, 没有this指针, 它无法进行对象的判别</p>
</li>
<li>
<p>为什么C++不支持友元函数为虚函数？</p>
<p><strong>因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。</strong></p>
</li>
</ol>
<h4 id="C-中类模板和模板类的区别">C++ 中类模板和模板类的区别</h4>
<ol>
<li>
<p>类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数</p>
</li>
<li>
<p>模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替。</p>
</li>
</ol>
<p><strong>解析</strong></p>
<ol>
<li>
<p>类模板的类型参数可以有一个或多个，每个类型前面都必须加class，如template &lt;class T1,class T2&gt;class someclass{…};在定义对象时分别代入实际的类型名，如 someclass&lt;int,double&gt; obj;</p>
</li>
<li>
<p>和使用类一样，使用类模板时要注意其作用域，只能在其有效作用域内用它定义对象。</p>
</li>
<li>
<p>模板可以有层次，一个类模板可以作为基类，派生出派生模板类。</p>
</li>
</ol>
<h4 id="虚函数表里存放的内容是什么时候写进去的？">虚函数表里存放的内容是什么时候写进去的？</h4>
<p>vptr本身是要在构造时才初始化的，但是编译时，vptr就被编译器放入了类的内部。vptr编译期就已经成为类的成员了（虽然看不见，但实际上是会占用内存的）。vptr要在构造时才被初始化。</p>
<p>在编译阶段，虚指针就已经存在在类当中了，不管实例化与否。实例化调用构造函数时，这个指针才有了具体的指向（指向类的虚表）。</p>
<p>一：虚函数表指针(vptr)初始化时机<br>
vptr跟着对象走，所以对象什么时候创建出来，vptr就什么时候初始化出来，也就是运行的时候。<br>
当程序在编译期间，编译器会为构造函数中增加为vptr赋值的代码(这是编译器的行为)，当程序在运行时，遇到创建对象的代码，执行对象的构造函数，那么这个构造函数里有为这个对象的vptr赋值的语句。</p>
<p>二：虚函数表创建时机</p>
<p><strong>虚函数表创建时机是在编译期间</strong>。编译期间编译器就为每个类确定好了对应的虚函数表里的内容。<br>
所以在程序运行时，编译器会把虚函数表的首地址赋值给虚函数表指针，所以，这个虚函数表指针就有值了。</p>
<ol>
<li>虚函数表是一个存储虚函数地址的数组, 以NULL结尾。<strong>虚表（vtable）在编译阶段生成，对象内存空间开辟以后，写入对象中的 vptr，然后调用构造函数</strong>。即：<strong>虚表在构造函数之前写入</strong></li>
<li>除了在构造函数之前写入之外，我们还需要考虑到虚表的二次写入机制，通过此机制让每个对象的虚表指针都能准确的指向到自己类的虚表，为实现动多态提供支持。</li>
</ol>
<p><strong>1. 每个类都有虚指针和虚表；</strong></p>
<p><strong>2. 如果不是虚继承，那么子类将父类的虚指针继承下来，并指向自身的虚表（发生在对象构造时）。有多少个虚函数，虚表里面的项就会有多少。多重继承时，可能存在多个的基类虚表与虚指针；</strong></p>
<p><strong>3. 如果是虚继承，那么子类会有两份虚指针，一份指向自己的虚表，另一份指向虚基表，多重继承时虚基表与虚基表指针有且只有一份。</strong></p>
<h3 id="类相关">类相关</h3>
<h4 id="什么是虚函数？什么是纯虚函数？">什么是虚函数？什么是纯虚函数？</h4>
<p><strong>虚函数</strong>：被 <code>virtual</code> 关键字修饰的成员函数，就是虚函数。</p>
<p><strong>纯虚函数</strong>：</p>
<ul>
<li>纯虚函数在类中声明时，加上 <code>= 0</code>；</li>
<li>含有纯虚函数的类称为抽象类（只要含有纯虚函数这个类就是抽象类），类中只有接口，没有具体的实现方法；</li>
<li>继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。</li>
</ul>
<p>说明：</p>
<ul>
<li>抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；</li>
<li>可以声明抽象类指针，可以声明抽象类的引用；</li>
<li>子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。</li>
</ul>
<h4 id="虚函数和纯虚函数的区别？">虚函数和纯虚函数的区别？</h4>
<ul>
<li>虚函数和纯虚函数可以出现在同一个类中，该类称为抽象基类。（含有纯虚函数的类称为抽象基类）</li>
<li>使用方式不同：虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用；</li>
<li>定义形式不同：虚函数在定义时在普通函数的基础上加上 <code>virtual</code> 关键字，纯虚函数定义时除了加上<code>virtual</code> 关键字还需要加上 <code>= 0</code>;</li>
<li>虚函数必须实现，否则编译器会报错；</li>
<li>对于实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在派生类中重写；</li>
<li>析构函数最好定义为虚函数，特别是对于含有继承关系的类；析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。</li>
</ul>
<p>被继承的基类的析构函数应该定义为虚函数（或者，更准确的说，被多态使用的基类的析构函数应该定义为虚函数）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> baseData;</span><br><span class="line">  ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> derivedData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">  <span class="keyword">delete</span> b;  <span class="comment">// 由于 Base 的析构函数不是虚函数，</span></span><br><span class="line">             <span class="comment">// 这里调用的是 Base 的析构函数，</span></span><br><span class="line">             <span class="comment">// 而非 Derived 的析构函数,</span></span><br><span class="line">             <span class="comment">// 因此，Derived 里的 derivedData 没有被释放，</span></span><br><span class="line">             <span class="comment">// 因此，内存泄漏。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到，上面的代码会造成内存泄漏。<br>
那么，是不是把所有的析构函数都定义成虚函数就行了呢？<br>
很可惜，不是。<br>
虽然这样做可以避免内存泄露，但会有其他的问题，下面予以说明。</li>
<li>如果一个类没有被继承，以后也不会被继承，那么，它的析构函数不应该是虚函数。<br>
因为虚函数是由额外开销的，需要一个指针，vptr，来实现虚函数。<br>
一个指针占8个字节（在32位机上是4个字节），对于一些比较“小”，且使用频繁的类，这是个不小的开销。（遗憾的是，“小”且使用频繁的类经常出现，比如表示坐标轴上点的Point类。）</li>
<li>最佳实践：<br>
如果一个类被其他类所继承，将其析构函数声明为虚函数。<br>
如果一个类（现在和将来）不会被其他类继承，构造函数则不应该声明为虚函数。</li>
</ul>
<h4 id="虚函数的实现机制">虚函数的实现机制</h4>
<p><strong>实现机制</strong>：虚函数通过虚函数表来实现。虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数。</p>
<p><strong>虚函数表相关知识点：</strong></p>
<ul>
<li>虚函数表存放的内容：类的虚函数的地址。</li>
<li>虚函数表建立的时间：<strong>编译阶段</strong>，即程序的编译过程中会将虚函数的地址放在虚函数表中。</li>
<li>虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。</li>
</ul>
<p>注：<strong>虚函数表和类绑定，虚表指针和对象绑定</strong>。即类的不同的对象的虚函数表是一样的，但是每个对象都有自己的虚表指针，来指向类的虚函数表。</p>
<p><strong>实例：</strong></p>
<p>无虚函数覆盖的情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B_fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::B_fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::B_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B_fun3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::B_fun3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">    p-&gt;<span class="built_in">B_fun1</span>(); <span class="comment">// Base::B_fun1()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基类和派生类的继承关系：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202241106018.png" alt="image.png" style="zoom:50%;" />
<p>基类的虚函数表：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202241132980.png" alt="image.png" style="zoom:50%;" />
<p>派生类的虚函数表：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202241106055.png" alt="image.png" style="zoom:50%;" />
<p>主函数中基类的指针 <code>p</code> 指向了派生类的对象，当调用函数 <code>B_fun1()</code> 时，通过派生类的虚函数表找到该函数的地址，从而完成调用。</p>
<h4 id="单继承和多继承的虚函数表结构">单继承和多继承的虚函数表结构</h4>
<p><strong>编译器处理虚函数表：</strong></p>
<ul>
<li>编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。</li>
<li>如果派生类没有重新定义基类的虚函数 A，则派生类的虚函数表中保存的是基类的虚函数 A 的地址，也就是说基类和派生类的虚函数 A 的地址是一样的。</li>
<li>如果派生类重写了基类的某个虚函数 B，则派生的虚函数表中保存的是重写后的虚函数 B 的地址，也就是说虚函数 B 有两个版本，分别存放在基类和派生类的虚函数表中。</li>
<li>如果派生类重新定义了新的虚函数 C，派生类的虚函数表保存新的虚函数 C 的地址。</li>
</ul>
<p>两个父类的多继承（其他以此类推）总结：</p>
<ul>
<li>两个虚函数指针分别指两个虚函数表。每个虚函数表保存每个父类的虚函数地址。</li>
<li>内存布局与继承的父类的顺序有关，子类的虚函数插入到<strong>第一个虚指针所指</strong>的虚函数表中。</li>
<li>特别关注子类的虚析构函数。第二个虚指针调用虚析构函数时，会跳转到第一个虚函数表调用子类虚析构函数。</li>
<li>子类的虚函数表中虚函数的顺序与父类一样，若子类重写父类虚函数，即在虚函数表中原位置覆盖即可。</li>
</ul>
<ol>
<li>单继承无虚函数覆盖的情况：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B_fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::B_fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::B_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B_fun3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::B_fun3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">    p-&gt;<span class="built_in">B_fun1</span>(); <span class="comment">// Base::B_fun1()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基类和派生类的继承关系：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202241216827.png" alt="image.png" style="zoom:50%;" />
<p>基类的虚函数表：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202241216832.png" alt="image.png" style="zoom:50%;" />
<p>派生类的虚函数表：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202241216726.png" alt="image.png" style="zoom:50%;" />
<ol start="2">
<li>单继承有虚函数覆盖的情况：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::B_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B_fun3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::B_fun3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">    p-&gt;<span class="built_in">fun1</span>(); <span class="comment">// Derive::fun1()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>派生类的虚函数表：</p>
<img src="https://pic.leetcode-cn.com/1612682073-uNdCTl-image.png" alt="image.png" style="zoom:50%;" />
<ol start="3">
<li>多继承无虚函数覆盖的情况：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B1_fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base1::B1_fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B1_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base1::B1_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B1_fun3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base1::B1_fun3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2_fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base2::B2_fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base2::B2_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2_fun3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base2::B2_fun3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B3_fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base3::B3_fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B3_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base3::B3_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B3_fun3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base3::B3_fun3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base1 *p = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">    p-&gt;<span class="built_in">B1_fun1</span>(); <span class="comment">// Base1::B1_fun1()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基类和派生类的关系：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202241216841.png" alt="image.png" style="zoom:50%;" />
<p>派生类的虚函数表：（基类的顺序和声明的顺序一致）</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202241216866.png" alt="image.png" style="zoom:50%;" />
<ol start="4">
<li>多继承有虚函数覆盖的情况：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base1::fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B1_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base1::B1_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B1_fun3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base1::B1_fun3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base2::fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base2::B2_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2_fun3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base2::B2_fun3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base3::fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B3_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base3::B3_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B3_fun3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base3::B3_fun3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base1 *p1 = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">    Base2 *p2 = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">    Base3 *p3 = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">    p1-&gt;<span class="built_in">fun1</span>(); <span class="comment">// Derive::fun1()</span></span><br><span class="line">    p2-&gt;<span class="built_in">fun1</span>(); <span class="comment">// Derive::fun1()</span></span><br><span class="line">    p3-&gt;<span class="built_in">fun1</span>(); <span class="comment">// Derive::fun1()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基类和派生类的关系：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202241216195.png" alt="image.png" style="zoom:50%;" />
<p>派生类的虚函数表：</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202241216505.png" alt="image.png" style="zoom:50%;" />
<h4 id="如何禁止构造函数的使用？">如何禁止构造函数的使用？</h4>
<p>为类的构造函数增加 <code>= delete</code> 修饰符，可以达到虽然声明了构造函数但禁止使用的目的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var1, var2;</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        var1 = <span class="number">10</span>;</span><br><span class="line">        var2 = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> tmp1, <span class="keyword">int</span> tmp2) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A ex1;    </span><br><span class="line">    <span class="function">A <span class="title">ex2</span><span class="params">(<span class="number">12</span>,<span class="number">13</span>)</span></span>; <span class="comment">// error: use of deleted function &#x27;A::A(int, int)&#x27;</span></span><br><span class="line">    <span class="comment">// 说明：上述代码中，使用了已经删除 `delete` 的构造函数，程序出现错误。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用途举例：</p>
<ul>
<li>
<p>当类中含有不能默认初始化的成员变量时，可以禁止默认构造函数的生成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">myClass</span>() = <span class="keyword">delete</span>;<span class="comment">//表示删除默认构造函数</span></span><br><span class="line"><span class="built_in">myClass</span>() = <span class="keyword">default</span>;<span class="comment">//表示默认存在构造函数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当类中含有不能默认拷贝成员变量时，可以禁止默认构造函数的生成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">myClass</span>(<span class="keyword">const</span> myClass&amp;) = <span class="keyword">delete</span>;<span class="comment">//表示删除默认拷贝构造函数，即不能进行默认拷贝</span></span><br><span class="line">myClass &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> myClass&amp;) = <span class="keyword">delete</span>;<span class="comment">//表示删除赋值操作符，即不能进行赋值操作</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>比如c++11的新特性 unique_ptr ,只能使用移动构造，不能使用拷贝构造，为的是节省空间。</p>
</li>
</ul>
<h4 id="构造函数、析构函数是否需要定义成虚函数？为什么？">构造函数、析构函数是否需要定义成虚函数？为什么？</h4>
<p>构造函数一般不定义为虚函数，原因：</p>
<ul>
<li>从存储空间的角度考虑：构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。</li>
<li>从使用的角度考虑：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的。</li>
<li>从实现上考虑：虚表指针是在创建对象之后才有的，因此构造函数不能定义成虚函数。创建对象需要调用构造函数，此时构造函数如果是虚函数，而虚函数的调用需要通过虚函数指针寻址才能调用，悖论；</li>
<li>从类型上考虑：在创建对象时需要明确其类型。</li>
</ul>
<p>析构函数一般定义成虚函数，原因：</p>
<ul>
<li>析构函数定义成虚函数是为了防止内存泄漏，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。</li>
</ul>
<h4 id="如何避免拷贝？">如何避免拷贝？</h4>
<ol>
<li>
<p>private<br>
最直观的想法是：将类的拷贝构造函数和拷贝赋值运算符声明为私有 <code>private</code>，但对于类的成员函数和友元函数依然可以调用，达不到完全禁止类的对象被拷贝的目的，而且程序会出现错误，因为未对函数进行定义。</p>
<p>解决方法：声明一个基类，具体做法如下。</p>
<ul>
<li>
<p>定义一个基类，将其中的拷贝构造函数和拷贝赋值运算符声明为私有 <code>private</code></p>
</li>
<li>
<p>派生类以私有 <code>private</code> 的方式继承基类</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Uncopyable</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="keyword">const</span> Uncopyable &amp;);            <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    Uncopyable &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable &amp;); <span class="comment">// 赋值构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">private</span> Uncopyable &#123; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>简单解释：</p>
<ul>
<li>能够保证，在派生类 <code>A</code> 的成员函数和友元函数中无法进行拷贝操作，因为无法调用基类 <code>Uncopyable</code> 的拷贝构造函数或拷贝赋值运算符。同样，在类的外部也无法进行拷贝操作。</li>
<li>不管 public 继承和 private 继承派生类都不能直接访问 (注：派生类采用 public 继承后，基类的私有成员派生类是不可访问的，派生类只能访问基类的公有成员和保护成员。所以跟private继承一样派生类无法直接访问基类的拷贝构造函数和拷贝赋值运算符。) 拷贝构造函数和拷贝赋值运算符。</li>
<li>但其实不管那种继承方式都可以通过在派生类成员函数中调用基类的public成员函数间接访问。因此上述做法只能避免直接拷贝，仍然无法避免间接拷贝。</li>
</ul>
</li>
<li>
<p>C++ 11 可以使用弃置函数 <code>delete</code> 关键字</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">noncopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">noncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">noncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noncopyable</span>(<span class="keyword">const</span> noncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    noncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> noncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span> :</span> <span class="keyword">private</span> noncopyable &#123; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于继承应该用 private 还是 public 的争论<br>
虽然<code>public</code>继承也可以达到要求，但<strong>最好</strong>还是用<code>private</code>继承</p>
<p>原因见《Effective C++》书中以下条款：<br>
条款06：若不想使用编译器自动生成的函数，就该明确拒绝<br>
条款32：确定你的public继承塑造出<strong>is-a</strong>关系<br>
条款39：明智而审慎地使用private继承</p>
</blockquote>
</li>
</ol>
<h4 id="如何减少构造函数开销？">如何减少构造函数开销？</h4>
<p><strong>在构造函数中使用类初始化列表</strong>，会减少调用默认的构造函数产生的开销</p>
<p>因为对于非内置类型，少了调用一次默认构造函数和一次赋值构造函数的过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">int</span> tmp) &#123;</span><br><span class="line">    val = tmp;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A(int &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp; a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) &#123;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val = a.val;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A&amp; operator= (const&amp; A) &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  A ex;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test1</span>()</span><br><span class="line">      : <span class="built_in">ex</span>(<span class="number">1</span>)  <span class="comment">// 成员列表初始化方式</span></span><br><span class="line">  &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  A ex;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test2</span>()  <span class="comment">// 函数体中赋值的方式</span></span><br><span class="line">  &#123;</span><br><span class="line">    ex = <span class="built_in">A</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test1 ex1;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  Test2 ex2;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A(int 1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A()</span></span><br><span class="line"><span class="comment">A(int 2)</span></span><br><span class="line"><span class="comment">A&amp; operator= (const&amp; A)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="多重继承时会出现什么状况？如何解决？">多重继承时会出现什么状况？如何解决？</h4>
<p>多重继承（多继承）：是指从多个直接基类中产生派生类。</p>
<p>多重继承容易出现的问题：<strong>命名冲突和数据冗余问题</strong>。<strong>菱形继承</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 间接基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> var1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> :</span> <span class="keyword">public</span> Base1 &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> var2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> :</span> <span class="keyword">public</span> Base1 &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> var3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误用法派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3 &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_var1</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var1 = tmp; &#125;  <span class="comment">// error: reference to &#x27;var1&#x27; is ambiguous. 命名冲突</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_var1</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; Base2::var1 = tmp; &#125; <span class="comment">// 正确，这里声明成员变量来源于类 Base2</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_var2</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var2 = tmp; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_var3</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var3 = tmp; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_var4</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var4 = tmp; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> var4;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法 1： 声明出现冲突的成员变量来源于哪个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3 &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_var1</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; Base2::var1 = tmp; &#125; <span class="comment">// 正确，这里声明成员变量来源于类 Base2</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_var2</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var2 = tmp; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_var3</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var3 = tmp; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_var4</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var4 = tmp; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> var4;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法 2： 虚继承</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span>  <span class="comment">// 间接基类，即虚基类</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> var1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base1 &#123; <span class="comment">// 虚继承</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> var2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base1 &#123; <span class="comment">// 虚继承</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> var3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3 &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_var1</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var1 = tmp; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_var2</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var2 = tmp; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_var3</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var3 = tmp; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_var4</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var4 = tmp; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> var4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述程序的继承关系如下：（菱形继承）</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202241911112.png" alt="image.png" style="zoom: 50%;" />
<p><strong>上述代码中存的问题：</strong><br>
对于派生类 <code>Derive</code> 上述代码中存在直接继承关系和间接继承关系。</p>
<ul>
<li>直接继承：<code>Base2</code> 、<code>Base3</code></li>
<li>间接继承：<code>Base1</code></li>
</ul>
<p>对于派生类中继承的的成员变量 <code>var1</code> ，从继承关系来看，实际上保存了两份，一份是来自基类 <code>Base2</code>，一份来自基类 <code>Base3</code>。因此，出现了命名冲突。</p>
<p><strong>解决方法 1：</strong> <strong>声明出现冲突的成员变量来源于哪个类</strong></p>
<p><strong>解决方法 2：</strong> <strong>虚继承</strong></p>
<p>使用虚继承的目的：保证存在命名冲突的成员变量在派生类中只保留一份，即让间接基类中的成员在派生类中只保留一份。解决二义性问题。在菱形继承关系中，间接基类称为虚基类，直接基类和间接基类之间的继承关系称为虚继承。</p>
<p>实现方式：在继承方式前面加上 <code>virtual</code> 关键字。</p>
<p>类之间的继承关系：</p>
<img src="https://pic.leetcode-cn.com/1612681729-IhAKvb-image.png" alt="image.png" style="zoom:50%;" />
<h4 id="空类占多少字节？C-编译器会给一个空类自动生成哪些函数？">空类占多少字节？C++ 编译器会给一个空类自动生成哪些函数？</h4>
<ol>
<li>
<p>空类声明：<strong>空类声明时编译器不会生成任何成员函数：</strong><br>
<strong>对于空类，声明时编译器不会生成任何的成员函数，只会生成 1 个字节的占位符</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;sizeof(A):&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(A) &lt;&lt; endl;  <span class="comment">// sizeof(A):1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>空类定义对象后：<strong>空类定义时编译器会生成 6 个成员函数：</strong><br>
当空类 <code>A</code> 定义对象时，<code>sizeof(A)</code> 仍是为 1，但编译器会生成 6 个成员函数：缺省的构造函数、拷贝构造函数、拷贝赋值运算符、析构函数、两个取址运算符。<br>
“只有当一个类没有定义任何自己的版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class A</span></span><br><span class="line"><span class="comment">&#123;&#125;; 该空类的等价写法如下：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;&#125;;                                        <span class="comment">// 缺省构造函数</span></span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">const</span> A &amp;tmp)&#123;&#125;;                            <span class="comment">// 拷贝构造函数</span></span><br><span class="line">  ~<span class="built_in">A</span>()&#123;&#125;;                                       <span class="comment">// 析构函数</span></span><br><span class="line">  A &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;tmp)&#123;&#125;;                 <span class="comment">// 赋值运算符</span></span><br><span class="line">  A *<span class="keyword">operator</span>&amp;() &#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;;              <span class="comment">// 取址运算符</span></span><br><span class="line">  <span class="keyword">const</span> A *<span class="keyword">operator</span>&amp;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;;  <span class="comment">// 取址运算符（const 版本）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A *p = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;sizeof(A):&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(A) &lt;&lt; endl;  <span class="comment">// sizeof(A):1</span></span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="为什么拷贝构造函数必须为引用？">为什么拷贝构造函数必须为引用？</h4>
<p>原因：<strong>避免拷贝构造函数无限制的递归，最终导致栈溢出。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">int</span> tmp) : <span class="built_in">val</span>(tmp) &#123;  <span class="comment">// 带参数构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A(int tmp)&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">const</span> A &amp;tmp) &#123;  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A(const A &amp;tmp)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    val = tmp.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  A &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;tmp) &#123;  <span class="comment">// 赋值函数（赋值运算符重载）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A &amp;operator=(const A &amp;tmp)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    val = tmp.val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(A tmp)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">A <span class="title">ex1</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// A(int tmp)</span></span><br><span class="line">  <span class="function">A <span class="title">ex2</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// A(int tmp)</span></span><br><span class="line">  A ex3 = ex1;	<span class="comment">// A(const A &amp;tmp) // ex3 还没有实例化，因此调用的是拷贝构造函数，构造出 ex3，而不是赋值函数</span></span><br><span class="line">  ex2 = ex1;	<span class="comment">// A &amp;operator=(const A &amp;tmp) // 对象 ex2 已经实例化了，不需要构造，此时只是将 ex1 赋值给 ex2，只会调用赋值函数</span></span><br><span class="line">  ex2.<span class="built_in">fun</span>(ex1); <span class="comment">// A(const A &amp;tmp)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>说明 1：<code>ex2 = ex1;</code> 和 <code>A ex3 = ex1;</code> 为什么调用的函数不一样？<br>
对象 <code>ex2</code> 已经实例化了，不需要构造，此时只是将 <code>ex1</code> 赋值给 <code>ex2</code>，只会调用赋值函数；但是 <code>ex3</code> 还没有实例化，因此调用的是拷贝构造函数，构造出 <code>ex3</code>，而不是赋值函数，这里涉及到构造函数的隐式调用。</li>
<li>说明 2：如果拷贝构造函数中形参不是引用类型，<code>A ex3 = ex1;</code>会出现什么问题？<br>
构造 <code>ex3</code>，实质上是 <code>ex3.A(ex1);</code>，假如拷贝构造函数参数不是引用类型，那么将使得 <code>ex3.A(ex1);</code> 相当于 <code>ex1</code> 作为函数 <code>A(const A tmp)</code>的形参 <code>temp</code> 的实参，在参数传递时相当于 <code>A tmp = ex1</code>，因为 <code>tmp</code> 没有被初始化，所以在 <code>A tmp = ex1</code> 中继续调用拷贝构造函数，接下来的是构造 <code>tmp</code>，也就是 <code>tmp.A(ex1)</code> ，必然又会有 <code>ex1</code> 作为函数 <code>A(const A tmp);</code> 的形参 <code>temp</code> 的实参，在参数传递时相当于即 <code>A tmp = ex1</code>，那么又会触发拷贝构造函数，就这下永远的递归下去。</li>
<li>说明 3：为什么 <code>ex2.fun(ex1);</code> 会调用拷贝构造函数？<br>
<code>ex1</code> 作为参数传递给 <code>fun</code> 函数， 即 <code>A tmp = ex1;</code>，这个过程会调用拷贝构造函数进行初始化。</li>
</ul>
<h4 id="C-类对象的初始化顺序">C++ 类对象的初始化顺序</h4>
<p>构造函数调用顺序：</p>
<ul>
<li>
<p>按照派生类继承基类的顺序，即派生列表中声明的顺序，依次调用基类的构造函数；</p>
</li>
<li>
<p>按照派生类中成员变量的声名顺序，依次调用派生类中成员变量所属类的构造函数；</p>
</li>
<li>
<p>执行派生类自身的构造函数。</p>
</li>
</ul>
<p>综上可以得出，类对象的初始化顺序：<strong>基类构造函数–&gt;派生类成员变量的构造函数–&gt;自身构造函数</strong><br>
注：</p>
<ul>
<li>基类构造函数的调用顺序与派生类的<strong>派生列表中的顺序</strong>有关；</li>
<li>成员变量的初始化顺序与<strong>声明顺序</strong>有关；</li>
<li>析构顺序和构造顺序相反。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  ~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> :</span> <span class="keyword">public</span> A,</span><br><span class="line">             <span class="keyword">public</span> B  <span class="comment">// 派生列表</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  ~<span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  B ex1;</span><br><span class="line">  A ex2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test ex;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">A()</span></span><br><span class="line"><span class="comment">B()</span></span><br><span class="line"><span class="comment">B()</span></span><br><span class="line"><span class="comment">A()</span></span><br><span class="line"><span class="comment">Test()</span></span><br><span class="line"><span class="comment">~Test()</span></span><br><span class="line"><span class="comment">~A()</span></span><br><span class="line"><span class="comment">~B()</span></span><br><span class="line"><span class="comment">~B()</span></span><br><span class="line"><span class="comment">~A()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>程序运行结果分析：</p>
<ul>
<li>首先调用基类 A 和 B 的构造函数，按照派生列表 <code>public A, public B</code> 的顺序构造；</li>
<li>然后调用派生类 Test 的成员变量 ex1 和 ex2 的构造函数，按照派生类中成员变量声明的顺序构造；</li>
<li>最后调用派生类的构造函数；</li>
<li>接下来调用析构函数，和构造函数调用的顺序相反。</li>
</ul>
<h4 id="如何禁止一个类被实例化">如何禁止一个类被实例化</h4>
<ol>
<li>
<p>方法一：在类中定义一个<strong>纯虚函数</strong>，<strong>使该类成为抽象基类</strong>，因为不能创建抽象基类的实例化对象；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> var1, var2;</span><br><span class="line">  <span class="built_in">A</span>() &#123;</span><br><span class="line">    var1 = <span class="number">10</span>;</span><br><span class="line">    var2 = <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A ex1;  <span class="comment">// error: cannot declare variable &#x27;ex1&#x27; to be of abstract type &#x27;A&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方法二：<strong>禁止使用构造函数</strong>，即将类的构造函数声明为私有 <code>private</code> 或者使用 <code>delete</code>。</p>
<p>注意：类的构造函数声明为私有可以禁止直接实例化，不能禁止间接实例化。</p>
</li>
</ol>
<h4 id="为什么用成员初始化列表会快一些？">为什么用成员初始化列表会快一些？</h4>
<p>初始化列表先于构造函数体内的代码执行，初始化列表执行的是数据成员的初始化过程</p>
<p><strong>说明</strong>：数据类型可分为内置类型和用户自定义类型（类类型），对于用户自定义类型，利用成员初始化列表效率高。</p>
<p><strong>原因</strong>：<strong>用户自定义类型如果使用类初始化列表，直接调用该成员变量对应的构造函数即完成初始化</strong>；</p>
<ul>
<li>如果在构造函数中初始化，因为 C++ 规定，<strong>对象的成员变量的初始化动作发生在进入构造函数本体之前</strong>，那么在执行构造函数的函数体之前首先调用默认的构造函数为成员变量设初值，在进入函数体之后，调用该成员变量对应的构造函数。</li>
<li>因此，使用列表初始化会减少一次调用默认的构造函数以及一次调用拷贝赋值运算符的过程，效率高。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">int</span> tmp) &#123;</span><br><span class="line">    val = tmp;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A(int &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp; a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) &#123;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val = a.val;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A&amp; operator= (const&amp; A) &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  A ex;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test1</span>()</span><br><span class="line">      : <span class="built_in">ex</span>(<span class="number">1</span>)  <span class="comment">// 成员列表初始化方式</span></span><br><span class="line">  &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  A ex;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 在进入构造函数体之前，调用默认构造函数初始化ex</span></span><br><span class="line">  <span class="built_in">Test2</span>() &#123; <span class="comment">// 函数体中赋值的方式</span></span><br><span class="line">    ex = <span class="built_in">A</span>(<span class="number">2</span>); <span class="comment">// 生成临时对象后，调用拷贝赋值运算符</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test1 ex1;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  Test2 ex2;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A(int 1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A()</span></span><br><span class="line"><span class="comment">A(int 2)</span></span><br><span class="line"><span class="comment">A&amp; operator= (const&amp; A)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>说明：<br>
从程序运行结果可以看出，使用成员列表初始化的方式会省去一次调用默认的构造函数的过程以及一次调用拷贝赋值运算符的过程。</p>
<p><strong>初始化数据成员与对数据成员赋值的含义是什么？有什么区别？</strong></p>
<p>首先把数据成员按类型分类并分情况说明:</p>
<ol>
<li>内置数据类型，复合类型（指针，引用）- 在成员初始化列表和构造函数体内进行，在性能和结果上都是一样的</li>
<li>用户定义类型（类类型）- 结果上相同，但是性能上存在很大的差别。<strong>因为类类型的数据成员对象在进入函数体前已经构造完成，也就是说在成员初始化列表处进行构造对象的工作，调用构造函数，在进入函数体之后，进行的是对已经构造好的类对象的赋值，又调用个拷贝赋值操作符才能完成</strong>（如果并未提供，则使用编译器提供的默认按成员赋值行为）</li>
</ol>
<h4 id="实例化一个对象需要哪几个阶段">实例化一个对象需要哪几个阶段</h4>
<ol>
<li>
<p>分配空间</p>
<p>创建类对象首先要为该对象分配内存空间。不同的对象，为其分配空间的时机未必相同。全局对象、静态对象、分配在栈区域内的对象，在编译阶段进行内存分配；存储在堆空间的对象，是在运行阶段进行内存分配。</p>
<p>在C++中，类对象的建立方式有两种：</p>
<ul>
<li>
<p>静态建立类对象，如A a;</p>
<p>是指全局对象，静态对象，以及分配在栈区域内的对象，编译器对它们的内存分配是在编译阶段就完成的，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，直接调用类的构造函数。</p>
</li>
<li>
<p>动态建立类对象，如A* p = new A;</p>
<p>分配堆区域内的对象，编译器对他们的内存分配是在运行时动态分配的，(使用new运算符将对象建立在堆空间中。这个过程分为两步，第一步，执行operator new()函数，在对中搜索合适的内存并进行分配，第二步，调用构造函数构造对象，初始化这片内存空间。使用这种方法，间接调用类的构造函数。</p>
</li>
</ul>
</li>
<li>
<p>初始化</p>
<p>首先明确一点：初始化不同于赋值。初始化发生在赋值之前，初始化随对象的创建而进行，而赋值是在对象创建好后，为其赋上相应的值。这一点可以联想下上一个问题中提到：<strong>初始化列表先于构造函数体内的代码执行，初始化列表执行的是数据成员的初始化过程</strong>，这个可以从成员对象的构造函数被调用看的出来。</p>
</li>
<li>
<p>赋值</p>
<p>对象初始化完成后，可以对其进行赋值。对于一个类的对象，其成员变量的赋值过程发生在类的构造函数的函数体中。当执行完该函数体，也就意味着类对象的实例化过程完成了。（总结：构造函数实现了对象的初始化和赋值两个过程，对象的初始化是通过初始化列表来完成，而对象的赋值则才是通过构造函数的函数体来实现。）</p>
</li>
</ol>
<p>注：<strong>对于拥有虚函数的类的对象，还需要给虚表指针赋值</strong>。</p>
<ul>
<li>没有继承关系的类，分配完内存后，<strong>首先给虚表指针赋值</strong>，然后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。</li>
<li>有继承关系的类，分配内存之后，首先进行基类的构造过程，然后给该派生类的虚表指针赋值，最后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。</li>
</ul>
<h4 id="友元函数的作用及使用场景">友元函数的作用及使用场景</h4>
<p>作用：</p>
<ul>
<li>友元提供了不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。</li>
<li>通过友元，一个不同函数或另一个类中的成员函数<strong>可以访问类中的私有成员和保护成员</strong>。</li>
</ul>
<p>使用场景：</p>
<ol>
<li>
<p>普通函数定义为友元函数，使普通函数能够访问类的私有成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;_cout, <span class="keyword">const</span> A &amp;tmp);  <span class="comment">// 声明为类的友元函数</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">int</span> tmp) : <span class="built_in">var</span>(tmp) &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> var;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;_cout, <span class="keyword">const</span> A &amp;tmp) &#123;</span><br><span class="line">  _cout &lt;&lt; tmp.var;</span><br><span class="line">  <span class="keyword">return</span> _cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">A <span class="title">ex</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">  cout &lt;&lt; ex &lt;&lt; endl;  <span class="comment">// 4</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>友元类：类之间共享数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() : <span class="built_in">var</span>(<span class="number">10</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">int</span> tmp) : <span class="built_in">var</span>(tmp) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;fun():&quot;</span> &lt;&lt; var &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> var;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fun():&quot;</span> &lt;&lt; ex.var &lt;&lt; endl;  <span class="comment">// 访问类 A 中的私有成员</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  A ex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  B ex;</span><br><span class="line">  ex.<span class="built_in">fun</span>();  <span class="comment">// fun():10</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="静态绑定和动态绑定">静态绑定和动态绑定</h4>
<p>静态类型和动态类型：</p>
<ul>
<li>静态类型：变量在声明时的类型，是在编译阶段确定的。静态类型不能更改。</li>
<li>动态类型：目前所指对象的类型，是在运行阶段确定的。动态类型可以更改。</li>
</ul>
<p>静态绑定和动态绑定：</p>
<ul>
<li>静态绑定是指程序在 <strong>编译阶段</strong> 确定对象的类型（静态类型）。</li>
<li>动态绑定是指程序在 <strong>运行阶段</strong> 确定对象的类型（动态类型）。</li>
</ul>
<p>静态绑定和动态绑定的区别：</p>
<ul>
<li>发生的时期不同：如上。</li>
<li>对象的静态类型不能更改，动态类型可以更改。</li>
</ul>
<p>注：对于类的成员函数，只有虚函数是动态绑定，其他都是静态绑定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::fun()&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Base *p = <span class="keyword">new</span> <span class="built_in">Derive</span>();  <span class="comment">// p 的静态类型是 Base*，动态类型是 Derive*</span></span><br><span class="line">  p-&gt;<span class="built_in">fun</span>();                <span class="comment">// fun 是虚函数，运行阶段进行动态绑定</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">Derive::fun()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="深拷贝和浅拷贝的区别">深拷贝和浅拷贝的区别</h4>
<p>如果一个类拥有资源，该类的对象进行复制时，如果资源重新分配，就是深拷贝，否则就是浅拷贝。</p>
<ul>
<li>深拷贝：该对象和原对象占用不同的内存空间，既拷贝存储在栈空间中的内容，又拷贝存储在堆空间中的内容。</li>
<li>浅拷贝：该对象和原对象占用同一块内存空间，仅拷贝类中位于栈空间中的内容。</li>
</ul>
<p><strong>当类的成员变量中有指针变量时，最好使用深拷贝。因为当两个对象指向同一块内存空间，如果使用浅拷贝，当其中一个对象的删除后，该块内存空间就会被释放，另外一个对象指向的就是垃圾内存。</strong></p>
<p><strong>浅拷贝实例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> *p;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test</span>(<span class="keyword">int</span> tmp) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(tmp);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Test(int tmp)&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Test <span class="title">ex1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="comment">// Test ex2 = ex1; *** Error in `./a.out&#x27;: double free or corruption (fasttop): 0x0000000000d21c20 ***</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">Test(int tmp)</span></span><br><span class="line"><span class="comment">~Test()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>说明：上述代码中，类对象 ex1、ex2 中的指针 p 实际上是指向同一块内存空间，对象析构时，ex2 先将内存释放了一次，之后析构对象 ex1 时又将这块已经被释放过的内存再释放一次。对同一块内存空间释放了两次，会导致程序崩溃。</p>
<p><strong>深拷贝实例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> *p;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test</span>(<span class="keyword">int</span> tmp) &#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(tmp);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Test(int tmp)&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Test</span>(<span class="keyword">const</span> Test &amp;tmp) &#123; <span class="comment">// 定义拷贝构造函数</span></span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*tmp.p);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Test(const Test &amp;tmp)&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Test <span class="title">ex1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  Test ex2 = ex1;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Test(int tmp)</span></span><br><span class="line"><span class="comment">Test(const Test &amp;tmp)</span></span><br><span class="line"><span class="comment">~Test()</span></span><br><span class="line"><span class="comment">~Test()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="编译时多态和运行时多态的区别-2">编译时多态和运行时多态的区别</h4>
<ul>
<li>编译时多态：在程序编译过程中出现，发生在模板和函数重载中（泛型编程）。</li>
<li>运行时多态：在程序运行过程中出现，发生在继承体系中，是指通过基类的指针或引用访问派生类中的虚函数。</li>
</ul>
<p>编译时多态和运行时多态的区别：</p>
<ul>
<li>时期不同：编译时多态发生在程序编译过程中，运行时多态发生在程序的运行过程中；</li>
<li>实现方式不同：编译时多态运用泛型编程来实现，运行时多态借助虚函数来实现。</li>
</ul>
<h4 id="实现一个类成员函数，要求不允许修改类的成员变量？">实现一个类成员函数，要求不允许修改类的成员变量？</h4>
<p>如果想达到一个类的成员函数不能修改类的成员变量，只需用 <code>const</code> 关键字来修饰该函数即可。</p>
<p>该问题本质是考察 <code>const</code> 关键字修饰成员函数的作用，以实例的方式来考察，应熟练掌握 <code>const</code> 关键字的作用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var1, var2;</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        var1 = <span class="number">10</span>;</span><br><span class="line">        var2 = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// 不能在 const 修饰的成员函数中修改成员变量的值，除非该成员变量用 mutable 修饰</span></span><br><span class="line">        var1 = <span class="number">100</span>; <span class="comment">// error: assignment of member &#x27;A::var1&#x27; in read-only object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A ex1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何让类不能被继承-final-？">如何让类不能被继承(final)？</h4>
<ul>
<li><strong>借助 <code>final</code> 关键字，用该关键字修饰的类不能被继承</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> <span class="keyword">final</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base &#123;&#125;;  <span class="comment">// error: cannot derive from &#x27;final&#x27; base &#x27;Base&#x27; in derived type &#x27;Derive&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Derive ex;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>借助友元、虚继承和私有构造函数来实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">  <span class="keyword">friend</span> T;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;base&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base&lt;B&gt; &#123;  <span class="comment">//一定注意 必须是虚继承</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">C</span>() &#123;</span><br><span class="line">  &#125;  <span class="comment">// error: &#x27;Base&lt;T&gt;::Base() [with T = B]&#x27; is private within this context</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：在上述代码中 <code>B</code> 类是不能被继承的类。<br>
具体原因：</p>
<ul>
<li>虽然 <code>Base</code> 类构造函数和析构函数被声明为私有 <code>private</code>，在 <code>B</code> 类中，由于 <code>B</code> 是 <code>Base</code> 的友元，因此可以访问 <code>Base</code> 类构造函数，从而正常创建 <code>B</code> 类的对象；</li>
<li><code>B</code> 类继承 <code>Base</code> 类采用虚继承的方式，创建 <code>C</code> 类的对象时，<code>C</code> 类的构造函数要负责 <code>Base</code> 类的构造，但是 <code>Base</code> 类的构造函数私有化了，<code>C</code> 类没有权限访问。因此，无法创建 <code>C</code> 类的对象， <code>B</code> 类是不能被继承的类。</li>
</ul>
<p>注意：在继承体系中，<strong>友元关系不能被继承</strong>，虽然 <code>C</code> 类继承了 <code>B</code> 类，<code>B</code> 类是 <code>Base</code> 类的友元，但是 <code>C</code> 类和 <code>Base</code> 类没有友元关系。</p>
<p>这里采用虚继承的原因是，直接由最低层次的派生类构造函数初始化虚基类。这是因为在菱形继承中，可能会存在对虚基类的多次初始化问题，为了避免出现该问题，在采用虚继承的时候，直接由最低层次的派生类构造函数直接负责虚基类类的构造。如果不加virtual的话，在构造函数的顺序中，每个类只负责自己的直接基类的初始化，所以还是可以生成对象的。加上了virtual之后，C直接负责Base类的构造，但是Base类的构造函数和析构函数都是private，C无法访问，所以不能生成对象。</p>
<h3 id="STL-相关">STL 相关</h3>
<h4 id="STL-的基本组成部分">STL 的基本组成部分</h4>
<p>标准模板库（Standard Template Library, 简称STL）简单说，就是一些常用数据结构和算法的模板的集合。</p>
<p><strong>广义上讲</strong>，STL分为3类：Algorithm（算法）、Container（容器）和Iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。</p>
<p><strong>详细的说</strong>，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。</p>
<p><strong>解析</strong></p>
<p>标准模板库STL主要由6大组成部分：</p>
<ol>
<li>
<p>容器(Container)</p>
<p>是一种数据结构， 如list, vector, 和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。</p>
</li>
<li>
<p>算法（Algorithm）</p>
<p>是用来操作容器中的数据的模板函数。例如，STL 用 sort() 来对一个 vector 中的数据进行排序，用 find() 来搜索一个 list 中的对象， 函数本身与他们操作的数据的结构和类型无关，因此他们可以用于从简单数组到高度复杂容器的任何数据结构上。</p>
</li>
<li>
<p>迭代器（Iterator）</p>
<p>提供了访问容器中对象的方法。例如，可以使用一对迭代器指定 list 或 vector 中的一定范围的对象。 迭代器就如同一个指针。事实上，C++ 的指针也是一种迭代器。 但是，迭代器也可以是那些定义了 operator*() 以及其他类似于指针的操作符方法的类对象;</p>
</li>
<li>
<p>仿函数（Function object）</p>
<p>仿函数又称之为函数对象， 其实就是重载了操作符的 struct, 没有什么特别的地方。</p>
</li>
<li>
<p>适配器（Adaptor）</p>
<p>简单的说就是一种接口类，专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能。主要包括 3 中适配器 Container Adaptor、Iterator Adaptor、Function Adaptor。</p>
</li>
<li>
<p>空间配制器（Allocator）</p>
<p>为 STL 提供空间配置的系统。其中主要工作包括两部分：</p>
<p>（1）对象的创建与销毁；</p>
<p>（2）内存的获取与释放。</p>
</li>
</ol>
<h4 id="STL-中常见的容器，并介绍一下实现原理">STL 中常见的容器，并介绍一下实现原理</h4>
<p>容器可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是模板类，分为顺序容器、关联式容器、容器适配器三种类型，三种类型容器特性分别如下：</p>
<ol>
<li>
<p>顺序容器</p>
<p>容器并非排序的，元素的插入位置同元素的值无关。包含vector、deque、list，具体实现原理如下：</p>
<ul>
<li>
<p>vector 头文件<br>
动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。</p>
</li>
<li>
<p>deque 头文件<br>
双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（仅次于vector）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。</p>
</li>
<li>
<p>list 头文件<br>
双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。</p>
</li>
</ul>
</li>
<li>
<p>关联式容器</p>
<p>元素是排序的；插入任何元素，都按相应的排序规则来确定其位置；在查找时具有非常好的性能；通常以平衡二叉树的方式实现。包含set、multiset、map、multimap，具体实现原理如下：</p>
<ul>
<li>
<p>set/multiset 头文件</p>
<p>set 即集合。set 中不允许相同元素，multiset 中允许存在相同元素。</p>
</li>
<li>
<p>map/multimap 头文件</p>
<p>map 与 set 的不同在于 map 中存放的元素有且仅有两个成员变量，一个名为 first ,另一个名为 second , map 根据 first 值对元素从小到大排序，并可快速地根据 first 来检索元素。</p>
</li>
</ul>
<p>**注意：**map 同 multimap 的不同在于是否允许相同 first 值的元素。</p>
</li>
<li>
<p>容器适配器</p>
<p>封装了一些基本的容器，使之具备了新的函数功能，比如把 deque 封装一下变为一个具有 stack 功能的数据结构。这新得到的数据结构就叫适配器。包含 stack , queue , priority_queue，具体实现原理如下：</p>
<ul>
<li>
<p>stack 头文件</p>
<ul>
<li>栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最进插入序列的项（栈顶的项）。后进先出。</li>
<li>默认用 deque 实现，也可以用 vector、list 实现</li>
</ul>
</li>
<li>
<p>queue 头文件</p>
<ul>
<li>队列。插入只可以在尾部进行，删除只允许从头部进行。先进先出。</li>
<li>默认用 deque 实现，也可以用 vector、list 实现</li>
</ul>
</li>
<li>
<p>priority_queue 头文件</p>
<ul>
<li>优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。最高优先级元素总是第一个出列。</li>
<li>默认用 vector 实现，也可以用 deque 实现</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="STL-中-map-hashtable-deque-list-的实现原理">STL 中 map hashtable deque list 的实现原理</h4>
<p>map、hashtable、deque、list实现机理分别为红黑树、函数映射、双向队列、双向链表，他们的特性分别如下：</p>
<ol>
<li>
<p>map 实现原理</p>
<p>map 内部实现了一个<strong>红黑树</strong>（红黑树是非严格平衡的二叉搜索树，而 AVL 是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素。因此，对于 map 进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map 中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。</p>
</li>
<li>
<p>hashtable（也称散列表，直译作哈希表）实现原理</p>
<p>hashtable 采用了<strong>函数映射的思想</strong>记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。这决定了哈希表特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。</p>
</li>
<li>
<p>deque实现原理</p>
<p>deque内部实现的是一个<strong>双向队列</strong>。元素在内存连续存放。随机存取任何元素都在常数时间完成（仅次于vector）。所有适用于vector的操作都适用于deque。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。</p>
</li>
<li>
<p>list实现原理</p>
<p>list内部实现的是一个<strong>双向链表</strong>。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。无成员函数，给定一个下标i，访问第i个元素的内容，只能从头部挨个遍历到第i个元素。</p>
</li>
</ol>
<h4 id="STL-的空间配置器（allocator）">STL 的空间配置器（allocator）</h4>
<p>一般情况下,一个程序包括数据结构和相应的算法，而数据结构作为存储数据的组织形式，与内存空间有着密切的联系。在 C++ STL 中，空间配置器便是用来实现内存空间(一般是内存，也可以是硬盘等空间)分配的工具，他与容器联系紧密，每一种容器的空间分配都是通过空间分配器 alloctor 实现的。</p>
<p><strong>解析</strong></p>
<ol>
<li>
<p>两种 C++ 类对象实例化方式的异同</p>
<p>在c++中，创建类对象一般分为两种方式：</p>
<ul>
<li>一种是直接利用构造函数, 直接构造类对象，如 Test test()；</li>
<li>另一种是通过 new 来实例化一个类对象，如 Test *pTest = new Test；那么，这两种方式有什么异同点呢？</li>
</ul>
<p>我们知道，内存分配主要有三种方式：</p>
<ul>
<li>静态存储区分配：内存在程序编译的时候已经分配好，这块内存在程序的整个运行空间内都存在。如全局变量, 静态变量等。</li>
<li>栈空间分配：程序在运行期间，函数内的局部变量通过栈空间来分配存储（函数调用栈），当函数执行完毕返回时，相对应的栈空间被立即回收。主要是局部变量。</li>
<li>堆空间分配：程序在运行期间，通过在堆空间上为数据分配存储空间，通过 malloc 和 new 创建的对象都是从堆空间分配内存，这类空间需要程序员自己来管理，必须通过 free() 或者是 delete() 函数对堆空间进行释放，否则会造成内存溢出。</li>
</ul>
<p>那么，从<strong>内存空间分配的角度</strong>来对这两种方式的区别，就比较容易区分:</p>
<ul>
<li>对于第一种方式来说，是直接通过调用 Test 类的构造函数来实例化 Test 类对象的, 如果该实例化对象是一个局部变量，则其是在栈空间分配相应的存储空间。</li>
<li>对于第二种方式来说, 就显得比较复杂。这里主要以 new 类对象来说明一下。new 一个类对象, 其实是执行了两步操作：<strong>首先, 调用 new 在堆空间分配内存, 然后调用类的构造函数构造对象的内容</strong>；同样，使用 delete 释放时，也是经历了两个步骤：<strong>首先调用类的析构函数释放类对象，然后调用 delete 释放堆空间</strong>。</li>
</ul>
</li>
<li>
<p>C++ STL 空间配置器实现</p>
<p>很容易想象，为了实现空间配置器，完全可以利用 new 和 delete 函数并对其进行封装实现 STL 的空间配置器，的确可以这样。但是，为了最大化提升效率，SGI STL版本并没有简单的这样做，而是采取了一定的措施，实现了更加高效复杂的空间分配策略。由于以上的构造都分为两部分，所以，在SGI STL中，将对象的构造切分开来，分成空间配置和对象构造两部分。</p>
<ul>
<li>内存配置操作: 通过alloc::allocate()实现</li>
<li>内存释放操作: 通过alloc::deallocate()实现</li>
<li>对象构造操作: 通过::construct()实现</li>
<li>对象释放操作: 通过::destroy()实现</li>
</ul>
<p>关于内存空间的配置与释放，SGI STL采用了两级配置器：一级配置器主要是考虑大块内存空间，利用 malloc 和 free实现；二级配置器主要是考虑小块内存空间而设计的（为了最大化解决内存碎片问题，进而提升效率），采用链表 free_list 来维护内存池（memory pool），free_list 通过 union 结构实现，空闲的内存块互相挂接在一块，内存块一旦被使用，则被从链表中剔除，易于维护。</p>
</li>
</ol>
<h4 id="STL-容器用过哪些，查找的时间复杂度是多少，为什么？">STL 容器用过哪些，查找的时间复杂度是多少，为什么？</h4>
<p>STL中常用的容器有vector、deque、list、map、set、multimap、multiset、unordered_map、unordered_set等。容器底层实现方式及时间复杂度分别如下：</p>
<ol>
<li>
<p>vector</p>
<p>采用一维数组实现，元素在内存连续存放，不同操作的时间复杂度为：</p>
<ul>
<li>随机访问——常数 <em>𝓞(1)</em></li>
<li>在末尾插入或移除元素——均摊常数 <em>𝓞(1)</em></li>
<li>插入或移除元素——与到 vector 结尾的距离成线性 <em>𝓞(n)</em></li>
</ul>
</li>
<li>
<p>deque</p>
<p>采用双向队列实现，元素在内存连续存放，不同操作的时间复杂度为：</p>
<ul>
<li>随机访问——常数 <em>O(1)</em></li>
<li>在结尾或起始插入或移除元素——常数 <em>O(1)</em></li>
<li>插入或移除元素——线性 <em>O(n)</em></li>
</ul>
</li>
<li>
<p>list</p>
<p>采用双向链表实现，元素存放在堆中，不同操作的时间复杂度为：</p>
<p>插入: O(1)</p>
<p>查看: O(N)</p>
<p>删除: O(1)</p>
</li>
<li>
<p>map、set、multimap、multiset</p>
<p>上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为:</p>
<p>插入: O(logN)</p>
<p>查看: O(logN)</p>
<p>删除: O(logN)</p>
</li>
<li>
<p>unordered_map、unordered_set、unordered_multimap、 unordered_multiset</p>
<p>上述四种容器采用哈希表实现，不同操作的时间复杂度为：<br>
插入: O(1)，最坏情况O(N)</p>
<p>查看: O(1)，最坏情况O(N)</p>
<p>删除: O(1)，最坏情况O(N)</p>
<p>**注意：**容器的时间复杂度取决于其底层实现方式。</p>
</li>
</ol>
<h4 id="迭代器？什么时候会失效？">迭代器？什么时候会失效？</h4>
<p>常用容器迭代器失效情形如下。</p>
<ol>
<li>
<p>对于序列容器 vector，deque 来说，使用 erase 后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase 返回下一个有效的迭代器。</p>
</li>
<li>
<p>对于关联容器 map，set 来说，使用了 erase 后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用 erase 之前，记录下一个元素的迭代器即可。</p>
</li>
<li>
<p>对于 list 来说，它使用了不连续分配的内存，并且它的 erase 方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。</p>
</li>
</ol>
<h4 id="STL中迭代器的作用，有指针为何还要迭代器？">STL中迭代器的作用，有指针为何还要迭代器？</h4>
<ol>
<li>
<p>迭代器的作用</p>
<p>（1）用于指向顺序容器和关联容器中的元素</p>
<p>（2）通过迭代器可以读取它指向的元素</p>
<p>（3）通过非 const 迭代器还可以修改其指向的元素</p>
</li>
<li>
<p>迭代器和指针的区别</p>
<p>**迭代器不是指针，是类模板，表现的像指针。**他只是模拟了指针的一些功能，重载了指针的一些操作符，–&gt;、++、–等。迭代器封装了指针，是一个 “可遍历STL（ Standard Template Library）容器内全部或部分元素” 的对象，<strong>本质是封装了原生指针</strong>，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p>
<p><strong>迭代器返回的是对象引用而不是对象的值</strong>，所以 cout 只能输出迭代器使用取值后的值而不能直接输出其自身。</p>
</li>
<li>
<p>迭代器产生的原因</p>
<p>Iterator 类的访问方式就是把不同集合类的访问逻辑抽象出来，<strong>使得不用暴露集合内部的结构而达到循环遍历集合的效果</strong>。</p>
</li>
</ol>
<p><strong>解析</strong></p>
<ol>
<li>
<p>迭代器</p>
<p>Iterator（迭代器）模式又称游标（Cursor）模式，用于提供一种方法<strong>顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示</strong>。 或者这样说可能更容易理解：Iterator 模式是运用于聚合对象的一种模式，通过运用该模式，使得我们<strong>可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素</strong>。 由于 Iterator 模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如 STL 的 list、vector、stack 等容器类及 ostream_iterator 等扩展Iterator。</p>
</li>
<li>
<p>迭代器示例：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v; <span class="comment">//一个存放int元素的数组，一开始里面没有元素</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::const_iterator i; <span class="comment">//常量迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i) <span class="comment">//v.begin()表示v第一个元素迭代器指针，++i指向下一个元素</span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot;,&quot;</span>; <span class="comment">//*i表示迭代器指向的元素</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::reverse_iterator r; <span class="comment">//反向迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (r = v.<span class="built_in">rbegin</span>(); r != v.<span class="built_in">rend</span>(); r++)</span><br><span class="line">        cout &lt;&lt; *r &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator j; <span class="comment">//非常量迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (j = v.<span class="built_in">begin</span>();j != v.<span class="built_in">end</span>();j++)</span><br><span class="line">        *j = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>();i != v.<span class="built_in">end</span>();i++)</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    运行结果：</span></span><br><span class="line"><span class="comment">          1,2,3,4,</span></span><br><span class="line"><span class="comment">          4,3,2,1,</span></span><br><span class="line"><span class="comment">          100,100,100,100,</span></span><br><span class="line"><span class="comment">*/</span>                </span><br></pre></td></tr></table></figure>
<h4 id="STL-迭代器是怎么删除元素的">STL 迭代器是怎么删除元素的</h4>
<p>这是主要考察迭代器失效的问题。</p>
<ol>
<li>
<p>对于序列容器 vector，deque 来说，使用 erase 后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase 返回下一个有效的迭代器；</p>
</li>
<li>
<p>对于关联容器 map，set 来说，使用了 erase 后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用 erase 之前，记录下一个元素的迭代器即可；</p>
</li>
<li>
<p>对于 list 来说，它使用了不连续分配的内存，并且它的 erase 方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。</p>
</li>
</ol>
<p><strong>解析</strong></p>
<p>容器上迭代器分类如下表（详细实现过程请翻阅相关资料详细了解）：</p>
<table><thead><tr><th align="center">容器</th><th align="center">容器上的迭代器类别</th></tr></thead><tbody><tr><td align="center">vector</td><td align="center">随机访问</td></tr><tr><td align="center">deque</td><td align="center">随机访问</td></tr><tr><td align="center">list</td><td align="center">双向</td></tr><tr><td align="center">set/multiset</td><td align="center">双向</td></tr><tr><td align="center">map/multimap</td><td align="center">双向</td></tr><tr><td align="center">stack</td><td align="center">不支持迭代器</td></tr><tr><td align="center">queue</td><td align="center">不支持迭代器</td></tr><tr><td align="center">priority_queue</td><td align="center">不支持迭代器</td></tr></tbody></table>
<h4 id="STL-中-resize-和-reserve-的区别">STL 中 resize 和 reserve 的区别</h4>
<ol>
<li>
<p>首先必须弄清楚两个概念：</p>
<ul>
<li>capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。不能通过下标等访问，因为此时容器中还没有创建任何对象。</li>
<li>size：指的是此时容器中实际的元素个数。可以通过下标访问 0 ~ (size - 1)范围内的对象。</li>
</ul>
</li>
<li>
<p>resize 和 reserve 区别主要有以下几点：</p>
<ul>
<li>resize 既分配了空间，也创建了对象；reserve 表示容器预留空间，但并不是真正的创建对象，需要通过 insert() 或 push_back() 等创建对象。</li>
<li>resize 既修改 capacity 大小，也修改 size 大小；reserve 只修改 capacity 大小，不修改 size 大小。</li>
<li>两者的形参个数不一样。 resize 带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve 只带一个参数，表示容器预留的大小。</li>
</ul>
</li>
</ol>
<p><strong>问题延伸：</strong></p>
<p>resize 和 reserve 既有差别，也有共同点。两个接口的<strong>共同点</strong>是**它们都保证了 vector 的空间大小 (capacity) 最少达到它的参数所指定的大小。**下面就他们的细节进行分析。</p>
<p>为实现 resize 的语义，resize 接口做了两个保证：</p>
<p>（1）保证区间 [0, new_size) 范围内数据有效，如果下标 index 在此区间内，vector[indext] 是合法的；</p>
<p>（2）保证区间 [0, new_size) 范围以外数据无效，如果下标 index 在区间外，vector[indext] 是非法的。</p>
<p>reserve 只是保证 vector 的空间大小 (capacity) 最少达到它的参数所指定的大小 n。在区间 [0, n) 范围内，如果下标是 index，vector[index] 这种访问有可能是合法的，也有可能是非法的，视具体情况而定。</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203162018325.png" alt="image-20220316201849161" style="zoom:80%;" />
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203162017280.png" alt="image-20220316201756078" style="zoom: 80%;" />
<p>以下是两个接口的源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size)</span> </span>&#123; </span><br><span class="line">	<span class="built_in">resize</span>(new_size, <span class="built_in">T</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (new_size &lt; <span class="built_in">size</span>()) </span><br><span class="line">        <span class="built_in">erase</span>(<span class="built_in">begin</span>() + new_size, <span class="built_in">end</span>()); <span class="comment">// erase区间范围以外的数据，确保区间以外的数据无效</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">end</span>(), new_size - <span class="built_in">size</span>(), x); <span class="comment">// 填补区间范围内空缺的数据，确保区间内的数据有效</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;initial capacity:&quot;</span>&lt;&lt;a.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;initial size:&quot;</span>&lt;&lt;a.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*resize改变capacity和size*/</span></span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">20</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;resize capacity:&quot;</span>&lt;&lt;a.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;resize size:&quot;</span>&lt;&lt;a.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">     <span class="comment">/*reserve改变capacity,不改变size*/</span></span><br><span class="line">    b.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;reserve capacity:&quot;</span>&lt;&lt;b.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;reserve size:&quot;</span>&lt;&lt;b.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    运行结果：</span></span><br><span class="line"><span class="comment">        initial capacity:0</span></span><br><span class="line"><span class="comment">        initial size:0</span></span><br><span class="line"><span class="comment">        resize capacity:20</span></span><br><span class="line"><span class="comment">        resize size:20</span></span><br><span class="line"><span class="comment">        reserve capacity:100</span></span><br><span class="line"><span class="comment">        reserve size:0</span></span><br><span class="line"><span class="comment">*/</span>    </span><br></pre></td></tr></table></figure>
<p>**注意：**如果 n 大于当前的 vector 的容量(是容量，并非 vector 的 size)，将会引起自动内存分配。所以现有的 pointer, references, iterators 将会失效。而内存的重新配置会很耗时间。</p>
<h4 id="STL-容器动态链接可能产生的问题？">STL 容器动态链接可能产生的问题？</h4>
<ol>
<li>
<p>可能产生的问题</p>
<p>容器是一种动态分配内存空间的一个变量集合类型变量。在一般的程序函数里，局部容器，参数传递容器，参数传递容器的引用，参数传递容器指针都是可以正常运行的，而在动态链接库函数内部使用容器也是没有问题的，但是给动态库函数传递容器的对象本身，则会出现内存堆栈破坏的问题。</p>
</li>
<li>
<p>产生问题的原因</p>
<p>容器和动态链接库相互支持不够好，动态链接库函数中使用容器时，参数中只能传递容器的引用，并且要保证容器的大小不能超出初始大小，否则导致容器自动重新分配，就会出现内存堆栈破坏问题。</p>
</li>
</ol>
<h4 id="map-和-unordered-map-的区别？底层实现">map 和 unordered_map 的区别？底层实现</h4>
<p>map和unordered_map的区别在于他们的<strong>实现基理不同</strong>。</p>
<ol>
<li>
<p>map实现机理</p>
<p>map内部实现了一个<strong>红黑树</strong>（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此 map 内部所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素。因此，对于 map 进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map 中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。</p>
</li>
<li>
<p>unordered_map实现机理</p>
<p>unordered_map内部实现了一个<strong>哈希表</strong>（也叫散列表），通过把关键码值映射到 Hash 表中一个位置来访问记录，查找时间复杂度可达 O(1)，其中在海量数据处理中有着广泛应用。因此，元素的排列顺序是无序的。</p>
</li>
</ol>
<h4 id="vector-和-list-的区别，分别适用于什么场景？"><strong>vector 和 list 的区别，分别适用于什么场景？</strong></h4>
<p>vector和list区别在于<strong>底层实现机理不同</strong>，因而特性和适用场景也有所不同。</p>
<p><strong>vector：一维数组</strong></p>
<ul>
<li>特点：元素在内存连续存放，动态数组，在<strong>堆</strong>中分配内存，元素连续存放，有保留内存，如果减少大小后内存也不会释放。</li>
<li>优点：和数组类似开辟一段连续的空间，并且支持随机访问，所以它的查找效率高其时间复杂度O(1)。</li>
<li>缺点：由于开辟一段连续的空间，所以插入删除会需要对数据进行移动比较麻烦，时间复杂度O（n），另外当空间不足时还需要进行扩容。</li>
<li>删除某个元素以后，该元素后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。</li>
<li><strong>对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了</strong></li>
</ul>
<p><strong>list：双向链表</strong></p>
<ul>
<li>特点：元素在<strong>堆</strong>中存放，每个元素都是存放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问。</li>
<li>优点：<strong>底层实现是双向链表</strong>，当对大量数据进行插入删除时，其时间复杂度O(1)。</li>
<li>缺点：底层没有连续的空间，只能通过指针来访问，所以查找数据需要遍历其时间复杂度O(n)，没有提供[]操作符的重载。</li>
<li><strong>在 list 内或在数个 list 间添加、移除和移动元素不会非法化迭代器或引用。迭代器仅在对应元素被删除时非法化。</strong></li>
</ul>
<p><strong>应用场景</strong></p>
<p>vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。</p>
<p>list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。</p>
<h4 id="vector-的实现原理">vector 的实现原理</h4>
<p>vector底层实现原理为<strong>一维数组</strong>（元素在空间连续存放）。</p>
<ol>
<li>
<p>新增元素</p>
<p>Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，再插入新增的元素。插入新的数据分在最后插入push_back和通过迭代器在任何位置插入，这里说一下通过迭代器插入，通过迭代器与第一个元素的距离知道要插入的位置，即 int index = iter-begin()。这个元素后面的所有元素都向后移动一个位置，在空出来的位置上存入新增的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新增元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(const_iterator iter, <span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> index = iter - <span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">if</span> (index &lt; size_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size_ == capacity_) &#123;</span><br><span class="line">      <span class="keyword">int</span> capa = <span class="built_in">calculateCapacity</span>();</span><br><span class="line">      <span class="built_in">newCapacity</span>(capa);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memmove</span>(buf + index + <span class="number">1</span>, buf + index, (size_ - index) * <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">    buf[index] = t;</span><br><span class="line">    size_++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除元素</p>
<p>删除和新增差不多，也分两种，删除最后一个元素pop_back和通过迭代器删除任意一个元素erase(iter)。通过迭代器删除还是先找到要删除元素的位置，即int index = iter-begin();这个位置后面的每个元素都想前移动一个元素的位置。同时我们知道erase不释放内存只初始化成默认值。</p>
<p>删除全部元素 clear：只是循环调用了erase，所以删除全部元素的时候，<strong>不释放内存。内存是在析构函数中释放的</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator iter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> index = iter - <span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">if</span> (index &lt; size_ &amp;&amp; size_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">memmove</span>(buf + index, buf + index + <span class="number">1</span>, (size_ - index) * <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">    buf[--size_] = <span class="built_in">T</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">iterator</span>(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>迭代器iteraotr</p>
<p>迭代器iteraotr是STL的一个重要组成部分,通过iterator可以很方便的存储集合中的元素.STL为每个集合都写了一个迭代器, 迭代器其实是对一个指针的包装,实现一些常用的方法,如++,–,!=,==,*,-&gt;等, 通过这些方法可以找到当前元素或是别的元素. vector是STL集合中比较特殊的一个,因为vector中的每个元素都是连续的,所以在自己实现vector的时候可以用指针代替。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器的实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Category</span>, <span class="keyword">class</span> _<span class="title">Ty</span>, <span class="keyword">class</span> _<span class="title">Diff</span> =</span> <span class="keyword">ptrdiff_t</span>,</span><br><span class="line">          <span class="class"><span class="keyword">class</span> _<span class="title">Pointer</span> =</span> _Ty *,</span><br><span class="line">          <span class="class"><span class="keyword">class</span> _<span class="title">Reference</span> =</span> _Ty &amp;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator</span> &#123;</span>  <span class="comment">// base type for all iterator classes</span></span><br><span class="line">  <span class="keyword">typedef</span> _Category iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> _Ty value_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Diff difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Diff distance_type;  <span class="comment">// retained</span></span><br><span class="line">  <span class="keyword">typedef</span> _Pointer pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Reference reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="STL-中的-map-的实现原理">STL 中的 map 的实现原理</h4>
<p>map是关联式容器，它们的底层容器都是<strong>红黑树</strong>。map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。</p>
<ol>
<li>
<p>map的特性如下</p>
<p>（1）map以RBTree作为底层容器；</p>
<p>（2）所有元素都是键+值存在；</p>
<p>（3）不允许键重复；</p>
<p>（4）所有元素是通过键进行自动排序的；</p>
<p>（5）map的键是不能修改的，但是其键对应的值是可以修改的。</p>
</li>
</ol>
<h4 id="C-的-vector-和-list中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？">C++ 的 vector 和 list中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？</h4>
<ol>
<li>
<p>迭代器和指针之间的区别</p>
<p>**迭代器不是指针，是类模板，表现的像指针。**他只是模拟了指针的一些功能，重载了指针的一些操作符，–&gt;、++、–等。迭代器封装了指针，是一个”可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象，<strong>本质是封装了原生指针</strong>，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p>
<p><strong>迭代器返回的是对象引用而不是对象的值</strong>，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。</p>
</li>
<li>
<p>vector和list特性</p>
<p><strong>vector特性</strong> 动态数组。元素在内存连续存放。随机存取任何元素都在常数时间完成。在尾端增删元素具有较大的性能（大部分情况下是常数时间）。</p>
<p><strong>list特性</strong> 双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。</p>
</li>
<li>
<p>vector增删元素</p>
<p>对于vector而言，删除某个元素以后，该元素后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。</p>
</li>
<li>
<p>list增删元素</p>
<p>对于list而言，删除某个元素，只有“指向被删除元素”的那个迭代器失效，其它迭代器不受任何影响。</p>
</li>
</ol>
<h4 id="map-和-set-有什么区别，分别又是怎么实现的？">map 和 set 有什么区别，分别又是怎么实现的？</h4>
<ol>
<li>
<p>set是一种关联式容器，其特性如下：</p>
<p>（1）set以RBTree作为底层容器</p>
<p>（2）所得元素的只有key没有value，value就是key</p>
<p>（3）不允许出现键值重复</p>
<p>（4）所有的元素都会被自动排序</p>
<p>（5）不能通过迭代器来改变set的值，因为set的值就是键，set的迭代器是const的</p>
</li>
<li>
<p>map和set一样是关联式容器，其特性如下：</p>
<p>（1）map以RBTree作为底层容器</p>
<p>（2）所有元素都是键+值存在</p>
<p>（3）不允许键重复</p>
<p>（4）所有元素是通过键进行自动排序的</p>
<p>（5）map的键是不能修改的，但是其键对应的值是可以修改的</p>
<p>综上所述，map和set<strong>底层实现</strong>都是红黑树；map和set的<strong>区别</strong>在于map的值不作为键，键和值是分开的。</p>
</li>
</ol>
<h4 id="push-back-和-emplace-back-的区别">push_back 和 emplace_back 的区别</h4>
<p>如果要将一个临时变量 push 到容器的末尾</p>
<ul>
<li>push_back() 需要先构造临时对象，再将这个对象拷贝到容器的末尾</li>
<li>emplace_back() 则直接在容器的末尾构造对象，这样就省去了拷贝的过程。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    str = <span class="built_in">to_string</span>(i);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">const</span> A&amp; other) : <span class="built_in">str</span>(other.str) &#123; cout &lt;&lt; <span class="string">&quot;拷贝构造&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  string str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;A&gt; vec;</span><br><span class="line">  vec.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">A</span>(i));  <span class="comment">//调用了10次构造函数和10次拷贝构造函数,</span></span><br><span class="line">                          <span class="comment">//        vec.emplace_back(i);</span></span><br><span class="line">    <span class="comment">//        //调用了10次构造函数一次拷贝构造函数都没有调用过</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="STL-中-vector-与-list-具体是怎么实现的？常见操作的时间复杂度是多少？">STL 中 vector 与 list 具体是怎么实现的？常见操作的时间复杂度是多少？</h4>
<ol>
<li>
<p>vector 一维数组（元素在内存连续存放）</p>
<p>是动态数组，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后，内存也不会释放；如果新增大小后小于当前大小时才会重新分配内存。</p>
<p>扩容方式：</p>
<p>a. 倍放开辟 2 倍的内存</p>
<p>b. 旧的数据开辟到新的内存</p>
<p>c. 释放旧的内存</p>
<p>d. 指向新内存</p>
</li>
<li>
<p>list 双向链表（元素存放在堆中）</p>
<p>元素存放在堆中，每个元素都是放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点，使得它的随机存取变得非常没有效率，因此它没有提供 [] 操作符的重载。但是由于链表的特点，它可以很有效的支持任意地方的删除和插入操作。</p>
<p>特点：</p>
<p>a. 随机访问不方便</p>
<p>b. 删除插入操作方便</p>
</li>
<li>
<p>常见时间复杂度</p>
<p>（1）vector插入、查找、删除时间复杂度分别为：O(n)、O(1)、O(n)；</p>
<p>（2）list插入、查找、删除时间复杂度分别为：O(1)、O(n)、O(1)。</p>
</li>
</ol>
<h3 id="C-新特性">C++ 新特性</h3>
<h4 id="C-11-的新特性有哪些">C++11 的新特性有哪些</h4>
<p>C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：</p>
<ol>
<li>
<p>语法的改进</p>
<p>（1）初始化列表，可以用于任何类型对象的初始化</p>
<p>（2）成员变量默认初始化</p>
<p>（3）<strong>auto关键字</strong>用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）</p>
<p>（4）<strong>decltype</strong> 求表达式的类型</p>
<p>（5）智能指针 shared_ptr</p>
<p>（6）空指针 nullptr（原来NULL）</p>
<p>（7）基于范围的 for 循环</p>
<p>（8）右值引用和move语义：让程序员有意识减少进行深拷贝操作</p>
<ul>
<li><code>delete</code> 函数：<code>= delete</code> 表示该函数不能被调用。</li>
<li><code>default</code> 函数：<code>= default</code> 表示编译器生成默认的函数，例如：生成默认的构造函数。</li>
<li><code>final</code>：final 用于修饰一个类，表示禁止该类进一步派生和虚函数的进一步重写</li>
<li><code>override</code>：用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了 override 但父类却没有这个虚函数，编译报错，使用 override 关键字可以避免开发者在重写基类函数时无意产生的错误</li>
<li><code>explicit</code>：explicit 专用于修饰构造函数，表示只能显式构造，不可以被隐式转换</li>
</ul>
</li>
<li>
<p>标准库扩充（往STL里新加进一些模板类，比较好用）</p>
<p>（9）无序容器（哈希表） 用法和功能同map一模一样，区别在于哈希表的效率更高</p>
<p>（10）正则表达式 可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串</p>
<p>（11）Lambda表达式</p>
</li>
</ol>
<h4 id="统一的初始化方法">统一的初始化方法</h4>
<p>C++98/03 可以使用初始化列表（initializer list）进行初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">long</span> l_arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>但是</strong>这种初始化方式的<strong>适用性非常狭窄</strong>，只有上面提到的这两种数据类型可以使用初始化列表。在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，实例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="keyword">int</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="keyword">const</span> Foo &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">a1</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line">    Foo a2 = <span class="number">123</span>;  <span class="comment">//error: &#x27;Foo::Foo(const Foo &amp;)&#x27; is private</span></span><br><span class="line">    Foo a3 = &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    Foo a4 &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> a5 = &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> a6 &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。a4 和 a6 的写法，是 C++98/03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。</p>
<h4 id="成员变量默认初始化">成员变量默认初始化</h4>
<p>好处：<strong>构建一个类的对象不需要用构造函数初始化成员变量</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序实例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">1234</span>; <span class="comment">//成员变量有一个初始值</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    cout &lt;&lt; b.m &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="auto关键字">auto关键字</h4>
<p>用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序实例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;::iterator i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> j = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，定义迭代器 i 的时候，类型书写比较冗长，容易出错。然而有了 auto 类型推导，我们大可不必这样，只写一个 auto 即可。</p>
<h4 id="decltype-求表达式的类型">decltype 求表达式的类型</h4>
<p>decltype 是 C++11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。</p>
<ul>
<li>为什么要有decltype</li>
</ul>
<p>因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。</p>
<p>auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> varname = value;</span><br><span class="line"><span class="keyword">decltype</span>(exp) varname = value;</span><br></pre></td></tr></table></figure>
<p>其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。</p>
<p>auto 根据 “=” 右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟&quot;=&quot;右边的 value 没有关系。</p>
<p>另外，<strong>auto 要求变量必须初始化，而 decltype 不要求</strong>。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。decltype 可以写成下面的形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(exp) varname;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decltype 用法举例</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">1</span>;  <span class="comment">//b 被推导成了 int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">10.8</span>) x = <span class="number">5.5</span>;  <span class="comment">//x 被推导成了 double</span></span><br><span class="line"><span class="keyword">decltype</span>(x + <span class="number">100</span>) y;  <span class="comment">//y 被推导成了 double</span></span><br></pre></td></tr></table></figure>
<h4 id="智能指针-shared-ptr">智能指针 shared_ptr</h4>
<p>和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//构建 2 个智能指针</span></span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">  <span class="comment">//输出 p2 指向的数据</span></span><br><span class="line">  cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">  p1.<span class="built_in">reset</span>();  <span class="comment">//引用计数减 1,p1为空指针</span></span><br><span class="line">  <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//以上操作，并不会影响 p2</span></span><br><span class="line">  cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">  <span class="comment">//判断当前和 p2 同指向的智能指针有多少个</span></span><br><span class="line">  cout &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    程序运行结果：</span></span><br><span class="line"><span class="comment">            10</span></span><br><span class="line"><span class="comment">            p1 为空</span></span><br><span class="line"><span class="comment">            10</span></span><br><span class="line"><span class="comment">            1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="空指针-nullptr（原来NULL）">空指针 nullptr（原来NULL）</h4>
<p>nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullptr 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。值得一提的是，<strong>nullptr 可以被隐式转换成任意的指针类型</strong>。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * a1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">char</span> * a2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">double</span> * a3 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>显然，不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int_、char_ 以及 double* 指针类型。另外，通过将指针初始化为 nullptr，可以很好地解决 NULL 遗留的问题，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isnull</span><span class="params">(<span class="keyword">void</span> *c)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void*c&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isnull</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">isnull</span>(<span class="literal">NULL</span>); <span class="comment">// NULL 指针是一个定义在标准库中的值为零的常量</span></span><br><span class="line">    <span class="built_in">isnull</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*    程序运行结果：        </span></span><br><span class="line"><span class="comment">        int n</span></span><br><span class="line"><span class="comment">        void*c</span></span><br><span class="line"><span class="comment">*/</span>          </span><br></pre></td></tr></table></figure>
<h4 id="基于范围的for循环">基于范围的for循环</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (dataType rangeVariable : array)</span><br><span class="line">    statement;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string planets []= &#123; <span class="string">&quot;Mercury&quot;</span>, <span class="string">&quot;Venus&quot;</span>, <span class="string">&quot;Earth&quot;</span>, <span class="string">&quot;Mars&quot;</span>, <span class="string">&quot;Jupiter&quot;</span>, <span class="string">&quot;Saturn&quot;</span>, <span class="string">&quot;Uranus&quot;</span>, <span class="string">&quot;Neptune&quot;</span>, <span class="string">&quot;Pluto(a dwarf planet)&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">// Display the values in the array</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Here are the planets: \n &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (string val : planets)</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>
<h4 id="右值引用和move语义">右值引用和move语义</h4>
<ol>
<li>
<p>右值引用</p>
<p>C++98/03 标准中就有引用，使用 “&amp;” 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<p>如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用。</p>
<p>注意，虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b = num;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p>
<p>为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。</p>
<p>需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>和常量左值引用不同的是，<strong>右值引用还可以对右值进行修改</strong>。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*    程序运行结果：        </span></span><br><span class="line"><span class="comment">        100    </span></span><br><span class="line"><span class="comment">*/</span>          </span><br></pre></td></tr></table></figure>
<p>另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; a = <span class="number">10</span>;<span class="comment">//编译器不会报错</span></span><br></pre></td></tr></table></figure>
<p>但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。</p>
</li>
<li>
<p>move语义</p>
<p>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，就是<strong>将某个左值强制转化为右值</strong>。基于 move() 函数特殊的功能，其常用于实现移动语义。move() 函数的用法也很简单，其语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">move</span>( arg ) <span class="comment">//其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序实例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">first</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">first</span>() : <span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>)) &#123; cout &lt;&lt; <span class="string">&quot;construct!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="comment">//移动构造函数</span></span><br><span class="line">  <span class="built_in">first</span>(first &amp;&amp;d) : <span class="built_in">num</span>(d.num) &#123;</span><br><span class="line">    d.num = <span class="literal">NULL</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;first move construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">  <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">second</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">second</span>() : <span class="built_in">fir</span>() &#123;&#125;</span><br><span class="line">  <span class="comment">//用 first 类的移动构造函数初始化 fir</span></span><br><span class="line">  <span class="built_in">second</span>(second &amp;&amp;sec) : <span class="built_in">fir</span>(<span class="built_in">move</span>(sec.fir)) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;second move construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">//这里也应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">  first fir;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  second oth;</span><br><span class="line">  second oth2 = <span class="built_in">move</span>(oth);</span><br><span class="line">  <span class="comment">// cout &lt;&lt; *oth.fir.num &lt;&lt; endl;   //程序报运行时错误</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    程序运行结果：</span></span><br><span class="line"><span class="comment">          construct!</span></span><br><span class="line"><span class="comment">        first move construct!</span></span><br><span class="line"><span class="comment">        second move construct</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="C-右值引用与转移语义">C++ 右值引用与转移语义</h4>
<ol>
<li>
<p>右值引用</p>
<p>一般来说，不能取地址的表达式，就是右值引用，能取地址的，就是左值。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> &#125;;</span><br><span class="line">A &amp; r = <span class="built_in">A</span>(); <span class="comment">//error,A()是无名变量，是右值</span></span><br><span class="line">A &amp;&amp; r = <span class="built_in">A</span>(); <span class="comment">//ok,r是右值引用</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>转移语义</p>
<p>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，<strong>就是将某个左值强制转化为右值</strong>。基于 move() 函数特殊的功能，其常用于实现移动语义。</p>
</li>
</ol>
<h4 id="无序容器（哈希表）">无序容器（哈希表）</h4>
<p>用法和功能同map一模一样，区别在于哈希表的效率更高。</p>
<p>(1) 无序容器具有以下 2 个特点：</p>
<p>a. 无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，</p>
<p>b. 和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。</p>
<p>(2) 和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。功能如下表：</p>
<table><thead><tr><th>无序容器</th><th>功能</th></tr></thead><tbody><tr><td>unordered_map</td><td>存储键值对 &lt;key, value&gt; 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。</td></tr><tr><td>unordered_multimap</td><td>和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</td></tr><tr><td>unordered_set</td><td>不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</td></tr><tr><td>unordered_multiset</td><td>和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。</td></tr></tbody></table> 
<h4 id="正则表达式">正则表达式</h4>
<p>可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串。常用符号的意义如下：</p>
<table><thead><tr><th>符号</th><th>意义</th></tr></thead><tbody><tr><td>^</td><td>匹配行的开头</td></tr><tr><td>$</td><td>匹配行的结尾</td></tr><tr><td>.</td><td>匹配任意单个字符</td></tr><tr><td>[…]</td><td>匹配[]中的任意一个字符</td></tr><tr><td>(…)</td><td>设定分组</td></tr><tr><td>\</td><td>转义字符</td></tr><tr><td>\d</td><td>匹配数字[0-9]</td></tr><tr><td>\D</td><td>\d 取反</td></tr><tr><td>\w</td><td>匹配字母[a-z]，数字，下划线</td></tr><tr><td>\W</td><td>\w 取反</td></tr><tr><td>\s</td><td>匹配空格</td></tr><tr><td>\S</td><td>\s 取反</td></tr><tr><td>+</td><td>前面的元素重复1次或多次</td></tr><tr><td>*</td><td>前面的元素重复任意次</td></tr><tr><td>?</td><td>前面的元素重复0次或1次</td></tr><tr><td>{n}</td><td>前面的元素重复n次</td></tr><tr><td>{n,}</td><td>前面的元素重复至少n次</td></tr><tr><td>{n,m}</td><td>前面的元素重复至少n次，至多m次</td></tr><tr><td>|</td><td>逻辑或</td></tr></tbody></table>
<h4 id="Lambda匿名函数">Lambda匿名函数</h4>
<p>所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。</p>
<p>我们可以忽略参数列表和返回类型，但<strong>必须永远包含捕获列表和函数体</strong>，不能有默认参数</p>
<p>定义</p>
<p>lambda 匿名函数很简单，可以套用如下的语法格式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[外部变量访问方式说明符] (参数) <span class="keyword">mutable</span> <span class="keyword">noexcept</span>/<span class="keyword">throw</span>() -&gt; 返回值类型  &#123;  </span><br><span class="line">	函数体;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中各部分的含义分别为：</p>
<ol>
<li>
<p>[外部变量方位方式说明符]<br>
[ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。<br>
所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。</p>
</li>
<li>
<p>(参数)<br>
和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；</p>
</li>
<li>
<p><strong>mutable</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203121149683.png" alt="image-20220222163614001" style="zoom:67%;" />
<p>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的原来值，修改的是拷贝的值。而如果想修改它们，就必须使用 mutable 关键字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">auto</span> f = [v]() <span class="keyword">mutable</span> &#123; <span class="comment">// 如果不加mutable，会报错：表达式必须是可修改的左值</span></span><br><span class="line">		<span class="keyword">return</span> ++v;</span><br><span class="line">	&#125;;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl; <span class="comment">// 21</span></span><br><span class="line">	cout &lt;&lt; v &lt;&lt; endl;   <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**注意:**对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/image-20220222163418189.png" alt="image-20220222163418189" style="zoom:80%;" />
</li>
<li>
<p>noexcept/throw()<br>
可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。<strong>默认情况下，lambda 函数的函数体中可以抛出任何类型的异常</strong>。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。</p>
</li>
<li>
<p>-&gt; 返回值类型<br>
指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略&quot;-&gt; 返回值类型&quot;。</p>
</li>
<li>
<p>函数体<br>
和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。</p>
</li>
</ol>
<h4 id="C-中智能指针和指针的区别是什么？">C++ 中智能指针和指针的区别是什么？</h4>
<ol>
<li>
<p>智能指针</p>
<p>如果在程序中使用 new 从堆（自由存储区）分配内存，等到不需要时，应使用 delete 将其释放。C++ 引用了智能指针 auto_ptr，以帮助自动完成这个过程。随后的编程体验（尤其是使用STL）表明，需要有更精致的机制。基于程序员的编程体验和BOOST库提供的解决方案，C++11 摒弃了 auto_ptr，并新增了三种智能指针：unique_ptr、shared_ptr 和 weak_ptr 。所有新增的智能指针都能与STL容器和移动语义协同工作。</p>
</li>
<li>
<p>指针</p>
<p>C 语言规定所有变量在使用前必须先定义，指定其类型，并按此分配内存单元。指针变量不同于整型变量和其他类型的变量，它是专门用来存放地址的，所以必须将它定义为“指针类型”。</p>
</li>
<li>
<p>智能指针和普通指针的区别</p>
<ul>
<li>
<p>智能指针实际上是对普通指针加了一层封装机制</p>
</li>
<li>
<p><strong>它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期</strong>。</p>
</li>
<li>
<p>智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源</p>
</li>
</ul>
</li>
</ol>
<h4 id="C-中的智能指针有哪些？分别解决的问题以及区别？">C++中的智能指针有哪些？分别解决的问题以及区别？</h4>
<p>智能指针是为了解决动态内存分配时带来的<strong>内存泄漏</strong>以及<strong>多次释放同一块内存空间</strong>而提出的。C++11 中封装在了 <code>&lt;memory&gt;</code> 头文件中。</p>
<p>C++11 中智能指针包括以下三种：</p>
<ul>
<li><strong>共享指针（shared_ptr）</strong>：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 <code>use_count()</code> 查看资源的所有者的个数，可以通过 <code>unique_ptr</code>、<code>weak_ptr</code> 来构造，调用 <code>release()</code> 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。</li>
<li><strong>独占指针（unique_ptr）</strong>：独享所有权的智能指针，资源只能被一个指针占有，<strong>该指针不能拷贝构造和赋值</strong>。但可以进行移动构造和移动赋值构造（调用 <code>move()</code> 函数），即一个 <code>unique_ptr</code> 对象赋值给另一个 <code>unique_ptr</code> 对象，可以通过该方法进行赋值。</li>
<li><strong>弱指针（weak_ptr）</strong>：指向 <code>share_ptr</code> 指向的对象，能够解决由shared_ptr带来的循环引用问题。</li>
</ul>
<p><strong>智能指针的实现原理：</strong> 计数原理。</p>
<ol>
<li>
<p>C++中的智能指针有4种，分别为：<strong>shared_ptr、unique_ptr、weak_ptr、auto_ptr</strong>，其中auto_ptr被C++11弃用。</p>
</li>
<li>
<p>使用智能指针的原因</p>
<p>申请的空间（即new出来的空间），在使用结束时，需要delete掉，否则会形成内存碎片。在程序运行期间，new 出来的对象，在析构函数中 delete 掉，但是这种方法不能解决所有问题，因为有时候 new 发生在某个全局函数里面，该方法会给程序员造成精神负担。此时，智能指针就派上了用场。</p>
<p>使用智能指针可以很大程度上避免这个问题，因为<strong>智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源</strong>。</p>
<p>所以，<strong>智能指针的作用原理就是在函数结束时自动释放内存空间，避免了手动释放内存空间。</strong></p>
</li>
<li>
<p>四种指针分别解决的问题以及各自特性如下：</p>
<p>（1）auto_ptr（C++98的方案，C++11已经弃用）</p>
<p>采用所有权模式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I reigned loney as a cloud.&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; p2;</span><br><span class="line">p2=p1; <span class="comment">//auto_ptr不会报错</span></span><br></pre></td></tr></table></figure>
<p>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：<strong>存在潜在的内存崩溃问题</strong>。</p>
<p>（2）unique_ptr（替换auto_ptr）</p>
<p>unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露，例如，以new创建对象后因为发生异常而忘记调用delete时的情形特别有用。</p>
<p>采用所有权模式，和上面例子一样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I reigned loney as a cloud.&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; p4;</span><br><span class="line">p4=p3; <span class="comment">//此时不会报错</span></span><br></pre></td></tr></table></figure>
<p>编译器认为P4=P3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。 另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;hello world&quot;</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;string&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      <span class="comment">// #1 not allowed</span></span><br><span class="line">unique_ptr&lt;string&gt; pu3;</span><br><span class="line">pu3 = unique_ptr&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;You&quot;</span>));   <span class="comment">// #2 allowed</span></span><br></pre></td></tr></table></figure>
<p>其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</p>
<p>**注意：**如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; ps1, ps2;</span><br><span class="line">ps1 = <span class="built_in">demo</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">ps2 = <span class="built_in">move</span>(ps1);</span><br><span class="line">ps1 = <span class="built_in">demo</span>(<span class="string">&quot;alexia&quot;</span>);</span><br><span class="line">cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>（3）shared_ptr（非常好使）</p>
<p>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr , unique_ptr , weak_ptr 来构造。当我们调用 release() 时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性( auto_ptr 是独占的), 在使用<strong>引用计数</strong>的机制上提供了可以共享所有权的智能指针。</p>
<p><strong>成员函数：</strong></p>
<ul>
<li>
<p><strong>use_count</strong> 返回引用计数的个数</p>
</li>
<li>
<p><strong>unique</strong> 返回是否是独占所有权( use_count 为 1)</p>
</li>
<li>
<p><strong>swap</strong> 交换两个 shared_ptr 对象(即交换所拥有的对象)</p>
</li>
<li>
<p><strong>reset</strong> 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p>
</li>
<li>
<p><strong>get</strong>  返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr sp(new int(1)); sp 与 sp.get()是等价的</p>
</li>
</ul>
<p>（4）weak_ptr</p>
<p>weak_ptr 是一种不控制所指向对象生存期的智能指针，它指向由一个 shared_ptr 管理的对象。将一个 weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数。 一旦最后一个指向对象的 shared_ptr 被销毁，对象就会被释放。 即使有 weak_ptr 指向对象，对象也还是会被释放。</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/image-20220222165322539.png" alt="image-20220222165322539" style="zoom:80%;" />
<p>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr 是用来解决 shared_ptr 相互引用时的死锁问题，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0, 资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和 shared_ptr 之间可以相互转化，shared_ptr 可以直接赋值给它，它可以通过调用 lock 函数来获得 shared_ptr。</p>
<p>由于对象可能不存在，我们不能使用 weak_ptr 直接访问对象，而必须调用 lock 。此函数检查 weak_ptr 指向的对象是否仍存在。如果存在， lock 返回一个指向共享对象的 shared_ptr。与任何其他 shared_ptr 类似，只要此 shared_ptr 存在，它所指向的底层对象也就会一直存在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  shared_ptr&lt;B&gt; pb_;</span><br><span class="line">  ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A delete\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  shared_ptr&lt;A&gt; pa_;</span><br><span class="line">  ~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B delete\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">  <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">  pb-&gt;pa_ = pa;</span><br><span class="line">  pa-&gt;pb_ = pb;</span><br><span class="line">  cout &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fun</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb; 这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</p>
<p><strong>注意</strong>：我们不能通过 weak_ptr 直接访问对象的方法，比如 B 对象中有一个方法 print() , 我们不能这样访问，pa-&gt;pb_-&gt;print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr，如：shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print();</p>
</li>
</ol>
<h4 id="简述-C-中智能指针的特点">简述 C++ 中智能指针的特点</h4>
<ol>
<li>
<p>C++中的智能指针有4种，分别为：<strong>shared_ptr、unique_ptr、weak_ptr、auto_ptr</strong>，其中auto_ptr被C++11弃用。</p>
</li>
<li>
<p><strong>为什么要使用智能指针</strong>：智能指针的作用是管理一个指针，因为存在申请的空间在函数结束时忘记释放，造成内存泄漏的情况。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，自动释放资源。</p>
</li>
<li>
<p>四种指针各自特性</p>
<p><strong>（1）auto_ptr</strong></p>
<p>auto指针存在的问题是，两个智能指针同时指向一块内存，就会两次释放同一块资源，自然报错。</p>
<p><strong>（2）unique_ptr</strong></p>
<p>unique指针规定一个智能指针独占一块内存资源。当两个智能指针同时指向一块内存，编译报错。</p>
<p>实现原理： <strong>将拷贝构造函数和赋值拷贝构造函数申明为 private 或 delete</strong> 。不允许拷贝构造函数和赋值操作符，但是支持移动构造函数，通过 std:move 把一个对象指针变成右值之后可以移动给另一个 unique_ptr</p>
<p><strong>（3）shared_ptr</strong></p>
<p>共享指针可以实现多个智能指针指向相同对象，该对象和其相关资源会在引用为0时被销毁释放。</p>
<p>实现原理：有一个<strong>引用计数</strong>的指针类型变量，专门用于引用计数，使用拷贝构造函数和赋值拷贝构造函数时，引用计数加1，当引用计数为0时，释放资源。</p>
</li>
</ol>
<p>**注意：**weak_ptr、shared_ptr 存在一个问题，当两个shared_ptr指针相互引用时，那么这两个指针的引用计数不会下降为0，资源得不到释放。因此引入weak_ptr，<strong>weak_ptr是弱引用，weak_ptr的构造和析构不会引起引用计数的增加或减少</strong>。</p>
<h4 id="weak-ptr-能不能知道对象计数为-0，为什么？">weak_ptr 能不能知道对象计数为 0，为什么？</h4>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/image-20220222172232898.png" alt="image-20220222172232898" style="zoom:80%;" />
<p>可以调用函数查看与 weak_ptr 共享对象的 shared_ptr 的数量</p>
<p>weak_ptr 是一种不控制对象生命周期的智能指针，它指向一个shared_ptr管理的对象。进行该对象管理的是那个引用的shared_ptr。weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的只是为了配合 shared_ptr 而引入的一种智能指针，配合 shared_ptr 工作，它只可以从一个 shared_ptr 或者另一个 weak_ptr 对象构造，<strong>它的构造和析构不会引起计数的增加或减少</strong>。</p>
<h4 id="weak-ptr-如何解决-shared-ptr-的循环引用问题？">weak_ptr 如何解决 shared_ptr 的循环引用问题？</h4>
<p>为了解决循环引用导致的内存泄漏，引入了弱指针 weak_ptr，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但是不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p>
<h4 id="share-ptr-怎么知道跟它共享对象的指针释放了">share_ptr 怎么知道跟它共享对象的指针释放了</h4>
<p>多个 shared_ptr 对象可以同时托管一个指针，系统会维护一个引用计数。当无 shared_ptr 托管该指针时，delete 该指针。</p>
<h4 id="shared-ptr-线程安全性，原理">shared_ptr 线程安全性，原理</h4>
<p>多线程环境下，调用不同 shared_ptr 实例的成员函数是不需要额外的同步手段的，即使这些 shared_ptr 拥有的是同样的对象。</p>
<p>但是如果多线程访问（有写操作）同一个shared_ptr，则需要同步，否则就会有 race condition 发生。也可以使用 shared_ptr overloads of atomic functions 来防止 race condition 的发生。</p>
<p><strong>多个线程同时读同一个 shared_ptr 对象是线程安全的，但是如果是多个线程对同一个 shared_ptr 对象进行读和写，则需要加锁。</strong></p>
<p>多线程读写 shared_ptr 所指向的同一个对象，不管是相同的 shared_ptr 对象，还是不同的 shared_ptr 对象，也需要加锁保护。例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序实例</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">long</span>&gt; global_instance = make_shared&lt;<span class="keyword">long</span>&gt;(<span class="number">0</span>);</span><br><span class="line">std::mutex g_i_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_fcn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// std::lock_guard&lt;std::mutex&gt; lock(g_i_mutex);</span></span><br><span class="line">  <span class="comment">// shared_ptr&lt;long&gt; local = global_instance;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">    *global_instance = *global_instance + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//*local = *local + 1;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">thread1</span><span class="params">(thread_fcn)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">thread2</span><span class="params">(thread_fcn)</span></span>;</span><br><span class="line"></span><br><span class="line">  thread1.<span class="built_in">join</span>();</span><br><span class="line">  thread2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;*global_instance is &quot;</span> &lt;&lt; *global_instance &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在线程函数thread_fcn的for循环中，2个线程同时对global_instance进行加1的操作。这就是典型的非线程安全的场景，最后的结果是未定的，运行结果如下：</p>
<p>*global_instance is 197240539</p>
<p>如果使用的是每个线程的局部shared_ptr对象local，因为这些local指向相同的对象，因此结果也是未定的，运行结果如下： *global_instance is 160285803</p>
<p>因此，这种情况下必须加锁，将thread_fcn中的第一行代码的注释去掉之后，不管是使用global_instance，还是使用local，得到的结果都是：</p>
<p>*global_instance is 200000000</p>
<h4 id="一个-unique-ptr-怎么赋值给另一个-unique-ptr-对象？">一个 unique_ptr 怎么赋值给另一个 unique_ptr 对象？</h4>
<p>借助 <code>std::move()</code> 可以实现将一个 <code>unique_ptr</code> 对象赋值给另一个 <code>unique_ptr</code> 对象，其目的是实现所有权的转移。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A 作为一个类 </span></span><br><span class="line"><span class="function">std::unique_ptr&lt;A&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">std::unique_ptr&lt;A&gt; ptr2 = std::<span class="built_in">move</span>(ptr1);</span><br></pre></td></tr></table></figure>
<h4 id="智能指针有没有内存泄露的情况">智能指针有没有内存泄露的情况</h4>
<p>智能指针有内存泄露的情况发生。</p>
<ol>
<li>
<p>智能指针发生内存泄露的情况</p>
<p>当两个对象同时使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄露。</p>
</li>
<li>
<p>智能指针的内存泄漏如何解决？<br>
为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但是不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序实例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::shared_ptr&lt;Child&gt; ChildPtr;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(std::shared_ptr&lt;Child&gt; child)</span> </span>&#123; <span class="keyword">this</span>-&gt;ChildPtr = child; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ChildPtr.<span class="built_in">use_count</span>()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Parent</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::shared_ptr&lt;Parent&gt; ParentPtr;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setPartent</span><span class="params">(std::shared_ptr&lt;Parent&gt; parent)</span> </span>&#123; <span class="keyword">this</span>-&gt;ParentPtr = parent; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ParentPtr.<span class="built_in">use_count</span>()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Child</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line">  std::weak_ptr&lt;Child&gt; wpc;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Parent&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Parent)</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Child&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Child)</span></span>;</span><br><span class="line">    p-&gt;<span class="built_in">setChild</span>(c);</span><br><span class="line">    c-&gt;<span class="built_in">setPartent</span>(p);</span><br><span class="line">    wpp = p;</span><br><span class="line">    wpc = c;</span><br><span class="line">    std::cout &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; c.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; wpp.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; wpc.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*    程序运行结果：</span></span><br><span class="line"><span class="comment">        2</span></span><br><span class="line"><span class="comment">        2</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，parent有一个shared_ptr类型的成员指向孩子，而child也有一个shared_ptr类型的成员指向父亲。然后在创建孩子和父亲对象时也使用了智能指针c和p，随后将c和p分别又赋值给child的智能指针成员parent和parent的智能指针成员child。从而形成了一个循环引用。</p>
<h4 id="循环引用的解决方法：weak-ptr">循环引用的解决方法：<code>weak_ptr</code></h4>
<p>循环引用：该被调用的析构函数没有被调用，从而出现了内存泄漏。</p>
<ul>
<li><code>weak_ptr</code> 对被 <code>shared_ptr</code> 管理的对象存在 <strong>非拥有性（弱）引用</strong>，在访问所引用的对象前必须先转化为 <code>shared_ptr</code>；</li>
<li><code>weak_ptr</code> 用来打断 <code>shared_ptr</code> 所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），<code>shared_ptr</code> 引用计数无法抵达 0，内存被泄露；令环中的指针之一为弱指针可以避免该情况；</li>
<li><code>weak_ptr</code> 用来表达临时所有权的概念，当某个对象只有存在时才需要被访问，而且随时可能被他人删除，可以用 <code>weak_ptr</code> 跟踪该对象；需要获得所有权时将其转化为 <code>shared_ptr</code>，此时如果原来的 <code>shared_ptr</code> 被销毁，则该对象的生命期被延长至这个临时的 <code>shared_ptr</code> 同样被销毁。</li>
</ul>
<h4 id="简述一下-C-11-中四种类型转换">简述一下 C++11 中四种类型转换</h4>
<p>C++中四种类型转换分别为<strong>const_cast、static_cast、dynamic_cast、reinterpret_cast</strong>，四种转换功能分别如下：</p>
<ol>
<li>
<p>const_cast</p>
<p>将 const 变量转为非 const</p>
</li>
<li>
<p>static_cast</p>
<p>最常用，可以用于各种隐式转换，比如非 const 转 const，static_cast 可以用于类向上转换，但向下转换能成功但是不安全。</p>
</li>
<li>
<p>dynamic_cast</p>
<p>只能用于含有虚函数的类转换，用于类向上和向下转换</p>
<p>**向上转换：**指派生类类向基类转换。</p>
<p>**向下转换：**指基类向派生类类转换。</p>
<p>这两种转换，子类包含父类，当父类转换成子类时可能出现非法内存访问的问题。</p>
<p>dynamic_cast 通过判断变量运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。dynamic_cast 可以做类之间上下转换，转换的时候会进行类型检查，类型相等成功转换，类型不等转换失败。运用 RTTI 技术，RTTI 是 ”Runtime Type Information” 的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法。在 c++ 层面主要体现在 dynamic_cast 和 typeid ，vs 中虚函数表的 -1 位置存放了指向 type_info 的指针，对于存在虚函数的类型，dynamic_cast 和 typeid 都会去查询 type_info。</p>
</li>
<li>
<p>reinterpret_cast</p>
<p>reinterpret_cast 可以做任何类型的转换，不过不对转换结果保证，容易出问题。</p>
<p>**注意：**为什么不用 C 的强制转换：C 的强制转换表面上看起来功能强大什么都能转，但是转换不够明确，<strong>不能进行错误检查，容易出错</strong>。</p>
</li>
</ol>
<h4 id="C-11-中-auto-的具体用法">C++ 11 中 auto 的具体用法</h4>
<p>auto用于定义变量，编译器可以自动判断变量的类型。auto主要有以下几种用法：</p>
<ol>
<li>
<p>auto的基本使用方法</p>
<p>（1）基本使用语法如下</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> name = value; <span class="comment">//name 是变量的名字，value 是变量的初始值</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> auto 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。或者说，C++ 中的变量必须是有明确类型的，只是这个类型是由编译器自己推导出来的。</p>
<p>（2）程序实例如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> n = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">auto</span> f = <span class="number">12.8</span>; </span><br><span class="line"><span class="keyword">auto</span> p = &amp;n; </span><br><span class="line"><span class="keyword">auto</span> url = <span class="string">&quot;www.123.com&quot;</span>;</span><br><span class="line"></span><br><span class="line"> a. 第 <span class="number">1</span> 行中，<span class="number">10</span> 是一个整数，默认是 <span class="keyword">int</span> 类型，所以推导出变量 n 的类型是 <span class="keyword">int</span>。</span><br><span class="line"> b. 第 <span class="number">2</span> 行中，<span class="number">12.8</span> 是一个小数，默认是 <span class="keyword">double</span> 类型，所以推导出变量 f 的类型是 <span class="keyword">double</span>。</span><br><span class="line"> c. 第 <span class="number">3</span> 行中，&amp;n 的结果是一个 <span class="keyword">int</span>* 类型的指针，所以推导出变量 f 的类型是 <span class="keyword">int</span>*。</span><br><span class="line"> d. 第 <span class="number">4</span> 行中，由双引号`<span class="string">&quot;&quot;</span>`包围起来的字符串是 <span class="keyword">const</span> <span class="keyword">char</span>* 类型，所以推导出变量 url 的类型是 <span class="keyword">const</span> <span class="keyword">char</span>*，也即一个常量指针。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>auto和 const 的结合使用</p>
<p>（1） auto 与 const 结合的用法</p>
<p>a. 当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性；</p>
<p>b. 当类型为引用时，auto 的推导结果将保留表达式的 const 属性。</p>
<p>（2）程序实例如下</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> n = x;  <span class="comment">//n 为 const int ，auto 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> f = n;      <span class="comment">//f 为 int，auto 被推导为 int（const 属性被抛弃）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;r1 = x;  <span class="comment">//r1 为 const int&amp; 类型，auto 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r2 = r1;  <span class="comment">//r2 为 const int&amp; 类型，auto 被推导为 const int 类型</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 auto 定义迭代器</p>
<p>在使用 stl 容器的时候，需要使用迭代器来遍历容器里面的元素；不同容器的迭代器有不同的类型，在定义迭代器时必须指明。而迭代器的类型有时候比较复杂，请看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt; v;</span><br><span class="line">    <span class="comment">//vector&lt; vector&lt;int&gt; &gt;::iterator i = v.begin();</span></span><br><span class="line">    <span class="keyword">auto</span> i = v.<span class="built_in">begin</span>();  <span class="comment">//使用 auto 代替具体的类型,该句比上一句简洁,根据表达式 v.begin() 的类型（begin() 函数的返回值类型）来推导出变量i的类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用于泛型编程</p>
<p>auto 的另一个应用就是当我们不知道变量是什么类型，或者不希望指明具体类型的时候，比如泛型编程中。请看下面例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">get</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;www.123.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> val = T::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    func&lt;A&gt;();</span><br><span class="line">    func&lt;B&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*        运行结果：</span></span><br><span class="line"><span class="comment">            100</span></span><br><span class="line"><span class="comment">            www.123.com</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>本例中的模板函数 func() 会调用所有类的静态函数 get()，并对它的返回值做统一处理，但是 get() 的返回值类型并不一样，而且不能自动转换。这种要求在以前的 C++ 版本中实现起来非常的麻烦，需要额外增加一个模板参数，并在调用时手动给该模板参数赋值，用以指明变量 val 的类型。但是有了 auto 类型自动推导，编译器就根据 get() 的返回值自己推导出 val 变量的类型，就不用再增加一个模板参数了。</p>
</li>
</ol>
<h4 id="C-11-中的可变参数模板新特性">C++11 中的可变参数模板新特性</h4>
<p>可变参数模板(variadic template)使得编程者能够创建这样的模板函数和模板类，即可接受可变数量的参数。例如要编写一个函数，它可接受任意数量的参数，参数的类型只需是cout能显示的即可，并将参数显示为用逗号分隔的列表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">14</span>;</span><br><span class="line"><span class="keyword">double</span> x = <span class="number">2.71828</span>;</span><br><span class="line">std::string mr = <span class="string">&quot;Mr.String objects!&quot;</span>;</span><br><span class="line"><span class="built_in">show_list</span>(n, x);</span><br><span class="line"><span class="built_in">show_list</span>(x*x, <span class="string">&#x27;!&#x27;</span>, <span class="number">7</span>, mr); <span class="comment">//这里的目标是定义show_list()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*    运行结果：</span></span><br><span class="line"><span class="comment">          14, 2.71828</span></span><br><span class="line"><span class="comment">          7.38905， !, 7, Mr.String objects!</span></span><br><span class="line"><span class="comment">*/</span>    </span><br></pre></td></tr></table></figure>
<p>要创建可变参数模板，需要理解几个要点：</p>
<p>（1）模板参数包（parameter pack）；</p>
<p>（2）函数参数包；</p>
<p>（3）展开（unpack）参数包；</p>
<p>（4）<strong>递归。</strong></p>
<h3 id="C-关键字、库函数">C++ 关键字、库函数</h3>
<h4 id="sizeof-和-strlen-的区别">sizeof 和 strlen 的区别</h4>
<ul>
<li>
<p><code>strlen</code> 是头文件 <code>&lt;cstring&gt;</code> 中的函数，<code>sizeof</code> 是 C++ 中的运算符。</p>
</li>
<li>
<p><code>strlen</code> 测量的是字符串的实际长度（其源代码如下），以 <code>\0</code> 结束。而 <code>sizeof</code> 测量的是字符数组的分配大小。<br>
<code>strlen</code> 源代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str++)</span><br><span class="line">        ++length;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(arr) &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) &lt;&lt; endl; <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>若字符数组 arr 作为函数的形参，<code>sizeof(arr)</code> 中 arr 被当作字符指针来处理，<code>strlen(arr)</code> 中 arr 依然是字符数组，从下述程序的运行结果中就可以看出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">size_of</span><span class="params">(<span class="keyword">char</span> arr[])</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) &lt;&lt; endl; <span class="comment">// warning: &#x27;sizeof&#x27; on array function parameter &#x27;arr&#x27; will return size of &#x27;char*&#x27; .</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(arr) &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">20</span>] = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">size_of</span>(arr); <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>strlen</code> 本身是库函数，因此在程序运行过程中，计算长度；而 <code>sizeof</code> 在编译时，计算长度；</p>
</li>
<li>
<p><code>sizeof</code> 的参数可以是类型，也可以是变量；<code>strlen</code> 的参数必须是 <code>char*</code> 类型的变量。</p>
</li>
</ul>
<h4 id="lambda-表达式（匿名函数）的具体应用和使用场景">lambda 表达式（匿名函数）的具体应用和使用场景</h4>
<ul>
<li>
<p>lambda 表达式是一个可调度的代码单元，可以视为一个未命名的内部函数</p>
</li>
<li>
<p><strong>lambda 函数是一个函数对象，编译器在编译时会生成一个 lambda 对象的类，然后再生成一个该命令未命名的对象</strong></p>
</li>
</ul>
<p>lambda 的形式如下：<br>
[捕获列表] (参数列表) -&gt; 返回类型 { 函数部分 }<br>
[capture list] (parameter list) -&gt; return type { function body }</p>
<ol>
<li>
<p>capture list 捕获列表是 lambda 函数所定义的函数的局部变量列表， 通常为空</p>
<ul>
<li>
<p>一个 lambda 只有在其捕获列表中捕获一个所在函数中的局部变量，才能在函数体中使用该变量。</p>
</li>
<li>
<p>捕获列表只用于局部非 static 变量。 lambda 可以直接使用局部 static 变量 和在它所在函数之外的声明的名字。</p>
</li>
<li>
<p>捕获列表的变量可以分为 值 或 引用传递。</p>
</li>
<li>
<p>值传递： lambda 捕获的变量在 lambda 函数 创建时 就发生了拷贝而非调用时。</p>
</li>
<li>
<p>隐式捕获：</p>
<p>编译器可以根据 lambda 中的代码推导使用的变量，为指示编译器推断捕获列表，应该在捕获列表中写一个 &amp; 或 =</p>
<ul>
<li>&amp; 告知编译器采用引用传递方式</li>
<li>= 告知编译器采用值传递方式</li>
</ul>
</li>
<li>
<p>当混合使用时，捕获列表第一个参数必须是 &amp; 或 = ，此符号指定了默认捕获方式为引用或值。且显示捕获的变量必须和隐式捕获使用不同的传递方式。</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203162122063.png" alt="image-20220316212235865" style="zoom:80%;" />
</li>
</ul>
</li>
<li>
<p>pameter list</p>
<p>参数列表和普通函数类似，但是 <strong>lambda 不能有默认参数</strong>【lambda 实参和形参数目一定相等】</p>
</li>
<li>
<p>return type</p>
<ul>
<li>
<p>与普通函数不同的是: lambda 必须使用 <strong>尾置返回</strong> 来指定返回类型。</p>
</li>
<li>
<p>如果忽略返回类型，lambda 表达式会根据函数体中的代码推断出返回类型</p>
</li>
<li>
<p>若函数体只有一个 return 语句， 则返回类型从返回表达式的类型推断而来，否则，若未指定返回类型，返回类型为 void</p>
</li>
<li>
<p><strong>Note: 如果 lambda 的函数体包含任意单一 return 之外的内容，且未指定返回类型，则返回 void</strong></p>
</li>
<li>
<p>当需要为 lambda 定义返回类型时，必须使用尾置返回类型</p>
</li>
</ul>
</li>
<li>
<p>function body</p>
<ul>
<li>与常规函数类似</li>
</ul>
</li>
</ol>
<h4 id="explicit-的作用（如何避免编译器进行隐式类型转换）">explicit 的作用（如何避免编译器进行隐式类型转换）</h4>
<p>作用：</p>
<ul>
<li><strong>用来声明类构造函数是显示调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换</strong>。</li>
<li>只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显示调用的，再加上 <code>explicit</code> 关键字也没有什么意义。</li>
</ul>
<p>隐式转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> var;</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">int</span> tmp) &#123; var = tmp; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A ex = <span class="number">10</span>;  <span class="comment">// 发生了隐式转换</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，<code>A ex = 10;</code> 在编译时，进行了隐式转换，将 <code>10</code> 转换成 <code>A</code> 类型的对象，然后将该对象赋值给 <code>ex</code>，等同于如下操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">temp</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">ex = temp;</span><br></pre></td></tr></table></figure>
<p>为了避免隐式转换，可用 <code>explicit</code> 关键字进行声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> var;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123;</span><br><span class="line">    var = tmp;</span><br><span class="line">    cout &lt;&lt; var &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">A <span class="title">ex</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">  A ex1 = <span class="number">10</span>;  <span class="comment">// error: conversion from &#x27;int&#x27; to non-scalar type &#x27;A&#x27; requested</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-和-C-static-的区别">C 和 C++ static 的区别</h4>
<p>C++ 中多了 静态成员变量和静态成员函数</p>
<ul>
<li>在 C 语言中，使用 <code>static</code> 可以定义局部静态变量、外部静态变量、静态函数</li>
<li>在 C++ 中，使用 <code>static</code> 可以定义局部静态变量、外部静态变量、静态函数、静态成员变量和静态成员函数。因为 C++ 中有类的概念，静态成员变量、静态成员函数都是与类有关的概念。</li>
</ul>
<h4 id="static-的作用">static 的作用</h4>
<p><code>static</code> 定义静态变量，静态函数。</p>
<ul>
<li>
<p><strong>保持变量内容持久</strong>：<code>static</code> 作用于局部变量，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间。<strong>static 修饰的变量只会被初始化一次</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> var = <span class="number">1</span>;  <span class="comment">// var 只在第一次进入这个函数的时初始化</span></span><br><span class="line">  var += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> var;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) cout &lt;&lt; <span class="built_in">fun</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 2 3 4 5 6 7 8 9 10 11</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>隐藏</strong>：<code>static</code> 作用于全局变量和函数，改变了全局变量和函数的作用域，使得全局变量和函数<strong>只能在定义它的文件中使用</strong>，在其他的源文件中不具有全局可见性。（注：普通全局变量和函数具有全局可见性，即其他的源文件也可以使用。）</p>
</li>
<li>
<p><code>static</code> 作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说<strong>可以不定义类的对象就可以通过类访问这些静态成员</strong>。注意：<strong>类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能访问非静态成员（因为没有 this 指针），不能将静态成员函数定义成虚函数。</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_var; <span class="comment">// 静态成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; s_var++ &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s_show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; s_var &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; var &lt;&lt; endl; // error: invalid use of member &#x27;A::a&#x27; in static member function. 静态成员函数不能调用非静态成员变量。无法使用 this.var</span></span><br><span class="line">        <span class="comment">// show();  // error: cannot call member function &#x27;void A::show()&#x27; without object. 静态成员函数不能调用非静态成员函数。无法使用 this.show()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> A::s_var = <span class="number">1</span>;  <span class="comment">// 静态成员变量在类外进行初始化赋值，默认初始化为 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// cout &lt;&lt; A::sa &lt;&lt; endl;    // error: &#x27;int A::sa&#x27; is private within this context</span></span><br><span class="line">    A ex;</span><br><span class="line">    ex.<span class="built_in">show</span>();</span><br><span class="line">    A::<span class="built_in">s_show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>static修饰的常规变量，从生命周期和作用域来来分析比较好：</li>
</ol>
<ul>
<li>生命周期： 从定义该变量该开始，直到程序结束时</li>
<li>作用域：<br>
若是局部变量，则作用域就是定义该变量的函数块范围<br>
若是全局变量，则是定义该变量的文件范围内部，也即是 static 修饰的变量具有文件作用域</li>
<li>static 定义变量的位置在静态变量区，<strong>超过其作用域该变量并不被释放，而是在函数结束时释放</strong></li>
<li>static 修饰的变量<strong>只会被初始化一次</strong></li>
</ul>
<ol start="2">
<li>static 修饰类：
<ul>
<li>static 修饰的成员变量要在<strong>类外初始化</strong>，属于类，为所有类对象共享，<strong>static 修饰的变量不占类的空间</strong></li>
<li>static 修饰的函数，静态成员函数，属于类，为类的所有对象共享，不能访问类的非静态成员和外部函数。静态成员函数<strong>没有this指针，因此只能访问静态成员</strong>(静态成员变量和静态函数)</li>
</ul>
</li>
</ol>
<h4 id="static-在类中使用的注意事项（定义、初始化和使用）">static 在类中使用的注意事项（定义、初始化和使用）</h4>
<p><strong>static 静态成员变量：</strong></p>
<ol>
<li>
<p>静态成员变量是<strong>在类内进行声明，在类外进行定义和初始化</strong>，在类外进行定义和初始化的时候不要出现 <code>static</code> 关键字和 <code>private</code>、<code>public</code>、<code>protected</code> 访问规则。</p>
</li>
<li>
<p>静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象。</p>
</li>
<li>
<p>静态成员变量可以作为成员函数的参数，而普通成员变量不可以。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_var;</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> i = s_var)</span></span>; <span class="comment">// 正确，静态成员变量可以作为成员函数的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> i = var)</span></span>;   <span class="comment">//  error: invalid use of non-static data member &#x27;A::var&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> A s_var; <span class="comment">// 正确，静态数据成员</span></span><br><span class="line">    A var;          <span class="comment">// error: field &#x27;var&#x27; has incomplete type &#x27;A&#x27;</span></span><br><span class="line">    A *p;           <span class="comment">// 正确，指针</span></span><br><span class="line">    A &amp;var1;        <span class="comment">// 正确，引用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>static 静态成员函数：</strong></p>
<ol>
<li>静态成员函数不能调用非静态成员变量或者非静态成员函数，<strong>因为静态成员函数没有 <code>this</code> 指针</strong>。静态成员函数做为类作用域的全局函数。</li>
<li><strong>静态成员函数不能声明成虚函数（<code>virtual</code>）、<code>const</code> 函数和 <code>volatile</code> 函数</strong>。</li>
</ol>
<p><strong>为何 static 成员函数不能为 const 函数</strong></p>
<p><strong>因为 static 成员函数没有 this 指针。</strong></p>
<ul>
<li>当声明一个非静态成员函数为 const 时，对 this 指针会有影响。对于一个 Test 类中的 const 修饰的成员函数，this 指针相当于 Test const *, 而对于非 const 成员函数，this 指针相当于Test *.</li>
<li>而 static 成员函数没有 this 指针，所以使用 const 来修饰 static 成员函数没有任何意义。</li>
<li>volatile 的道理也是如此。</li>
</ul>
<p><strong>为何 static 成员函数不能为 virtual</strong></p>
<ol>
<li>static 成员不属于任何类对象或类实例，所以即使给此函数加上 virutal 也是没有任何意义的。</li>
<li>静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数没有 this 指针。</li>
</ol>
<ul>
<li>虚函数依靠 vptr 和 vtable 来处理。vptr 是一个指针，在类的构造函数中创建生成，并且只能用 this 指针来访问它，因为它是类的一个成员，并且 vptr 指向保存虚函数地址的 vtable.</li>
<li><strong>对于静态成员函数，它没有 this 指针，所以无法访问 vptr。 这就是为何 static 函数不能为 virtual.</strong></li>
<li>虚函数的调用关系：<code>this-&gt;vptr-&gt;vtable-&gt;virtual function</code></li>
</ul>
<h4 id="static-全局变量和普通全局变量的异同">static 全局变量和普通全局变量的异同</h4>
<p>相同点：</p>
<ul>
<li>存储方式：普通全局变量和 <code>static</code> 全局变量都是静态存储方式。</li>
</ul>
<p>不同点：</p>
<ul>
<li>作用域：
<ul>
<li>普通全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的；</li>
<li>静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。</li>
<li>由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。</li>
</ul>
</li>
<li>初始化：静态全局变量只初始化一次，防止在其他文件中使用。</li>
</ul>
<h4 id="const-作用及用法">const 作用及用法</h4>
<p><strong>作用</strong>：</p>
<ul>
<li><code>const</code> 修饰成员变量，定义成 <code>const</code> 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。</li>
<li><code>const</code> 修饰函数参数，使得传递过来的函数参数的值不能改变。</li>
<li><code>const</code> 修饰成员函数，使得成员函数不能修改任何类型的成员变量（<code>mutable</code> 修饰的变量除外），也不能调用非 <code>const</code> 成员函数，因为非 <code>const</code> 成员函数可能会修改成员变量。</li>
</ul>
<p>**存储位置：**const 变量的内存位于栈区或者静态存储区，不在符号表(常量表)中</p>
<ol>
<li>const 修饰的量不是常量，仅仅是个只读量。在编译的时候全部替换 const 变量被赋予的值（这点和 C 语言的宏相似），在运行的时候该 const 变量可通过内存进行修改:</li>
</ol>
<ul>
<li>通过内存(指针)可以修改位于栈区的 const 变量，语法合乎规定，编译运行不会报错，但是在编译的时候所有用到该常量的地方全部被替换成了定义时所赋予的值，然后再运行的时候无法使用通过指针修改后的值。</li>
<li>通过内存(指针)修改位于静态存储区的的 const 变量，语法上没有报错，编译不会出错，一旦运行就会报告异常。</li>
<li>注：通过指针修改在全局区上的 const 变量，编译可通过，运行就会报异常。</li>
</ul>
<p><strong>在类中的用法</strong>：</p>
<p><code>const</code> 成员变量：</p>
<ol>
<li>
<p><code>const</code> 成员变量只能在类内声明、定义，<strong>在构造函数初始化列表中初始化</strong>。</p>
</li>
<li>
<p><code>const</code> 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同对象的 <code>const</code> 成员变量的值是不同的。因此不能在类的声明中初始化 <code>const</code> 成员变量，类的对象还没有创建，编译器不知道他的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">//之所以没报错是因为用了初始化列表</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a) : <span class="built_in">a</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a) &#123; <span class="comment">//没用初始化列表声明const成员变量,报错</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a; <span class="comment">//这里给a赋值也没关系, 因为a会是第一次构造时的值, 后面再实例化对象, 也不会变</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a) : <span class="built_in">a</span>(a) &#123;&#125; <span class="comment">//正确</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.a &lt;&lt; endl;<span class="comment">//4</span></span><br><span class="line">    <span class="function">A <span class="title">b</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.a &lt;&lt; endl;<span class="comment">//4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>const</code> 成员函数：</p>
<ol>
<li>不能修改成员变量的值，除非有 <code>mutable</code> 修饰；只能访问成员变量。</li>
<li>不能调用非常量成员函数，以防修改成员变量的值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> tmp) : <span class="built_in">var</span>(tmp) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">c_fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// const 成员函数</span></span><br><span class="line">        var = tmp; <span class="comment">// error: assignment of member &#x27;A::var&#x27; in read-only object. 在 const 成员函数中，不能修改任何类成员变量。</span></span><br><span class="line">        <span class="built_in">fun</span>(tmp); <span class="comment">// error: passing &#x27;const A&#x27; as &#x27;this&#x27; argument discards qualifiers. const 成员函数不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; var = tmp; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="define-和-const-的区别">define 和 const 的区别</h4>
<p>区别：</p>
<ul>
<li>编译阶段：<code>define</code> 是在编译预处理阶段进行替换，<code>const</code> 是在编译阶段确定其值。</li>
<li>安全性：<code>define</code> 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；<code>const</code> 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。</li>
<li>内存占用：<code>define</code> 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间；<strong><code>const</code> 定义的<code>全局常量</code>占用静态存储区的空间，程序运行过程中只有一份（有的 const 局部变量，比如作为类的成员变量，是属于对象的，程序运行的时候内存中，并不是一份）</strong>。</li>
<li>调试：<code>define</code> 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；<code>const</code> 定义的常量可以进行调试。</li>
</ul>
<p><code>const</code> 的优点：</p>
<ul>
<li>有数据类型，在定义式可进行安全性检查。</li>
<li>可以进行调试。</li>
<li>占用较少的空间(全局变量)。</li>
</ul>
<h4 id="define-和-typedef-的区别">define 和 typedef 的区别</h4>
<ul>
<li>
<p>原理：</p>
<ul>
<li><code>#define</code> 作为预处理指令，在编译预处理时进行替换操作，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。</li>
<li><strong><code>typedef</code> 是关键字，在编译时处理，有类型检查功能</strong>，用来给一个已经存在的类型一个别名，但不能在一个函数定义里面使用 <code>typedef</code> 。</li>
</ul>
</li>
<li>
<p>功能：<code>typedef</code> 用来定义类型的别名，方便使用。<code>#define</code> 不仅可以为类型取别名，还可以定义常量、变量、编译开关等。</p>
</li>
<li>
<p>作用域：</p>
<ul>
<li><code>#define</code> 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而 <code>typedef</code> 有自己的作用域。不管是在某个函数内，还是在所有函数之外，作用域都是从定义开始直到整个文件结尾。</li>
<li><code>typedef</code>：有作用域的限制。如果放在所有函数之外，它的作用域就是从它定义开始直到文件尾；如果放在某个函数内，定义域就是从定义开始直到该函数结尾；</li>
</ul>
</li>
<li>
<p>指针的操作：<code>typedef</code> 和 <code>#define</code> 在处理指针时不完全一样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTPTR1 int *</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> * INTPTR2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    INTPTR1 p1, p2; <span class="comment">// p1: int *; p2: int    等价于：int *p1, p2;</span></span><br><span class="line">    INTPTR2 p3, p4; <span class="comment">// p3: int *; p4: int *  等价于：int *p1, *p2;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> INTPTR1 p5 = &amp;var; <span class="comment">// 相当于 const int *p5; 常量指针，即不可以通过 p5 去修改 p5 指向的内容，但是 p5 可以指向其他内容。</span></span><br><span class="line">    <span class="keyword">const</span> INTPTR2 p6 = &amp;var; <span class="comment">// 相当于 int * const p6; 指针常量，不可使 p6 再指向其他内容。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="用宏实现比较大小，以及两个数中的最小值">用宏实现比较大小，以及两个数中的最小值</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(X, Y) ((X)&gt;(Y)?(X):(Y)) <span class="comment">// 注意加括号！！！</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(X, Y) ((X)&lt;(Y)?(X):(Y))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var1 = <span class="number">10</span>, var2 = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MAX</span>(var1, var2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MIN</span>(var1, var2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序运行结果：</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="inline-内联函数-作用及使用方法-2">inline 内联函数 作用及使用方法</h4>
<p><strong>作用</strong>：<br>
<code>inline</code> 是一个关键字，可以用于定义内联函数。内联函数，像普通函数一样被调用，但是<strong>在调用时并不通过函数调用的机制而是直接在调用点处展开</strong>，这样可以大大<strong>减少由函数调用带来的开销</strong>，从而提高程序的运行效率。</p>
<p><strong>使用方法：</strong></p>
<ol>
<li>
<p><strong>类内定义成员函数默认是内联函数</strong></p>
<p>在类内定义成员函数，可以不用在函数头部加 <code>inline</code> 关键字，因为编译器会自动将类内定义的函数（构造函数、析构函数、普通成员函数等）声明为内联函数，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="built_in">A</span> (<span class="keyword">int</span> tmp) &#123; var = tmp; &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123; cout &lt;&lt; var &lt;&lt; endl; &#125; <span class="comment">// 类内定义成员函数，默认是内联函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类外定义成员函数，若想定义为内联函数，需用关键字声明</p>
<p>当在类内声明函数，在类外定义函数时，如果想将该函数定义为内联函数，则可以在类内声明时不加 <code>inline</code> 关键字，而在类外定义函数时加上 <code>inline</code> 关键字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="built_in">A</span> (<span class="keyword">int</span> tmp) &#123; var = tmp; &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">A::fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; var &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>另外，可以在声明函数和定义函数的同时加上 <code>inline</code>；也可以只在函数声明时加 <code>inline</code>，而定义函数时不加 <code>inline</code>。只要确保在调用该函数之前把 <code>inline</code> 的信息告知编译器即可。</p>
<p><strong>内联函数的作用</strong>：</p>
<ol>
<li>
<p>消除函数调用的开销。</p>
<p>在内联函数出现之前，程序员通常用 #define 定义一些“函数”来消除调用这些函数的开销。内联函数设计的目的之一，就是取代 #define 的这项功能（因为使用 #define 定义的那些“函数”，编译器不会检查其参数的正确性等，而使用 inline 定义的函数，和普通函数一样，可以被编译器检查，这样有利于尽早发现错误）。</p>
</li>
<li>
<p>去除函数只能定义一次的限制。</p>
<p>内联函数可以在头文件中被定义，并被多个 .cpp 文件 include，而不会有重定义错误。这也是设计内联函数的主要目的之一。</p>
</li>
</ol>
<p><strong>关于减少函数调用的开销：</strong></p>
<ol>
<li>
<p>内联函数一定会被编译器在调用点展开吗？</p>
<p>错，inline 只是对编译器的建议，而非命令。编译器可以选择忽视 inline。当程序员定义的 inline 函数包含复杂递归，或者 inlinie 函数本身比较长，编译器一般不会将其展开，而仍然会选择函数调用。</p>
</li>
<li>
<p>“调用” 普通函数时，一定是调用吗？</p>
<p>错，即使是普通函数，编译器也可以选择进行优化，将普通函数在“调用”点展开。</p>
</li>
<li>
<p>既然内联函数在编译阶段已经在调用点被展开，那么程序运行时，对应的内存中不包含内联函数的定义，对吗？</p>
<p>错。</p>
<p>首先，如第一点所言，编译器可以选择调用内联函数，而非展开内联函数。因此，内存中仍然需要一份内联函数的定义，以供调用。</p>
<p>而且，一致性是所有语言都应该遵守的准则。普通函数可以有指向它的函数指针，那么，内联函数也可以有指向它的函数指针，因此，内存中需要一份内联函数的定义，使得这样的函数指针可以存在。</p>
</li>
</ol>
<p><strong>关于去除函数只能定义一次的限制：</strong></p>
<ul>
<li>
<p>下述程序会报错：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;function 1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;function 2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">myPrint</span>();  <span class="comment">// error，会出现链接时错误， myPrint 函数被定义了两次。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>而下述程序不会报错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;inline function 1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;inline function 2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">myPrint</span>()<span class="comment">// 正常运行;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可见，<strong>内联函数可以在头文件中定义</strong>（即多个 .cpp 源文件可以定义函数名、参数都一样的内联函数，而不会有重定义错误）。</p>
</li>
</ul>
<h4 id="inline-函数工作原理-2">inline 函数工作原理</h4>
<ul>
<li>内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。</li>
<li>普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。</li>
</ul>
<h4 id="宏定义（define）和内联函数（inline）的区别">宏定义（define）和内联函数（inline）的区别</h4>
<ol>
<li>内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</li>
<li>内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。</li>
<li>宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fun_max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MAX</span>(var, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 5  </span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">fun_max</span>(var, <span class="number">0</span>) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="new-和-malloc">new 和 malloc</h4>
<h5 id="new-的作用？">new 的作用？</h5>
<p><code>new</code> 是 C++ 中的关键字，用来动态分配内存空间，实现方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; </span><br></pre></td></tr></table></figure>
<h5 id="new-和-malloc-如何判断是否申请到内存？">new 和 malloc 如何判断是否申请到内存？</h5>
<ul>
<li><code>malloc</code> ：成功申请到内存，返回指向该内存的指针；分配失败，返回 <code>NULL</code> 指针。</li>
<li><code>new</code> ：内存分配成功，返回该对象类型的指针；分配失败，抛出 <code>bac_alloc</code> 异常。</li>
</ul>
<p>注：可以使用<code>std::nothrow</code>让<code>new</code>在申请内存失败时也同<code>malloc</code>一样返回<code>NULL</code>指针，而不是抛出<code>std::bad_alloc</code>异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A *a = <span class="built_in"><span class="keyword">new</span></span> (std::nothrow) <span class="built_in">A</span>();</span><br><span class="line"><span class="keyword">if</span> (a == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// add logs here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="delete-实现原理？delete-和-delete-的区别？">delete 实现原理？delete 和 delete[] 的区别？</h4>
<p><code>delete</code> 的实现原理：</p>
<ul>
<li><strong>首先执行该对象所属类的析构函数</strong>；</li>
<li>进而通过调用 <code>operator delete</code> 的标准库函数来释放所占的内存空间。</li>
</ul>
<p><code>delete</code> 和 <code>delete []</code> 的区别：</p>
<ul>
<li><code>delete</code> 用来释放单个对象所占的空间，只会调用一次析构函数；</li>
<li><code>delete []</code> 用来释放数组空间，会对数组中的每个成员都调用一次析构函数。</li>
<li>对于像<code>int/char/long/int*</code>等等简单数据类型，由于对象没有析构函数，所以<strong>用<code>delete</code>和<code>delete []</code>是一样的！都不会造成内存泄露！</strong> 但通常为了规范起见，new []都配套使用delete []。</li>
<li>但是如果是<code>C++自定义对象</code>数组就不同了！由于<code>delete p</code>只调用了一次析构函数，剩余的对象不会调用析构函数，所以剩余对象中如果有申请了新的内存或者其他系统资源，那么这部分内存和资源就无法被释放掉了，<strong>因此会造成内存泄露或者更严重的问题</strong>。</li>
</ul>
<h4 id="new-和-malloc-的区别，delete-和-free-的区别">new 和 malloc 的区别，delete 和 free 的区别</h4>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/1644544880-MwtYMy-image.png" alt="image.png" style="zoom: 67%;" />
<p>在使用的时候 <code>new</code>、<code>delete</code> 搭配使用，<code>malloc</code>、<code>free</code> 搭配使用。</p>
<ul>
<li><code>malloc</code>、<code>free</code> 是库函数，而<code>new</code>、<code>delete</code> 是关键字。<br>
-<code>new</code> 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；<code>malloc</code> 在申请空间时，需要确定所申请空间的大小。</li>
<li><code>new</code> 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；<code>malloc</code> 申请空间时，返回的是 <code>void*</code> 类型，需要进行强制类型的转换，转换为对象类型的指针。</li>
<li><code>new</code> 分配失败时，会抛出 <code>bad_alloc</code> 异常，<code>malloc</code> 分配失败时返回空指针。</li>
<li>对于自定义的类型，<code>new</code> 首先调用 <code>operator new()</code> 函数申请空间（底层通过 <code>malloc</code> 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；<code>delete</code> 首先调用析构函数，然后调用 <code>operator delete()</code> 释放空间（底层通过 <code>free</code> 实现）。<code>malloc</code>、<code>free</code> 无法进行自定义类型的对象的构造和析构。</li>
<li><code>new</code> 操作符从自由存储区上为对象动态分配内存，而 <code>malloc</code> 函数从堆上动态分配内存。（自由存储区不等于堆）</li>
</ul>
<p>堆区和自由存储区的区别与联系：<br>
（1）malloc申请的内存在堆上，使用free释放。new申请的内存在自由存储区，用delete释放<br>
（2）堆（heap）是c语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当程序运行时调用malloc()时就会从中分配，调用free可把内存交换。而自由存储区是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。<strong>基本上，所有的C++编译器默认用堆来实现自由存储区，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来实现，这时由new运算符分配的对象，说它在堆上也对，说它在自由存储区也对。</strong><br>
记住：<br>
（1）堆是c语言和操作系统的术语，是操作系统维护的一块内存。自由存储是 C++ 中通过 new 和 delete 动态分配和释放对象的抽象概念。<br>
（2）new 所申请的内存区域在 C++ 中称为自由存储区，编译器用 malloc 和 free 实现 new 和 delete 操作符时，new 申请的内存可以说是在堆上。<br>
（3）堆和自由存储区有相同之处，但并不等价。</p>
<h4 id="malloc-的原理？malloc-的底层实现？">malloc 的原理？malloc 的底层实现？</h4>
<p><code>malloc</code> 的原理:</p>
<ul>
<li>当开辟的空间小于 128K 时，调用 <code>brk()</code> 函数，通过移动 <code>_enddata</code> 来实现；</li>
<li>当开辟空间大于 128K 时，调用 <code>mmap()</code> 函数，通过在虚拟地址空间中开辟一块内存空间来实现。</li>
</ul>
<p><code>malloc</code> 的底层实现：</p>
<ul>
<li><code>brk()</code> 函数实现原理：向高地址的方向移动指向数据段的高地址的指针 <code>_enddata</code>。</li>
<li><code>mmap</code> 内存映射原理：
<ol>
<li>进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域；</li>
<li>调用内核空间的系统调用函数 <code>mmap()</code>，实现文件物理地址和进程虚拟地址的一一映射关系；</li>
<li>进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝。</li>
</ol>
</li>
</ul>
<h4 id="C-和-C-struct-的区别？">C 和 C++ struct 的区别？</h4>
<ul>
<li>在 C 语言中 <code>struct</code> 是用户自定义数据类型；在 C++ 中 <code>struct</code> 是抽象数据类型，支持成员函数的定义。</li>
<li>C 语言中 <code>struct</code> 没有访问权限的设置，是一些变量的集合体，不能定义成员函数；C++ 中 <code>struct</code> 可以和类一样，有访问权限，并可以定义成员函数。</li>
<li>C 语言中 <code>struct</code> 定义的自定义数据类型，在定义该类型的变量时，需要加上 <code>struct</code> 关键字，例如：<code>struct A var;</code>，定义 <code>A</code> 类型的变量；而 C++ 中，不用加该关键字，例如：<code>A var;</code></li>
</ul>
<h4 id="为什么有了-class-还保留-struct？">为什么有了 class 还保留 struct？</h4>
<p>C++ 是在 C 语言的基础上发展起来的，为了与 C 语言兼容，C++ 中保留了 <code>struct</code>。</p>
<h4 id="struct-和-union-的区别">struct 和 union 的区别</h4>
<p>说明：<code>union</code> 是联合体，<code>struct</code> 是结构体。<br>
区别：</p>
<ol>
<li>联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，联合体只有一个有效的成员；而结构体所有的成员都有效。</li>
<li>对联合体的不同成员赋值，将会对覆盖其他成员的值，而对于结构体的对不同成员赋值时，相互不影响。</li>
<li>联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小；结构体分配内存的大小遵循内存对齐原则。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> cc1; <span class="comment">// char 1 字节，按该类型的倍数分配大小</span></span><br><span class="line">&#125; u11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> i; <span class="comment">// int 4 字节，按该类型的倍数分配大小</span></span><br><span class="line">&#125; u22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">double</span> d; <span class="comment">// double 8 字节，按该类型的倍数分配大小</span></span><br><span class="line">&#125; u33;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s1</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;   <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="keyword">double</span> d; <span class="comment">// 1（char）+ 7（内存对齐）+ 8（double）= 16 字节</span></span><br><span class="line">&#125; s11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s2</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;   <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="keyword">char</span> cc;  <span class="comment">// 1（char）+ 1（char）= 2 字节</span></span><br><span class="line">    <span class="keyword">double</span> d; <span class="comment">// 2 + 6（内存对齐）+ 8（double）= 16 字节</span></span><br><span class="line">&#125; s22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s3</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;   <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="keyword">double</span> d; <span class="comment">// 1（char）+ 7（内存对齐）+ 8（double）= 16 字节</span></span><br><span class="line">    <span class="keyword">char</span> cc;  <span class="comment">// 16 + 1（char）+ 7（内存对齐）= 24 字节</span></span><br><span class="line">&#125; s33;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(u11) &lt;&lt; endl; <span class="comment">// 10</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(u22) &lt;&lt; endl; <span class="comment">// 12</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(u33) &lt;&lt; endl; <span class="comment">// 16</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s11) &lt;&lt; endl; <span class="comment">// 16</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s22) &lt;&lt; endl; <span class="comment">// 16</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s33) &lt;&lt; endl; <span class="comment">// 24</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) &lt;&lt; endl;    <span class="comment">// 4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="class-和-struct-的异同">class 和 struct 的异同</h4>
<ul>
<li><code>struct</code> 和 <code>class</code> 都可以自定义数据类型，也支持继承操作。</li>
<li><code>struct</code> 中默认的访问级别是 <code>public</code>，默认的继承级别也是 <code>public</code>；<code>class</code> 中默认的访问级别是 <code>private</code>，默认的继承级别也是 <code>private</code>。</li>
<li>当 <code>class</code> 继承 <code>struct</code> 或者 <code>struct</code> 继承 <code>class</code> 时，默认的继承级别取决于 <code>class</code> 或 <code>struct</code> 本身， <code>class</code>（<code>private</code> 继承），<code>struct</code>（<code>public</code> 继承），即取决于派生类的默认继承级别。</li>
<li><code>class</code> 可以用于定义模板参数，<code>struct</code> 不能用于定义模板参数。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202241015072.png" alt="QQ图片20210408152636.png"></p>
<h4 id="volatile-的作用？是否具有原子性，对编译器有什么影响？">volatile 的作用？是否具有原子性，对编译器有什么影响？</h4>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203162317614.png" alt="image-20220316231723297" style="zoom:80%;" />
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203162314932.png" alt="image-20220316231404611" style="zoom:80%;" />
<ul>
<li><strong><code>volatile</code> 的作用：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 <code>volatile</code>，告知编译器不应对这样的对象进行优化。</strong></li>
<li><code>volatile</code> <strong>不具有原子性</strong>。</li>
<li><code>volatile</code> 对编译器的影响：<strong>使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，从而导致程序错误。</strong></li>
</ul>
<ol>
<li>volatile 中文意思是不稳定的，易变的。</li>
<li>volatile 变量的作用和使用场景如下：
<ul>
<li>
<p>在多线程编程中，多个线程访问同一个变量，而且有可能修改变量，如果不加 volatile，编译器有可能做优化，在寄存器中保存变量，CPU 直接访问寄存器，从而优化变量访问速度，加上 volatile 修饰，CPU 会直接访问内存，不会做寄存器的优化。这一条称为<strong>保证内存的可见性</strong>。</p>
<p>类似的情况在中断服务程序中访问变量，并行设备的硬件寄存器变量都是一个道理。</p>
</li>
<li>
<p>另一个作用是<strong>禁止指令重排，也是针对编译器说的，保证缓存一致性</strong>。</p>
<p>volatile 保证了程序的正确性，损失了编译器的优化。</p>
</li>
</ul>
</li>
</ol>
<p>摘自《程序员的自我修养》中原话：</p>
<ul>
<li>
<p>我们可以使用 volatile 关键字试图阻止过度优化，volatile 基本可以做到两件事情：</p>
<ol>
<li>
<p>阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回；（缓存一致性协议、轻量级同步）</p>
</li>
<li>
<p>阻止编译器调整操作 volatile 变量的指令排序。</p>
</li>
</ol>
<ul>
<li>
<p>注意：即使volatile能够阻止编译器调整顺序，也无法阻止 CPU 动态调度换序。</p>
<p>要保证线程安全，阻止CPU换序是必须的。遗憾的是，现在并不存在可移植的阻止换序的方法。<br>
通常情况下是调用CPU提供的一条指令，这条指令常常被称为 barrier。<br>
一条 barrier 指令会阻止 CPU 将该指令之前的指令交换到 barrier 之后。</p>
</li>
</ul>
</li>
</ul>
<p>对volatile的三点理解：</p>
<ol>
<li>只能保证赋值原子性，复合操作不能保证；</li>
<li>告诉编译器不进行指令重排（JMM 中还会追加 CPU 内存屏障），以避免过度优化；</li>
<li>保证内存可见性。</li>
</ol>
<p>参考《effective modern C++》：</p>
<ul>
<li>
<p>在 C++多线程中，volatile 不具有原子性；无法对代码重新排序实施限制。</p>
</li>
<li>
<p>能干什么：<strong>告诉编译器不要在此内存上做任何优化</strong>。如果对内存有只写未读的等非常规操作，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;</span><br><span class="line">x = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>编译器会优化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>volatile 就是阻止编译器进行此类优化。</p>
</li>
</ul>
<h4 id="什么情况下一定要用-volatile，-能否和-const-一起使用？">什么情况下一定要用 volatile， 能否和 const 一起使用？</h4>
<p>使用 <code>volatile</code> 关键字的场景：</p>
<ul>
<li>当多个线程都会用到某一变量，并且该变量的值有可能发生改变时，需要用 <code>volatile</code> 关键字对该变量进行修饰；</li>
<li>中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用 <code>volatile</code> 关键字修饰。</li>
</ul>
<p><code>volatile</code> 关键字和 <code>const</code> 关键字可以同时使用，某种类型可以既是 <code>volatile</code> 又是 <code>const</code> ，同时具有二者的属性。</p>
<h4 id="返回函数中静态变量的地址会发生什么？">返回函数中静态变量的地址会发生什么？</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> var = <span class="number">10</span>;</span><br><span class="line">    var *= tmp;</span><br><span class="line">    <span class="keyword">return</span> &amp;var;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">fun</span>(<span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 50</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：上述代码中在函数 <code>fun</code> 中定义了静态局部变量 <code>var</code>，使得离开该函数的作用域后，该变量不会销毁，返回到主函数中，该变量依然存在，从而使程序得到正确的运行结果。但是，该静态局部变量直到程序运行结束后才销毁，浪费内存空间。</p>
<ul>
<li>全局变量（包括静态全局变量）是最先构造的，早于 main 函数，当然，析构函数也是执行的最晚，晚于 main 函数。</li>
<li>静态局部变量是要等到执行该声明定义的表达式后，才开始执行构造的。当然，析构函数也是早于全局变量的。</li>
</ul>
<h4 id="extern-C-的作用？">extern C 的作用？</h4>
<p>当 C++ 程序 需要调用 C 语言编写的函数，C++ 使用链接指示，即 <code>extern &quot;C&quot;</code> 指出任意非 C++ 函数所用的语言。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能出现在 C++ 头文件&lt;cstring&gt;中的链接指示</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++ 和 C语言编译函数签名方式不一样， extern 关键字可以让两者保持统一，这样才能找到对应的函数</p>
<p>extern “C” 的作用是让 C++ 编译器将 extern “C” 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和 C 语言库中的符号进行链接的问题。</p>
<p>c 和 c++ 对同一个函数经过编译后生成的函数名是不同的</p>
<ul>
<li>C++ 支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；</li>
<li>C 语言并不支持函数重载，因此编译 C 语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</li>
<li>如果在 c++ 中调用一个使用 c 语言编写的模块中的某个函数，那么 c++ 是根据 c++ 的名称修饰方式来查找并链接这个函数，那么就会发生链接错误。</li>
</ul>
<h4 id="sizeof-1-1-在-C-和-C-中分别是什么结果？">sizeof(1 == 1) 在 C 和 C++ 中分别是什么结果？</h4>
<ul>
<li>C：  <code>sizeof(1 == 1)</code> 等价于  <code>sizeof(1)</code> 按照整数 <code>int</code> 处理，所以是 4 字节，这里也有可能是 8 字节（看操作系统）</li>
<li>C++：因为有 bool 类型  <code>sizeof(1 == 1)</code> 等价于<code>sizeof(true)</code> 按照 <code>bool</code> 类型处理，所以是 1 个字节</li>
</ul>
<h4 id="memmove-函数的底层原理？">memmove 函数的底层原理？</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *psrc;</span><br><span class="line">    <span class="keyword">char</span> *pdst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == dst || <span class="literal">NULL</span> == src) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((src &lt; dst) &amp;&amp; (<span class="keyword">char</span> *)src + size &gt; (<span class="keyword">char</span> *)dst) &#123; <span class="comment">// 出现地址重叠的情况，自后向前拷贝</span></span><br><span class="line">        psrc = (<span class="keyword">char</span> *)src + size - <span class="number">1</span>;</span><br><span class="line">        pdst = (<span class="keyword">char</span> *)dst + size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">            *pdst-- = *psrc--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        psrc = (<span class="keyword">char</span> *)src;</span><br><span class="line">        pdst = (<span class="keyword">char</span> *)dst;</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">            *pdst++ = *psrc++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="memmove-和-memcopy-的区别">memmove 和 memcopy 的区别</h4>
<p>memcpy和memmove都是C语言的库函数，相比于strcpy和strncpy只能拷贝字符串数组，memcpy与memmove可以拷贝其它类型的数组，但是为什么要同时提供两种方法呢？本文主要就是介绍这两个函数的区别。</p>
<p>首先来看函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> s2, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *s1, <span class="keyword">const</span> <span class="keyword">void</span> *s2, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这两个函数都是将s2指向位置的n字节数据拷贝到s1指向的位置，区别就在于关键字restrict, memcpy假定两块内存区域没有数据重叠，而memmove没有这个前提条件。如果复制的两个区域存在重叠时使用memcpy，其结果是不可预知的，有可能成功也有可能失败的，所以如果使用了memcpy,程序员自身必须确保两块内存没有重叠部分。</p>
<p>我们来看一组示例:</p>
<ol>
<li>
<p>正常情况拷贝</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203162327394.webp" alt="img" style="zoom:50%;" />
<p>正常情况下，即使内容有重叠，src的内容也可以正确地被拷贝到了dest指向的空间。</p>
</li>
<li>
<p>内存重叠的拷贝</p>
<img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203162328485.webp" alt="img" style="zoom:50%;" />
<p>这种情况下，src的地址小于dest的地址，拷贝前3个字节没问题，但是拷贝第4，5个字节时，原有的内容已经被src拷贝过来的字符覆盖了，所以已经丢失原来src的内容，这很明显就是问题所在。</p>
</li>
</ol>
<p><strong>memcpy的实现</strong></p>
<p>一般来说，memcpy的实现非常简单，只需要顺序的循环，把字节一个一个从src拷贝到dest就行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span> <span class="comment">/* size_t */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *dp = dest;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sp = src;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">        *dp++ = *sp++;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>memmove的实现</strong></p>
<p>memmove会对拷贝的数据作检查，确保内存没有覆盖，如果发现会覆盖数据，简单的实现是调转开始拷贝的位置，从尾部开始拷贝:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span> <span class="comment">/* for size_t */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *pd = dest;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *ps = src;</span><br><span class="line">    <span class="keyword">if</span> (__np_anyptrlt(ps, pd))</span><br><span class="line">        <span class="keyword">for</span> (pd += n, ps += n; n--;)</span><br><span class="line">            *--pd = *--ps;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">            *pd++ = *ps++;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>__np_anyptrlt</code>是一个简单的宏，用于结合拷贝的长度检测dest与src的位置，如果dest和src指向同样的对象，且src比dest地址小，就需要从尾部开始拷贝。否则就和memcpy处理相同。<br>
但是实际在C99实现中，是将内容拷贝到临时空间，再拷贝到目标地址中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span> <span class="comment">/* for size_t */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span> <span class="comment">/* for memcpy */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> tmp[n];</span><br><span class="line">    <span class="built_in">memcpy</span>(tmp,src,n);</span><br><span class="line">    <span class="built_in">memcpy</span>(dest,tmp,n);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见memcpy的速度比memmove快一点，如果使用者可以确定内存不会重叠，则可以选用memcpy，否则memmove更安全一些。另外一个提示是第三个参数是拷贝的长度，如果你是拷贝10个double类型的数值，要写成sizeof(double)*10,而不仅仅是10。</p>
<h4 id="strcpy-函数有什么缺陷？">strcpy 函数有什么缺陷？</h4>
<p><code>strcpy</code> 函数的缺陷：<code>strcpy</code> 函数不检查目的缓冲区的大小边界，而是将源字符串逐一的全部赋值给目的字符串地址起始的一块连续的内存空间，同时加上字符串终止符，会导致其他变量被覆盖。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">0x11112222</span>;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">10</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Address : var &quot;</span> &lt;&lt; &amp;var &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Address : arr &quot;</span> &lt;&lt; &amp;arr &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">strcpy</span>(arr, <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;var:&quot;</span> &lt;&lt; hex &lt;&lt; var &lt;&lt; endl; <span class="comment">// 将变量 var 以 16 进制输出</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr:&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Address : var 0x23fe4c</span></span><br><span class="line"><span class="comment">Address : arr 0x23fe42</span></span><br><span class="line"><span class="comment">var:11002164</span></span><br><span class="line"><span class="comment">arr:hello world!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// strcpy 函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* des,<span class="keyword">const</span> <span class="keyword">char</span>* source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* r=des;</span><br><span class="line">    <span class="built_in">assert</span>((des != <span class="literal">NULL</span>) &amp;&amp; (source != <span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>((*r++ = *source++)!=<span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：从上述代码中可以看出，变量 <code>var</code> 的后六位被字符串 <code>&quot;hello world!&quot;</code> 的 <code>&quot;d!\0&quot;</code> 这三个字符改变，这三个字符对应的 ascii 码的十六进制为：<code>\0</code>(0x00)，<code>!</code>(0x21)，<code>d</code>(0x64)。<br>
原因：变量 <code>arr</code> 只分配的 10 个内存空间，通过上述程序中的地址可以看出 <code>arr</code> 和 <code>var</code> 在内存中是连续存放的，但是在调用 <code>strcpy</code> 函数进行拷贝时，源字符串 <code>&quot;hello world!&quot;</code> 所占的内存空间为 13，因此在拷贝的过程中会占用 <code>var</code> 的内存空间，导致 <code>var</code>的后六位被覆盖。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202202241047498.png" alt="image.png"></p>
<h4 id="auto-类型推导的原理">auto 类型推导的原理</h4>
<p><code>auto</code> 类型推导的原理：编译器根据初始值来推算变量的类型，要求用 <code>auto</code> 定义变量时必须有初始值。</p>
<p>编译器推断出来的 <code>auto</code> 类型有时和初始值类型并不完全一样，编译器会适当改变结果类型使其更符合初始化规则。</p>
<p>auto变量的规则是 “做函数模板需要做的事情”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> my_new_variable = its_initial_value;</span><br></pre></td></tr></table></figure>
<p>就像普通的赋值操作一样, <code>my_new_variable</code> 的基本类型和值与 <code>its_initial_value</code> 一样,但是 <code>its_initial_value</code> 的第二属性（ 顶层 const , volatile, &amp;/&amp;&amp;）不一定相同。例如 <code>its_initial_value</code> 是 <code>const</code> 并不意味着 <code>my_new_variable</code> 是 <code>const</code> ，因此, <code>my_new_variable</code> 和 <code>its_initial_value</code> 只是在基本类型上相同, 但不是完全相同的变量.</p>
<h3 id="语言特性相关">语言特性相关</h3>
<h4 id="左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？">左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？</h4>
<p>左值：指表达式结束后依然存在的持久对象。</p>
<p>右值：表达式结束就不再存在的临时对象。</p>
<p>左值和右值的区别：<strong>左值持久，右值短暂</strong></p>
<p>右值引用和左值引用的区别：</p>
<ul>
<li>左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。</li>
<li>右值引用必须绑定到右值的引用，通过 <code>&amp;&amp;</code> 获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。</li>
</ul>
<p><code>std::move</code> <strong>可以将一个左值强制转化为右值，继而可以通过右值引用使用该值，以用于移动语义</strong>。move 实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。如果是一些基本类型比如 int 和 char[10] 定长数组等类型，使用 move 的话仍然会发生拷贝（因为没有对应的移动构造函数）</p>
<p><code>T&amp;&amp; t</code> 在发生自动类型推断的时候，它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。需要注意的是，仅仅是当发生自动类型推导（如函数模板的类型自动推导，或auto关键字）的时候，<code>T&amp;&amp; </code>才是 universal references</p>
<p>引用折叠：正是因为引入了右值引用，所以可能存在左值引用与右值引用和右值引用与右值引用的折叠，C++11 确定了引用折叠的规则，规则是这样的：</p>
<ul>
<li>所有的右值引用叠加到右值引用上仍然还是一个右值引用；</li>
<li>所有的其他引用类型之间的叠加都将变成左值引用。</li>
</ul>
<p><strong>完美转发</strong>：C++11 引入了完美转发：在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11中的 <code>std::forward</code> 正是做这个事情的，他会按照参数的实际类型进行转发</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processValue</span><span class="params">(<span class="keyword">int</span>&amp; a)</span></span>&#123; cout &lt;&lt; <span class="string">&quot;lvalue&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processValue</span><span class="params">(<span class="keyword">int</span>&amp;&amp; a)</span></span>&#123; cout &lt;&lt; <span class="string">&quot;rvalue&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forwardValue</span><span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">processValue</span>(std::forward&lt;T&gt;(val)); <span class="comment">//照参数本来的类型进行转发。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Testdelcl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    forwardValue(i); <span class="comment">//传入左值 lvaue </span></span><br><span class="line">    forwardValue(<span class="number">0</span>);<span class="comment">//传入右值  rvalue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>右值引用 <code>T&amp;&amp;</code> 是一个 universal references，可以接受左值或者右值，正是这个特性让他适合作为一个参数的路由，然后再通过 <code>std::forward</code> 按照参数的实际类型去匹配对应的重载函数，最终实现完美转发。</p>
<h4 id="std-move-函数的实现原理">std::move() 函数的实现原理</h4>
<p><code>std::move()</code> 函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：引用折叠原理</p>
<ul>
<li>右值传递给上述函数的形参 <code>T&amp;&amp;</code> 依然是右值，即 <code>T&amp;&amp; &amp;&amp;</code> 相当于 <code>T&amp;&amp;</code>。</li>
<li>左值传递给上述函数的形参 <code>T&amp;&amp;</code> 依然是左值，即 <code>T&amp;&amp; &amp;</code> 相当于 <code>T&amp;</code>。</li>
</ul>
<p>小结：通过引用折叠原理可以知道，<code>move()</code> 函数的形参既可以是左值也可以是右值。</p>
<p><code>remove_reference</code> 具体实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原始的，最通用的版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;  <span class="comment">//定义 T 的类型别名为 type</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//部分版本特例化，将用于左值引用和右值引用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;</span>T&amp;&gt; <span class="comment">//左值引用</span></span><br><span class="line">&#123; <span class="keyword">typedef</span> T type; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;</span>T&amp;&amp;&gt; <span class="comment">//右值引用</span></span><br><span class="line">&#123; <span class="keyword">typedef</span> T type; &#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//举例如下,下列定义的a、b、c三个变量都是int类型</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">remove_refrence&lt;<span class="keyword">decltype</span>(<span class="number">42</span>)&gt;::type a;             <span class="comment">//使用原版本，</span></span><br><span class="line">remove_refrence&lt;<span class="keyword">decltype</span>(i)&gt;::type  b;             <span class="comment">//左值引用特例版本</span></span><br><span class="line">remove_refrence&lt;<span class="keyword">decltype</span>(std::<span class="built_in">move</span>(i))&gt;::type  b;  <span class="comment">//右值引用特例版本 </span></span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line">转化过程：</span><br><span class="line"><span class="number">1.</span> std::<span class="built_in">move</span>(var) =&gt; std::<span class="built_in">move</span>(<span class="keyword">int</span>&amp;&amp; &amp;) =&gt; 折叠后 std::<span class="built_in">move</span>(<span class="keyword">int</span>&amp;)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 此时：T 的类型为 <span class="keyword">int</span>&amp;，<span class="keyword">typename</span> remove_reference&lt;T&gt;::type 为 <span class="keyword">int</span>，这里使用 remove_reference 的左值引用的特例化版本</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 通过 <span class="keyword">static_cast</span> 将 <span class="keyword">int</span>&amp; 强制转换为 <span class="keyword">int</span>&amp;&amp;</span><br><span class="line"></span><br><span class="line">整个std::move被实例化如下</span><br><span class="line">string&amp;&amp; <span class="built_in">move</span>(<span class="keyword">int</span>&amp; t) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp;&amp;&gt;(t); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p><code>std::move()</code> 实现原理：</p>
<ol>
<li>利用引用折叠原理将右值经过 <code>T&amp;&amp;</code> 传递类型保持不变还是右值，而左值经过 <code>T&amp;&amp;</code> 变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变；</li>
<li>然后通过 <code>remove_refrence</code> 移除引用，得到具体的类型 <code>T</code>；</li>
<li>最后通过 <code>static_cast&lt;&gt;</code> 进行强制类型转换，返回 <code>T&amp;&amp;</code> 右值引用。</li>
</ol>
<h4 id="什么是指针？指针的大小及用法？">什么是指针？指针的大小及用法？</h4>
<p><strong>指针：</strong> 指向另外一种类型的复合类型。</p>
<p><strong>指针的大小：</strong> 在 32 位计算机中，指针占用 4 个字节空间；在 64 位计算机中，指针占 8 个字节空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p1) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>指针的用法：</strong></p>
<ol>
<li>
<p>指向普通对象的指针</p>
</li>
<li>
<p>指向常量对象的指针：常量指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_var = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> * p = &amp;c_var;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指向函数的指针：函数指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*fun_p)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">    fun_p = add;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">fun_p</span>(<span class="number">1</span>, <span class="number">6</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指向对象成员的指针，包括指向对象成员函数的指针和指向对象成员变量的指针。<br>
特别注意：定义指向成员函数的指针时，要标明指针所属的类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> var1, var2; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> var1 + var2; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A ex;</span><br><span class="line">    ex.var1 = <span class="number">3</span>;</span><br><span class="line">    ex.var2 = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> *p1 = &amp;ex.var1; <span class="comment">// 指向对象成员变量的指针 3</span></span><br><span class="line">    cout &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">int</span> A::*p2 = &amp;A::var2;</span><br><span class="line">    cout &lt;&lt; ex.*p2 &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (A::*fun_p)();</span><br><span class="line">    fun_p = &amp;A::add; <span class="comment">// 指向对象成员函数的指针 fun_p 7</span></span><br><span class="line">    cout &lt;&lt; (ex.*fun_p)() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>this 指针：指向类的当前对象的指针常量。</p>
</li>
</ol>
<h4 id="什么是野指针和悬空指针？">什么是野指针和悬空指针？</h4>
<ul>
<li>
<p>悬空指针：</p>
<p>若指针指向一块内存空间，当这块内存空间被释放后，该指针依然指向这块内存空间，此时，称该指针为“悬空指针”。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="built_in">free</span>(p); </span><br><span class="line"><span class="comment">// 此时，p 指向的内存空间已释放， p 就是悬空指针。</span></span><br><span class="line"></span><br><span class="line">p = <span class="literal">nullptr</span>; <span class="comment">// 现在 p 就不是悬空指针了</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>野指针：</p>
<p>“野指针” 是指不确定其指向的指针，未初始化的指针为“野指针”。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p; </span><br><span class="line"><span class="comment">// 此时 p 是“野指针”。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="C-11-nullptr-比-NULL-优势">C++ 11 nullptr 比 NULL 优势</h4>
<ul>
<li><code>NULL</code>：预处理变量，是一个宏，它的值是 0，定义在头文件 <code>&lt;cstdlib&gt;</code> 中，即 <code>#define NULL 0</code>。</li>
<li><code>nullptr</code>：C++ 11 中的关键字，是一种特殊类型的字面值，nullptr 可以转换成任意其他指针类型。</li>
</ul>
<p><code>nullptr</code> 的优势：</p>
<ol>
<li>有类型，类型是 <code>typdef decltype(nullptr) nullptr_t;</code>，使用 <code>nullptr</code> 提高代码的健壮性。</li>
<li>函数重载：因为 <code>NULL</code> 本质上是 0，在函数调用过程中，若出现函数重载并且传递的实参是 <code>NULL</code>，可能会出现，不知和哪一个函数匹配的情况；但是传递实参 <code>nullptr</code> 就不会出现这种情况，<code>nullptr</code> 本身是<strong>指针类型</strong>，不能转化为整数类型，否则还会在重载时出现二义性问题。</li>
</ol>
<ul>
<li>C++</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *p)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;fun(char const *p)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;fun(int tmp)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">nullptr</span>); <span class="comment">// fun(char const *p)</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">NULL</span>); <span class="comment">// error: call of overloaded &#x27;fun(NULL)&#x27; is ambiguous</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指针和引用的区别？">指针和引用的区别？</h4>
<ul>
<li>指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变绑定的对象。（是否可变）</li>
<li>指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。（是否占内存）</li>
<li>指针可以为空，但是引用必须绑定对象。（是否可为空）</li>
<li>指针可以有多级，但是引用只能一级。（是否能为多级）</li>
</ul>
<p>引用是否占内存，取决于编译器的实现。<br>
如果编译器用指针实现引用，那么它占内存。<br>
如果编译器直接将引用替换为其所指的对象，则其不占内存（毕竟，替换掉之后，该引用实际就不存在了）。</p>
<p>顺便一提，你无法用 sizeof 得到引用的大小，sizeof 作用于引用时，你得到的是它对应的对象的大小。</p>
<h4 id="常量指针和指针常量的区别">常量指针和指针常量的区别</h4>
<p><strong>常量指针：</strong><br>
常量指针本质上是个指针，只不过这个指针指向的对象是常量。<br>
特点：<code>const</code> 的位置在指针声明运算符 <code>*</code> 的左侧。</p>
<p><strong>只要 <code>const</code> 位于 <code>*</code> 的左侧，无论它在类型名的左边或右边，都表示指向常量的指针</strong>。（可以这样理解，<code>*</code> 左侧表示指针指向的对象，该对象为常量，那么该指针为常量指针。）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * p;</span><br></pre></td></tr></table></figure>
<p>注意 1：指针指向的对象不能通过这个指针来修改，也就是说常量指针可以被赋值为变量的地址，之所以叫做常量指针，是限制了通过这个指针修改变量的值。<br>
例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_var = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;c_var; </span><br><span class="line">    *p = <span class="number">6</span>;            <span class="comment">// error: assignment of read-only location &#x27;* p&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 2：虽然常量指针指向的对象不能变化，可是因为常量指针本身是一个变量，因此，可以被重新赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_var1 = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_var2 = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;c_var1; </span><br><span class="line">    p = &amp;c_var2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>指针常量：</strong><br>
指针常量的本质上是个常量，只不过这个常量的值是一个指针。<br>
特点：<strong><code>const</code> 位于指针声明操作符右侧，表明该对象本身是一个常量，<code>*</code> 左侧表示该指针指向的类型，即以 <code>*</code> 为分界线，其左侧表示指针指向的类型，右侧表示指针本身的性质。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> var;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> c_p = &amp;var; </span><br></pre></td></tr></table></figure>
<p>注意 1：指针常量的值是指针，这个值因为是常量，所以指针本身不能改变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var, var1;</span><br><span class="line">    <span class="keyword">int</span> * <span class="keyword">const</span> c_p = &amp;var;</span><br><span class="line">    c_p = &amp;var1; <span class="comment">// error: assignment of read-only variable &#x27;c_p&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 2：指针的内容可以改变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> * <span class="keyword">const</span> c_p = &amp;var;</span><br><span class="line">    *c_p = <span class="number">12</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数指针和指针函数的区别">函数指针和指针函数的区别</h4>
<p><strong>指针函数：</strong><br>
指针函数本质是一个函数，只不过该函数的返回值是一个指针。相对于普通函数而言，只是返回值是指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Type</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> var1;</span><br><span class="line">  <span class="keyword">int</span> var2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Type * <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp1, <span class="keyword">int</span> tmp2)</span></span>&#123;</span><br><span class="line">    Type * t = <span class="keyword">new</span> <span class="built_in">Type</span>();</span><br><span class="line">    t-&gt;var1 = tmp1;</span><br><span class="line">    t-&gt;var2 = tmp2;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Type *p = <span class="built_in">fun</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数指针：</strong><br>
函数指针本质是一个指针变量，只不过这个指针指向一个函数。函数指针即指向函数的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> tmp1, <span class="keyword">int</span> tmp2)</span> </span>&#123; <span class="keyword">return</span> tmp1 * tmp2; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> tmp1, <span class="keyword">int</span> tmp2)</span> </span>&#123; <span class="keyword">return</span> tmp1 / tmp2; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">int</span></span> (*fun)(<span class="keyword">int</span> x, <span class="keyword">int</span> y); </span><br><span class="line">  fun = fun1;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">fun</span>(<span class="number">15</span>, <span class="number">5</span>) &lt;&lt; endl; </span><br><span class="line">  fun = fun2;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">fun</span>(<span class="number">15</span>, <span class="number">5</span>) &lt;&lt; endl; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">75</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>函数指针和指针函数的区别：</strong></p>
<ul>
<li>本质不同
<ul>
<li>指针函数本质是一个函数，其返回值为指针。</li>
<li>函数指针本质是一个指针变量，其指向一个函数。</li>
</ul>
</li>
<li>定义形式不同
<ul>
<li>指针函数：<code>int* fun(int tmp1, int tmp2);</code> ，这里<code>*</code> 表示函数的返回值类型是指针类型。</li>
<li>函数指针：<code>int (*fun)(int tmp1, int tmp2);</code>，这里<code>*</code> 表示变量本身是指针类型。</li>
</ul>
</li>
<li>用法不同</li>
</ul>
<h4 id="强制类型转换有哪几种？">强制类型转换有哪几种？</h4>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static_cast</td>
<td>用于良性转换，一般不会导致意外发生，风险很低。</td>
</tr>
<tr>
<td>const_cast</td>
<td>用于 const 与非 const、volatile 与非 volatile 之间的转换。</td>
</tr>
<tr>
<td>reinterpret_cast</td>
<td>高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换。</td>
</tr>
<tr>
<td>dynamic_cast</td>
<td>借助 RTTI（运行时类型识别），用于类型安全的向下转型（Downcasting）。</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>static_cast</code>：用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。</p>
<ol>
<li>
<p>用于基本数据类型的转换。</p>
</li>
<li>
<p>用于类层次之间的基类和派生类之间 <strong>指针或者引用</strong> 的转换（<strong>不要求必须包含虚函数，但必须是有相互联系的类</strong>），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用 <code>dynamic_cast</code> 进行下行转换。</p>
</li>
<li>
<p>可以将空指针转化成目标类型的空指针。</p>
</li>
<li>
<p>可以将任何类型的表达式转化成 <code>void</code> 类型。</p>
</li>
<li>
<blockquote>
<p>static_cast 只能用于良性转换，这样的转换风险较低，一般不会发生什么意外，例如：</p>
<ul>
<li>原有的自动类型转换，例如 short 转 int、int 转 double、const 转非 const、向上转型等；</li>
<li>void 指针和具体类型指针之间的转换，例如<code>void *</code>转<code>int *</code>、<code>char *</code>转<code>void *</code>等；</li>
<li>有转换构造函数或者类型转换函数的类与其它类型之间的转换，例如 double 转 Complex（调用转换构造函数）、Complex 转 double（调用类型转换函数）。</li>
</ul>
<p>需要注意的是，static_cast 不能用于无关类型之间的转换，因为这些转换都是有风险的，例如：</p>
<ul>
<li>两个具体类型指针之间的转换，例如<code>int *</code>转<code>double *</code>、<code>Student *</code>转<code>int *</code>等。不同类型的数据存储格式不一样，长度也不一样，用 A 类型的指针指向 B 类型的数据后，会按照 A 类型的方式来处理数据：如果是读取操作，可能会得到一堆没有意义的值；如果是写入操作，可能会使 B 类型的数据遭到破坏，当再次以 B 类型的方式读取数据时会得到一堆没有意义的值。</li>
<li>int 和指针之间的转换。将一个具体的地址赋值给指针变量是非常危险的，因为该地址上的内存可能没有分配，也可能没有读写权限，恰好是可用内存反而是小概率事件。</li>
</ul>
<p>static_cast 也不能用来去掉表达式的 const 修饰和 volatile 修饰。换句话说，不能将 const/volatile 类型转换为非 const/volatile 类型。</p>
<p><strong>static_cast 是“静态转换”的意思，也就是在编译期间转换，转换失败的话会抛出一个编译错误。</strong></p>
</blockquote>
</li>
</ol>
</li>
<li>
<p><code>const_cast</code>：const_cast 比较好理解，它用来去掉表达式的 const 修饰或 volatile 修饰。换句话说，const_cast 就是用来将 const/volatile 类型转换为非 const/volatile 类型。</p>
</li>
<li>
<p><code>reinterpret_cast</code>：reinterpret 是“重新解释”的意思，顾名思义，reinterpret_cast 这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高。reinterpret_cast 可以认为是 static_cast 的一种补充，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成，例如两个具体类型指针之间的转换、int 和指针之间的转换（有些编译器只允许 int 转指针，不允许反过来）。</p>
</li>
<li>
<p><code>dynamic_cast</code>：</p>
<ul>
<li>
<p>dynamic_cast 用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功。</p>
</li>
<li>
<p>其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时会进行类型检查。</p>
</li>
<li>
<p>只能用于<strong>带有虚函数</strong>的基类或派生类的指针或者引用对象的转换，转换成功返回指向类型的指针或引用，转换失败返回 <code>NULL</code>；不能用于基本数据类型的转换。</p>
</li>
<li>
<p>在向上进行转换时，即派生类类的指针转换成基类类的指针和 <code>static_cast</code> 效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）。</p>
</li>
<li>
<p>在下行转换时，基类的指针类型转化为派生类类的指针类型，只有当要转换的指针指向的对象类型是转化以后的对象类型及其后代，才会转化成功。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Class A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Class B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Class C&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> C &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Class D&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A *pa = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">  B *pb;</span><br><span class="line">  C *pc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//情况①</span></span><br><span class="line">  pb = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pa);  <span class="comment">//向下转型失败</span></span><br><span class="line">  <span class="keyword">if</span> (pb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Downcasting failed: A* to B*&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Downcasting successfully: A* to B*&quot;</span> &lt;&lt; endl;</span><br><span class="line">    pb-&gt;<span class="built_in">func</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  pc = <span class="keyword">dynamic_cast</span>&lt;C *&gt;(pa);  <span class="comment">//向下转型失败</span></span><br><span class="line">  <span class="keyword">if</span> (pc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Downcasting failed: A* to C*&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Downcasting successfully: A* to C*&quot;</span> &lt;&lt; endl;</span><br><span class="line">    pc-&gt;<span class="built_in">func</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;-------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//情况②</span></span><br><span class="line">  pa = <span class="keyword">new</span> <span class="built_in">D</span>();                <span class="comment">//向上转型都是允许的</span></span><br><span class="line">  pb = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pa);  <span class="comment">//向下转型成功</span></span><br><span class="line">  <span class="keyword">if</span> (pb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Downcasting failed: A* to B*&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Downcasting successfully: A* to B*&quot;</span> &lt;&lt; endl;</span><br><span class="line">    pb-&gt;<span class="built_in">func</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  pc = <span class="keyword">dynamic_cast</span>&lt;C *&gt;(pa);  <span class="comment">//向下转型成功</span></span><br><span class="line">  <span class="keyword">if</span> (pc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Downcasting failed: A* to C*&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Downcasting successfully: A* to C*&quot;</span> &lt;&lt; endl;</span><br><span class="line">    pc-&gt;<span class="built_in">func</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="如何判断结构体是否相等？能否用-memcmp-函数判断结构体相等？">如何判断结构体是否相等？能否用 memcmp 函数判断结构体相等？</h4>
<p>需要重载操作符 <code>==</code> 判断两个结构体是否相等，不能用函数 <code>memcmp</code> 来判断两个结构体是否相等，因为 <code>memcmp</code> 函数是逐个字节进行比较的，而结构体存在内存空间中保存时存在字节对齐，字节对齐时补的字节内容是随机的，会产生垃圾值，所以无法比较。</p>
<p>利用运算符重载来实现结构体对象的比较：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">char</span> c_tmp, <span class="keyword">int</span> tmp) : <span class="built_in">c</span>(c_tmp), <span class="built_in">val</span>(tmp) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> A &amp;tmp1, <span class="keyword">const</span> A &amp;tmp2);  <span class="comment">//  友元运算符重载函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> A &amp;tmp1, <span class="keyword">const</span> A &amp;tmp2) &#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">return</span></span> (tmp1.c == tmp2.c &amp;&amp; tmp1.val == tmp2.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">A <span class="title">ex1</span><span class="params">(<span class="string">&#x27;a&#x27;</span>, <span class="number">90</span>)</span>, <span class="title">ex2</span><span class="params">(<span class="string">&#x27;b&#x27;</span>, <span class="number">80</span>)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (ex1 == ex2)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ex1 == ex2&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ex1 != ex2&quot;</span> &lt;&lt; endl;  <span class="comment">// 输出</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于重载 <code>==</code> 双目操作符!!!</p>
<p>操作符 <code>==</code> 为双目操作符，因此只接受两个参数。这时在类内定义或声明操作符时需要特别注意，因为类的成员函数会有隐含的 this 指针，如果定义为 <code>bool operator==(const A &amp;tmp1, const A &amp;tmp2)</code> ，实则有三个参数，在编译时会报错提示参数太多。</p>
<p>针对以上问题解决方法有以下三种：</p>
<ol>
<li><strong>如本示例一样，定义为友元函数，则不会有隐含的this指针。</strong></li>
<li><strong>在类外定义重载操作符，成为全局函数。</strong></li>
<li><strong>在类内定义重载操作符（非友元函数），但只含一个参数，加上隐含的this指针，共两个参数。</strong></li>
</ol>
<h4 id="参数传递时，值传递、引用传递、指针传递的区别？">参数传递时，值传递、引用传递、指针传递的区别？</h4>
<p>参数传递的三种方式：</p>
<ul>
<li>值传递：形参是实参的拷贝，函数对形参的所有操作不会影响实参。</li>
<li>指针传递：本质上是值传递，只不过拷贝的是指针的值，拷贝之后，实参和形参是不同的指针，通过指针可以间接的访问指针所指向的对象，从而可以修改它所指对象的值。</li>
<li>引用传递：当形参是引用类型时，我们说它对应的实参被引用传递。</li>
</ul>
<h4 id="什么是模板？如何实现？">什么是模板？如何实现？</h4>
<p>模板：创建类或者函数的蓝图或者公式，分为函数模板和类模板。<br>
实现方式：模板定义以关键字 <code>template</code> 开始，后跟一个模板参数列表。</p>
<ul>
<li>模板参数列表不能为空；</li>
<li>模板类型参数前必须使用关键字 <code>class</code> 或者 <code>typename</code>，在模板参数列表中这两个关键字含义相同，可互换使用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, ...&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>函数模板：通过定义一个函数模板，可以避免为每一种类型定义一个新函数。</p>
<ul>
<li>对于函数模板而言，模板类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。</li>
<li>函数模板实例化：<strong>当调用一个模板时，编译器用函数实参来推断模板实参，从而使用实参的类型来确定绑定到模板参数的类型</strong>。</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add_fun</span><span class="params">(<span class="keyword">const</span> T&amp; tmp1, <span class="keyword">const</span> T&amp; tmp2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tmp1 + tmp2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var1, var2;</span><br><span class="line">  cin &gt;&gt; var1 &gt;&gt; var2;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">add_fun</span>(var1, var2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> var3, var4;</span><br><span class="line">  cin &gt;&gt; var3 &gt;&gt; var4;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">add_fun</span>(var3, var4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类模板：类似函数模板，类模板以关键字 <code>template</code> 开始，后跟模板参数列表。但是，<strong>编译器不能为类模板推断模板参数类型，需要在使用该类模板时，在模板名后面的尖括号中指明类型</strong>。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="built_in">Complex</span>(T a, T b) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//运算符重载</span></span><br><span class="line">  Complex&lt;T&gt; <span class="keyword">operator</span>+(Complex &amp;c) &#123;</span><br><span class="line">    <span class="function">Complex&lt;T&gt; <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a + c.a, <span class="keyword">this</span>-&gt;b + c.b)</span></span>;</span><br><span class="line">    cout &lt;&lt; tmp.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; tmp.b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  T a;</span><br><span class="line">  T b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">  <span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">  Complex&lt;<span class="keyword">int</span>&gt; c = a + b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="函数模板和类模板的区别？">函数模板和类模板的区别？</h4>
<ul>
<li>实例化方式不同：函数模板实例化由编译程序在处理函数调用时自动完成，类模板实例化需要在程序中显式指定。</li>
<li>重载：函数模板是可以被重载的（类模板不能被重载），也就是说允许存在两个同名的函数模板，还可以对它们进行实例化，使它们具有相同的参数类型。</li>
<li>默认参数：类模板在模板参数列表中可以有默认参数。在C++11 中函数模板也可以使用默认参数，且不用像类模板一样严格按照从右到左的顺序定义默认参数。</li>
<li>特化：函数模板只能全特化；而类模板可以全特化，也可以偏特化。再次划重点 <strong>函数模板不能被偏特化</strong>。</li>
<li>调用方式不同：函数模板可以隐式调用，也可以显式调用；类模板只能显式调用。但在 C++17 中引入了 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">CTAD</a>，类的模板参数也不一定需要显示指定了</li>
</ul>
<p>函数模板重载、调用方式举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(T)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数模板的重载</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(T*)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add_fun</span><span class="params">(<span class="keyword">const</span> T&amp; tmp1, <span class="keyword">const</span> T&amp; tmp2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tmp1 + tmp2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 函数模板重载示例</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">  cout &lt;&lt; fun&lt;<span class="keyword">int</span>*&gt;(p) &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line">  cout &lt;&lt; fun&lt;<span class="keyword">int</span>&gt;(p) &lt;&lt; endl;   <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数模板调用示例</span></span><br><span class="line">  <span class="keyword">int</span> var1 = <span class="number">1</span>, var2 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">double</span> var3 = <span class="number">1.1</span>, var4 = <span class="number">2.2</span>;</span><br><span class="line">  cout &lt;&lt; add_fun&lt;<span class="keyword">int</span>&gt;(var1, var2) &lt;&lt; endl;  <span class="comment">// 显式调用 3</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">add_fun</span>(var3, var4) &lt;&lt; endl;       <span class="comment">// 隐式调用 3.3</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>偏特例化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(T1 value1, T2 value2)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value1 = &quot;</span> &lt;&lt; value1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value2 = &quot;</span> &lt;&lt; value2 &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;</span>T, <span class="keyword">double</span>&gt; &#123;  <span class="comment">// 部分类型明确化，为偏特化类</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(T value1, <span class="keyword">double</span> value2)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value = &quot;</span> &lt;&lt; value1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;doubleValue = &quot;</span> &lt;&lt; value2 &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A&lt;<span class="keyword">char</span>, <span class="keyword">double</span>&gt; a;</span><br><span class="line">  a.<span class="built_in">function</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">12.3</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="什么是可变参数模板？">什么是可变参数模板？</h4>
<p>可变参数模板：接受可变数目参数的模板函数或模板类。将可变数目的参数被称为参数包，包括模板参数包和函数参数包。</p>
<ul>
<li>模板参数包：表示零个或多个模板参数；</li>
<li>函数参数包：表示零个或多个函数参数。</li>
</ul>
<p>用省略号来指出一个模板参数或函数参数表示一个包，在模板参数列表中，<code>class...</code> 或 <code>typename...</code> 指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。当需要知道包中有多少元素时，可以使用 <code>sizeof...</code> 运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt; <span class="comment">// Args 是模板参数包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;... rest)</span></span>; <span class="comment">// 可变参数模板，rest 是函数参数包</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_fun</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; t &lt;&lt; endl;  <span class="comment">// 最后一个元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_fun</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args &amp;...args)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="built_in">print_fun</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">print_fun</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment">Hello world !</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>说明：<strong>可变参数函数通常是递归的</strong>，第一个版本的 <code>print_fun</code> 负责终止递归并打印初始调用中的最后一个实参。第二个版本的 <code>print_fun</code> 是可变参数版本，打印绑定到 t 的实参，并用来调用自身来打印函数参数包中的剩余值。</p>
<h4 id="什么是模板特化？为什么特化？">什么是模板特化？为什么特化？</h4>
<p>模板特化的原因：模板并非对任何模板实参都合适、都能实例化，某些情况下，通用模板的定义对特定类型不合适，可能会编译失败，或者得不到正确的结果。因此，当不希望使用模板版本时，可以定义类或者函数模板的一个特例化版本。</p>
<p>模板特化：模板参数在某种特定类型下的具体实现。分为函数模板特化和类模板特化</p>
<ul>
<li>函数模板特化：将函数模板中的全部类型进行特例化，称为函数模板特化。</li>
<li>类模板特化：将类模板中的部分或全部类型进行特例化，称为类模板特化。</li>
</ul>
<p>特化分为全特化和偏特化：</p>
<ul>
<li>全特化：模板中的模板参数全部特例化。</li>
<li>偏特化：模板中的模板参数只确定了一部分，剩余部分需要在编译器编译时确定。</li>
</ul>
<p>说明：要区分下函数重载与函数模板特化<br>
定义函数模板的特化版本，本质上是接管了编译器的工作，为原函数模板定义了一个特殊实例，而不是函数重载，函数模板特化并不影响函数匹配。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T t1, T t2)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;通用版本：&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> t1 == t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;  <span class="comment">//函数模板特化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">char</span> *t1, <span class="keyword">char</span> *t2)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;特化版本：&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(t1, t2) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> arr1[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="keyword">char</span> arr2[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">compare</span>(<span class="number">123</span>, <span class="number">123</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">compare</span>(arr1, arr2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">通用版本：1</span></span><br><span class="line"><span class="comment">特化版本：0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="include-和-的区别">include &quot; &quot; 和 &lt;&gt; 的区别</h4>
<p><code>include&lt;文件名&gt;</code> 和 <code>#include&quot;文件名&quot;</code> 的区别:</p>
<ul>
<li>查找文件的位置：<code>include&lt;文件名&gt;</code> 在标准库头文件所在的目录中查找，如果没有，编译器会终止查找，直接报错：No such file or directory.；<code>#include&quot;文件名&quot;</code> 在当前源文件所在目录中进行查找，如果没有；再到系统目录中查找。</li>
<li>使用习惯：对于标准库中的头文件常用 <code>include&lt;文件名&gt;</code>，对于自己定义的头文件，常用 <code>#include&quot;文件名&quot;</code></li>
</ul>
<p>注意：虽然 <code>#include&quot;&quot;</code> 的查找范围更广，但是这并不意味着，不论是系统头文件，还是自定义头文件，一律用 <code>#include&quot;&quot;</code>包含。因为 <code>#include&quot; &quot;</code> 的查找顺序存在先后关系，如果项目当前目录或者引用目录下存在和系统目录下重名的头文件，那么编译器在当前目录或者引用目录查找成功后，将不会继续查找，所以存在头文件覆盖的问题。另外，对于系统头文件，用 <code>#include&lt;&gt;</code>包含，查找时一步到位，程序编译时的效率也会相对更高。</p>
<h4 id="switch-的-case-里定义变量细节">switch 的 case 里定义变量细节</h4>
<ol>
<li>
<p>报错</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (var) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">0</span>;  </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a.cpp:9:11: note:   crosses initialization of &#x27;int cnt&#x27;</span></span><br><span class="line"><span class="comment">    9 |       int a = 0;</span></span><br><span class="line"><span class="comment">      |           ^~~</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>错误原因<br>
究其根本原因，是C++的一条规则：<strong>在任何作用域内，假如存在变量初始化语句，该初始化语句不可以被跳过，一定要执行！</strong><br>
这里强调在作用域内的变量一旦初始化就不能跳过，但是可以跳过整个作用域！<br>
比如初始化语句 <code>int a = 0;</code>，就有虽然进入其所在的作用域，但是不被执行的风险，所以就报错了！</p>
</li>
<li>
<p>如何修改</p>
<ol>
<li>
<p>把 int a; 移到 switch 和 case 之间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (var) &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      a = <span class="number">0</span>;  </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在case后+作用域符号{}</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (var) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这两种修改，都保证了只要进入a的作用域，都会执行a的初始化语句！</p>
</li>
<li>
<p>判断对错</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (var) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">int</span> a;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      a = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在C++中是正常编译和执行的，因为：int a 只是定义了 a，并没有初始化，没有违背上述规则！<br>
编译的时候，编译到case 0 的时候分配空间，运行到case 1的时候赋值，a 的作用域就是定义后开始到 switch 结束的整个作用域</p>
</li>
<li>
<p>关于声明、定义和初始化：<br>
①声明变量不会分配内存空间；<br>
②定义变量int a，编译的时候会分配内存，但是并不会产生任何可执行的代码，所以int a这句话只是在编译的时候有用，执行的时候跳过的时候也无所谓！<br>
③初始化变量分配空间并初始化（编译时分配空间，运行时初始化赋值），假如存在，一定要执行！</p>
</li>
</ol>
<h4 id="迭代器的作用？">迭代器的作用？</h4>
<ul>
<li>
<p>迭代器：一种抽象的设计概念，在设计模式中有迭代器模式，即<strong>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而无需暴露该容器的内部表述方式</strong>。</p>
</li>
<li>
<p>作用：<strong>在无需知道容器底层原理的情况下，遍历容器中的元素</strong>。</p>
</li>
</ul>
<h4 id="泛型编程如何实现？">泛型编程如何实现？</h4>
<p>泛型编程实现的基础：模板。模板是创建类或者函数的蓝图或者说公式，当时用一个 <code>vector</code> 这样的泛型，或者 <code>find</code> 这样的泛型函数时，编译时会转化为特定的类或者函数。</p>
<p>标准模板库的六大组件：<br>
1、容器<br>
2、算法<br>
3、迭代器<br>
4、分配器<br>
5、仿函数<br>
6、适配器</p>
<h4 id="什么是类型萃取？">什么是类型萃取？</h4>
<p>类型萃取使用模板技术来萃取类型（包含自定义类型和内置类型）的某些特性，用以判断该类型是否含有某些特性，从而在泛型算法中来对该类型进行特殊的处理用来提高效率或者其他。</p>
<p>C++ 类型萃取一般用于模板中，当我们定义一个模板函数后，需要知道模板类型形参并加以运用时就可以用类型萃取。</p>
<ul>
<li>比如我们需要在函数中进行拷贝，通常我们可以用内置函数 <code>memcpy</code> 或者自己写一个 for 循环来进行拷贝。</li>
</ul>
<h3 id="C-设计模式">C++ 设计模式</h3>
<h4 id="什么是单例模式？如何实现？应用场景？">什么是单例模式？如何实现？应用场景？</h4>
<p><strong>单例模式</strong>：<strong>保证类的实例化对象仅有一个，并且提供一个访问他的全局访问点</strong>。</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li>表示文件系统的类，一个操作系统一定是只有一个文件系统，因此文件系统的类的实例有且仅有一个。</li>
<li>打印机打印程序的实例，一台计算机可以连接好几台打印机，但是计算机上的打印程序只有一个，就可以通过单例模式来避免两个打印作业同时输出到打印机。</li>
</ul>
<p><strong>实现方式：</strong><br>
单例模式可以通过全局或者静态变量的形式实现，这样比较简单，但是这样会影响封装性，难以保证别的代码不会对全局变量造成影响。</p>
<ul>
<li><strong>默认的构造函数、拷贝构造函数、拷贝赋值运算符声明为私有的</strong>，这样禁止在类的外部创建该对象；</li>
<li>全局访问点也要定义成 <strong>静态类型的成员函数</strong>，没有参数，返回该类的指针类型。因为使用实例化对象的时候是通过类直接调用该函数，并不是先创建一个该类的对象，通过对象调用。</li>
</ul>
<p>不安全的实现方式：<br>
原因：考虑当两个线程同时调用 <code>getInstance</code> 方法，并且同时检测到 <code>instance</code> 是 <code>NULL</code>，两个线程会同时实例化对象，不符合单例模式的要求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton * instance;</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp; tmp)&#123;&#125;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp; tmp)&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* <span class="built_in">getInstance</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p><strong>分类：</strong></p>
<ul>
<li>懒汉模式：直到第一次用到类的实例时才去实例化，上面是懒汉实现。</li>
<li>饿汉模式：类定义的时候就实例化。</li>
</ul>
<p>线程安全的懒汉模式实现：<br>
方法一：<strong>加锁</strong><br>
存在的问题：每次判断实例对象是否为空，都要被锁定，如果是多线程的话，就会造成大量线程阻塞。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">static</span> Singleton * instance;</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp; tmp)&#123;&#125;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp; tmp)&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* <span class="built_in">getInstance</span>()&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">NULL</span>)&#123;            </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> Singleton::mutex;</span><br></pre></td></tr></table></figure>
<p>方法二：<strong>内部静态变量</strong>，<strong>在全局访问点 <code>getInstance</code> 中定义静态实例</strong>。推荐！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp; temp)&#123;&#125;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp; temp)&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* <span class="built_in">getInstance</span>()&#123; </span><br><span class="line">        <span class="keyword">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> Singleton::mutex; </span><br></pre></td></tr></table></figure>
<p>饿汉模式的实现：<br>
<strong>饿汉模式本身就是线程安全的不用加锁。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* instance;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp; temp)&#123;&#125;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp; temp)&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> <span class="built_in">Singleton</span>()&#123;&#125; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* <span class="built_in">getInstance</span>()&#123; </span><br><span class="line">        <span class="keyword">return</span> instance;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br></pre></td></tr></table></figure>
<p>懒汉式是以时间换空间，适应于访问量较小时；推荐使用内部静态变量的懒汉单例，代码量少。</p>
<p>饿汉式是以空间换时间，适应于访问量较大时，或者线程比较多的的情况。</p>
<h4 id="什么是工厂模式？如何实现？应用场景？">什么是工厂模式？如何实现？应用场景？</h4>
<p><strong>工厂模式</strong>：包括简单工厂模式、抽象工厂模式、工厂方法模式</p>
<ul>
<li>简单工厂模式：主要用于创建对象。用一个工厂来根据输入的条件产生不同的类，然后根据不同类的虚函数得到不同的结果。</li>
<li>工厂方法模式：修正了简单工厂模式中不遵守开放封闭原则。把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。</li>
<li>抽象工厂模式：定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类。</li>
</ul>
<ol>
<li>
<p>简单工厂模式<br>
主要用于创建对象。用一个工厂来根据输入的条件产生不同的类，然后根据不同类的虚函数得到不同的结果。<br>
<strong>应用场景</strong>：</p>
<ul>
<li>适用于针对不同情况创建不同类时，只需传入工厂类的参数即可，无需了解具体实现方法。例如：计算器中对于同样的输入，执行不同的操作：加、减、乘、除。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is the product class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> var1, var2;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add_Operation</span> :</span> <span class="keyword">public</span> Operation &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> var1 + var2; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub_Operation</span> :</span> <span class="keyword">public</span> Operation &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> var1 - var2; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mul_Operation</span> :</span> <span class="keyword">public</span> Operation &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> var1 * var2; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Div_Operation</span> :</span> <span class="keyword">public</span> Operation &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> var1 / var2; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is the Factory class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Operation *<span class="title">CreateProduct</span><span class="params">(<span class="keyword">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (op) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Add_Operation</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Sub_Operation</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Mul_Operation</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Div_Operation</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Add_Operation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  Operation *p = Factory::<span class="built_in">CreateProduct</span>(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">  p-&gt;var1 = a;</span><br><span class="line">  p-&gt;var2 = b;</span><br><span class="line">  cout &lt;&lt; p-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  p = Factory::<span class="built_in">CreateProduct</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  p-&gt;var1 = a;</span><br><span class="line">  p-&gt;var2 = b;</span><br><span class="line">  cout &lt;&lt; p-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>工厂方法模式<br>
修正了简单工厂模式中不遵守开放封闭原则。把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。<br>
<strong>应用场景</strong>：</p>
<ul>
<li>
<p>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</p>
</li>
<li>
<p>一个类通过其派生类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其派生类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，派生类对象将覆盖父类对象，从而使得系统更容易扩展。</p>
</li>
<li>
<p>将创建对象的任务委托给多个工厂派生类中的某一个，客户端在使用时可以无须关心是哪一个工厂派生类创建产品派生类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</p>
</li>
<li>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

// Here is the product class
class Operation &#123;
 public:
  int var1, var2;
  virtual double GetResult() &#123;
    double res = 0;
    return res;
  &#125;
&#125;;

class Add_Operation : public Operation &#123;
 public:
  virtual double GetResult() &#123; return var1 + var2; &#125;
&#125;;

class Sub_Operation : public Operation &#123;
 public:
  virtual double GetResult() &#123; return var1 - var2; &#125;
&#125;;

class Mul_Operation : public Operation &#123;
 public:
  virtual double GetResult() &#123; return var1 * var2; &#125;
&#125;;

class Div_Operation : public Operation &#123;
 public:
  virtual double GetResult() &#123; return var1 / var2; &#125;
&#125;;

class Factory &#123;
 public:
  virtual Operation *CreateProduct() = 0;
&#125;;

class Add_Factory : public Factory &#123;
 public:
  Operation *CreateProduct() &#123; return new Add_Operation(); &#125;
&#125;;

class Sub_Factory : public Factory &#123;
 public:
  Operation *CreateProduct() &#123; return new Sub_Operation(); &#125;
&#125;;

class Mul_Factory : public Factory &#123;
 public:
  Operation *CreateProduct() &#123; return new Mul_Operation(); &#125;
&#125;;

class Div_Factory : public Factory &#123;
 public:
  Operation *CreateProduct() &#123; return new Div_Operation(); &#125;
&#125;;

int main() &#123;
  int a, b;
  cin &gt;&gt; a &gt;&gt; b;
  Add_Factory *p_fac = new Add_Factory();
  Operation *p_pro = p_fac-&gt;CreateProduct();
  p_pro-&gt;var1 = a;
  p_pro-&gt;var2 = b;
  cout &lt;&lt; p_pro-&gt;GetResult() &lt;&lt; endl;

  Mul_Factory *p_fac1 = new Mul_Factory();
  Operation *p_pro1 = p_fac1-&gt;CreateProduct();
  p_pro1-&gt;var1 = a;
  p_pro1-&gt;var2 = b;
  cout &lt;&lt; p_pro1-&gt;GetResult() &lt;&lt; endl;

  return 0;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 抽象工厂模式</span><br><span class="line">   定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类。</span><br><span class="line">   **应用场景：**</span><br><span class="line"></span><br><span class="line">   -   一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</span><br><span class="line"></span><br><span class="line">   -   系统中有多于一个的产品族，而每次只使用其中某一产品族。</span><br><span class="line"></span><br><span class="line">   -   属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</span><br><span class="line"></span><br><span class="line">   -   产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的  </span><br><span class="line">       产品等级结构。</span><br><span class="line">       </span><br><span class="line">   - ```cpp</span><br><span class="line">     #include &lt;iostream&gt;</span><br><span class="line">     #include &lt;vector&gt;</span><br><span class="line">     using namespace std;</span><br><span class="line">     </span><br><span class="line">     // Here is the product class</span><br><span class="line">     class Operation_Pos &#123;</span><br><span class="line">      public:</span><br><span class="line">       int var1, var2;</span><br><span class="line">       virtual double GetResult() &#123;</span><br><span class="line">         double res = 0;</span><br><span class="line">         return res;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     class Add_Operation_Pos : public Operation_Pos &#123;</span><br><span class="line">      public:</span><br><span class="line">       virtual double GetResult() &#123; return var1 + var2; &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     class Sub_Operation_Pos : public Operation_Pos &#123;</span><br><span class="line">      public:</span><br><span class="line">       virtual double GetResult() &#123; return var1 - var2; &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     class Mul_Operation_Pos : public Operation_Pos &#123;</span><br><span class="line">      public:</span><br><span class="line">       virtual double GetResult() &#123; return var1 * var2; &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     class Div_Operation_Pos : public Operation_Pos &#123;</span><br><span class="line">      public:</span><br><span class="line">       virtual double GetResult() &#123; return var1 / var2; &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     /*********************************************************************************/</span><br><span class="line">     class Operation_Neg &#123;</span><br><span class="line">      public:</span><br><span class="line">       int var1, var2;</span><br><span class="line">       virtual double GetResult() &#123;</span><br><span class="line">         double res = 0;</span><br><span class="line">         return res;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     class Add_Operation_Neg : public Operation_Neg &#123;</span><br><span class="line">      public:</span><br><span class="line">       virtual double GetResult() &#123; return -(var1 + var2); &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     class Sub_Operation_Neg : public Operation_Neg &#123;</span><br><span class="line">      public:</span><br><span class="line">       virtual double GetResult() &#123; return -(var1 - var2); &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     class Mul_Operation_Neg : public Operation_Neg &#123;</span><br><span class="line">      public:</span><br><span class="line">       virtual double GetResult() &#123; return -(var1 * var2); &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     class Div_Operation_Neg : public Operation_Neg &#123;</span><br><span class="line">      public:</span><br><span class="line">       virtual double GetResult() &#123; return -(var1 / var2); &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     /*****************************************************************************************************/</span><br><span class="line">     </span><br><span class="line">     // Here is the Factory class</span><br><span class="line">     class Factory &#123;</span><br><span class="line">      public:</span><br><span class="line">       virtual Operation_Pos *CreateProduct_Pos() = 0;</span><br><span class="line">       virtual Operation_Neg *CreateProduct_Neg() = 0;</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     class Add_Factory : public Factory &#123;</span><br><span class="line">      public:</span><br><span class="line">       Operation_Pos *CreateProduct_Pos() &#123; return new Add_Operation_Pos(); &#125;</span><br><span class="line">       Operation_Neg *CreateProduct_Neg() &#123; return new Add_Operation_Neg(); &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     class Sub_Factory : public Factory &#123;</span><br><span class="line">      public:</span><br><span class="line">       Operation_Pos *CreateProduct_Pos() &#123; return new Sub_Operation_Pos(); &#125;</span><br><span class="line">       Operation_Neg *CreateProduct_Neg() &#123; return new Sub_Operation_Neg(); &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     class Mul_Factory : public Factory &#123;</span><br><span class="line">      public:</span><br><span class="line">       Operation_Pos *CreateProduct_Pos() &#123; return new Mul_Operation_Pos(); &#125;</span><br><span class="line">       Operation_Neg *CreateProduct_Neg() &#123; return new Mul_Operation_Neg(); &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     class Div_Factory : public Factory &#123;</span><br><span class="line">      public:</span><br><span class="line">       Operation_Pos *CreateProduct_Pos() &#123; return new Div_Operation_Pos(); &#125;</span><br><span class="line">       Operation_Neg *CreateProduct_Neg() &#123; return new Div_Operation_Neg(); &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     int main() &#123;</span><br><span class="line">       int a, b;</span><br><span class="line">       cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">       Add_Factory *p_fac = new Add_Factory();</span><br><span class="line">       Operation_Pos *p_pro = p_fac-&gt;CreateProduct_Pos();</span><br><span class="line">       p_pro-&gt;var1 = a;</span><br><span class="line">       p_pro-&gt;var2 = b;</span><br><span class="line">       cout &lt;&lt; p_pro-&gt;GetResult() &lt;&lt; endl;</span><br><span class="line">     </span><br><span class="line">       Add_Factory *p_fac1 = new Add_Factory();</span><br><span class="line">       Operation_Neg *p_pro1 = p_fac1-&gt;CreateProduct_Neg();</span><br><span class="line">       p_pro1-&gt;var1 = a;</span><br><span class="line">       p_pro1-&gt;var2 = b;</span><br><span class="line">       cout &lt;&lt; p_pro1-&gt;GetResult() &lt;&lt; endl;</span><br><span class="line">     </span><br><span class="line">       return 0;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
</li>
</ol>
<h4 id="什么是观察者模式？如何实现？应用场景？">什么是观察者模式？如何实现？应用场景？</h4>
<p><strong>观察者模式</strong>：定义一种一（被观察类）对多（观察类）的关系，让多个观察对象同时监听一个被观察对象，被观察对象状态发生变化时，会通知所有的观察对象，使他们能够更新自己的状态。</p>
<p><strong>观察者模式中存在两种角色：</strong></p>
<ul>
<li>观察者：内部包含被观察者对象，当被观察者对象的状态发生变化时，更新自己的状态。（接收通知更新状态）</li>
<li>被观察者：内部包含了所有观察者对象，当状态发生变化时通知所有的观察者更新自己的状态。（发送通知）</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li>当一个对象的改变需要同时改变其他对象，且不知道具体有多少对象有待改变时，应该考虑使用观察者模式；</li>
<li>一个抽象模型有两个方面，其中一方面依赖于另一方面，这时可以用观察者模式将这两者封装在独立的对象中使它们各自独立地改变和复用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span>;</span></span><br><span class="line"><span class="comment">//观察者 基类 （内部实例化了被观察者的对象sub）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> &#123;</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  string name;</span><br><span class="line">  Subject *sub;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Observer</span>(string name, Subject *sub) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;sub = sub;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockObserver</span> :</span> <span class="keyword">public</span> Observer &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">StockObserver</span>(string name, Subject *sub) : <span class="built_in">Observer</span>(name, sub) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NBAObserver</span> :</span> <span class="keyword">public</span> Observer &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">NBAObserver</span>(string name, Subject *sub) : <span class="built_in">Observer</span>(name, sub) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//被观察者 基类</span></span><br><span class="line"><span class="comment">//（内部存放了所有的观察者对象，以便状态发生变化时，给观察者发通知）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> &#123;</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  list&lt;Observer *&gt; observers;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  string action;  <span class="comment">//被观察者对象的状态</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer *)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer *)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Secretary</span> :</span> <span class="keyword">public</span> Subject &#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer *observer)</span> </span>&#123; observers.<span class="built_in">push_back</span>(observer); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer *observer)</span> </span>&#123;</span><br><span class="line">    list&lt;Observer *&gt;::iterator iter = observers.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (iter != observers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((*iter) == observer) &#123;</span><br><span class="line">        observers.<span class="built_in">erase</span>(iter);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ++iter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;Observer *&gt;::iterator iter = observers.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (iter != observers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      (*iter)-&gt;<span class="built_in">update</span>();</span><br><span class="line">      ++iter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StockObserver::update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 收到消息：&quot;</span> &lt;&lt; sub-&gt;action &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">if</span> (sub-&gt;action == <span class="string">&quot;梁所长来了!&quot;</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我马上关闭股票，装做很认真工作的样子！&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NBAObserver::update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 收到消息：&quot;</span> &lt;&lt; sub-&gt;action &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">if</span> (sub-&gt;action == <span class="string">&quot;梁所长来了!&quot;</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我马上关闭NBA，装做很认真工作的样子！&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Subject *dwq = <span class="keyword">new</span> <span class="built_in">Secretary</span>();</span><br><span class="line">  Observer *xs = <span class="keyword">new</span> <span class="built_in">NBAObserver</span>(<span class="string">&quot;xiaoshuai&quot;</span>, dwq);</span><br><span class="line">  Observer *zy = <span class="keyword">new</span> <span class="built_in">NBAObserver</span>(<span class="string">&quot;zouyue&quot;</span>, dwq);</span><br><span class="line">  Observer *lm = <span class="keyword">new</span> <span class="built_in">StockObserver</span>(<span class="string">&quot;limin&quot;</span>, dwq);</span><br><span class="line"></span><br><span class="line">  dwq-&gt;<span class="built_in">attach</span>(xs);</span><br><span class="line">  dwq-&gt;<span class="built_in">attach</span>(zy);</span><br><span class="line">  dwq-&gt;<span class="built_in">attach</span>(lm);</span><br><span class="line"></span><br><span class="line">  dwq-&gt;action = <span class="string">&quot;去吃饭了！&quot;</span>;</span><br><span class="line">  dwq-&gt;<span class="built_in">notify</span>();</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  dwq-&gt;action = <span class="string">&quot;梁所长来了!&quot;</span>;</span><br><span class="line">  dwq-&gt;<span class="built_in">notify</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="什么是单例设计模式，如何实现">什么是单例设计模式，如何实现</h4>
<ol>
<li>
<p>单例模式定义</p>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p>
<p>那么我们就必须保证：</p>
<p>（1）该类不能被复制。</p>
<p>（2）该类不能被公开的创造。</p>
<p>那么对于C++来说，它的构造函数，拷贝构造函数和赋值函数都不能被公开调用。</p>
</li>
<li>
<p>单例模式<strong>实现方式</strong></p>
<p>单例模式通常有两种模式，分别为<strong>懒汉式单例</strong>和<strong>饿汉式单例</strong>。两种模式实现方式分别如下：</p>
<p>（1）懒汉式设计模式实现方式（2种）</p>
<p>a. 静态指针 + 用到时初始化</p>
<p>b. 局部静态变量</p>
<p>（2）饿汉式设计模式（2种）</p>
<p>a. 直接定义静态对象</p>
<p>b. 静态指针 + 类外初始化时new空间实现</p>
</li>
</ol>
<p><strong>解析</strong></p>
<ol>
<li>
<p>懒汉模式</p>
<p>懒汉模式的特点是延迟加载，比如配置文件，采用懒汉式的方法，配置文件的实例直到用到的时候才会加载，不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候才会去实例化。以下是懒汉模式实现方式C++代码：</p>
<p>（1）<strong>懒汉模式实现一：静态指针 + 用到时初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实例（线程不安全）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> T&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!value_) &#123;</span><br><span class="line">      value_ = <span class="keyword">new</span> <span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *value_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Singleton</span>();</span><br><span class="line">  ~<span class="built_in">Singleton</span>();</span><br><span class="line">  <span class="keyword">static</span> T* value_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Singleton&lt;T&gt;::value_ = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>在单线程中，这样的写法是可以正确使用的，但是在多线程中就不行了，该方法是线程不安全的。<br>
a. 假如线程A和线程B, 这两个线程要访问getInstance函数，线程A进入getInstance函数，并检测if条件，由于是第一次进入，value为空，if条件成立，准备创建对象实例。<br>
b. 但是，线程A有可能被OS的调度器中断而挂起睡眠，而将控制权交给线程B。<br>
c. 线程B同样来到if条件，发现value还是为NULL，因为线程A还没来得及构造它就已经被中断了。此时假设线程B完成了对象的创建，并顺利的返回。<br>
d. 之后线程A被唤醒，继续执行new再次创建对象，这样一来，两个线程就构建两个对象实例，这就破坏了唯一性。<br>
另外，还存在内存泄漏的问题，new出来的东西始终没有释放，下面是一种饿汉式的一种改进。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实例（线程安全）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> T&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  这里使用了两个 if判断语句的技术称为双检锁；好处是，只有判断指针为空的时候才加锁，</span></span><br><span class="line">    <span class="comment">//  避免每次调用 GetInstance的方法都加锁，锁的开销毕竟还是有点大的</span></span><br><span class="line">    <span class="keyword">if</span> (!value_) &#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_Mutex)</span></span>; <span class="comment">// 加锁</span></span><br><span class="line">      <span class="keyword">if</span> (!value_) &#123;</span><br><span class="line">          value_ = <span class="keyword">new</span> <span class="built_in">T</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *value_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CGarbo</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">CGarbo</span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> (Singleton::value_) <span class="keyword">delete</span> Singleton::value_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">static</span> CGarbo Garbo;</span><br><span class="line">  <span class="built_in">Singleton</span>();</span><br><span class="line">  ~<span class="built_in">Singleton</span>();</span><br><span class="line">  <span class="keyword">static</span> T* value_;</span><br><span class="line">  <span class="keyword">static</span> std::mutex m_Mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Singleton&lt;T&gt;::value_ = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>在程序运行结束时，系统会调用Singleton的静态成员Garbo的析构函数，该析构函数会删除单例的唯一实例。使用这种方法释放单例对象有以下特征：</p>
<p>a. 在单例类内部定义专有的嵌套类；</p>
<p>b. 在单例类内定义私有的专门用于释放的静态成员；</p>
<p>c. 利用程序在结束时析构全局变量的特性，选择最终的释放时机。</p>
<p>（2）<strong>懒汉模式实现二：局部静态变量（C++ 11 线程安全）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实例（C++）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> T&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> T instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Singleton</span>()&#123;&#125;;</span><br><span class="line">  <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">  Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>饿汉模式</p>
<p>单例类定义的时候就进行实例化。因为main函数执行之前，全局作用域的类成员静态变量m_Instance已经初始化，故<strong>没有多线程的问题</strong>。</p>
<p>（1）<strong>饿汉模式实现一：直接定义静态对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实例（线程安全）</span></span><br><span class="line"><span class="comment">//.h文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">  Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> Singleton m_Instance;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// CPP文件</span></span><br><span class="line">Singleton Singleton::m_Instance;  <span class="comment">//类外定义-不要忘记写</span></span><br><span class="line"><span class="function">Singleton&amp; <span class="title">Singleton::GetInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Instance; &#125;</span><br><span class="line"><span class="comment">//函数调用</span></span><br><span class="line">Singleton&amp; instance = Singleton::<span class="built_in">GetInstance</span>();</span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong></p>
<p>实现简单，多线程安全。</p>
<p><strong>缺点：</strong></p>
<p>在程序开始时，就创建类的实例，如果Singleton对象产生很昂贵，而本身有很少使用，这种方式单从资源利用效率的角度来讲，比懒汉式单例类稍差些。但从反应时间角度来讲，则比懒汉式单例类稍好些。</p>
<p><strong>使用条件：</strong></p>
<p>想避免频繁加锁时的性能消耗</p>
<p>（2）<strong>饿汉模式实现二：静态指针 + 类外初始化时new空间实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实例（线程安全）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> Singleton* p;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton* <span class="title">initance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::p = <span class="keyword">new</span> Singleton;</span><br><span class="line"><span class="function">Singleton* <span class="title">singleton::initance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="请说说工厂设计模式，如何实现，以及它的优点">请说说工厂设计模式，如何实现，以及它的优点</h4>
<ol>
<li>
<p>工厂设计模式的定义</p>
<p>定义一个创建对象的接口，让子类决定实例化哪个类，而对象的创建统一交由工厂去生产，有良好的封装性，既做到了解耦，也保证了最少知识原则。</p>
</li>
<li>
<p>工厂设计模式分类</p>
<p>工厂模式属于创建型模式，大致可以分为三类，<strong>简单工厂模式、工厂方法模式、抽象工厂模式</strong>。听上去差不多，都是工厂模式。下面一个个介绍：</p>
<p>（1）简单工厂模式</p>
<p>它的主要特点是需要在工厂类中做判断，从而创造相应的产品。当增加新的产品时，就需要修改工厂类。</p>
<p>**举例：**有一家生产处理器核的厂家，它只有一个工厂，能够生产两种型号的处理器核。客户需要什么样的处理器核，一定要显示地告诉生产工厂。下面给出一种实现方案：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序实例（简单工厂模式）</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CTYPE</span> &#123;</span> COREA, COREB &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCore</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单核A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreA</span> :</span> <span class="keyword">public</span> SingleCore &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;SingleCore A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单核B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreB</span> :</span> <span class="keyword">public</span> SingleCore &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;SingleCore B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//唯一的工厂，可以生产两种型号的处理器核，在内部判断</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">(<span class="keyword">enum</span> CTYPE ctype)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ctype == COREA)          <span class="comment">//工厂内部判断</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreA</span>();  <span class="comment">//生产核A</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ctype == COREB)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreB</span>();  <span class="comment">//生产核B</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong> 简单工厂模式可以根据需求，动态生成使用者所需类的对象，而使用者不用去知道怎么创建对象，使得各个模块各司其职，降低了系统的耦合性。</p>
<p>**缺点：**就是要增加新的核类型时，就需要修改工厂类。这就违反了开放封闭原则：软件实体（类、模块、函数）可以扩展，但是不可修改。</p>
<p>（2）工厂方法模式</p>
<p>所谓工厂方法模式，是指定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。</p>
<p>**举例：**这家生产处理器核的产家赚了不少钱，于是决定再开设一个工厂专门用来生产B型号的单核，而原来的工厂专门用来生产A型号的单核。这时，客户要做的是找好工厂，比如要A型号的核，就找A工厂要；否则找B工厂要，不再需要告诉工厂具体要什么型号的处理器核了。下面给出一个实现方案：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序实例（工厂方法模式）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCore</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单核A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreA</span> :</span> <span class="keyword">public</span> SingleCore &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;SingleCore A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单核B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreB</span> :</span> <span class="keyword">public</span> SingleCore &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;SingleCore B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//生产A核的工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> :</span> <span class="keyword">public</span> Factory &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">SingleCoreA* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//生产B核的工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> :</span> <span class="keyword">public</span> Factory &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">SingleCoreB* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong> <strong>扩展性好，符合了开闭原则</strong>，新增一种产品时，只需增加改对应的产品类和对应的工厂子类即可。</p>
<p>**缺点：**每增加一种产品，就需要增加一个对象的工厂。如果这家公司发展迅速，推出了很多新的处理器核，那么就要开设相应的新工厂。在C++实现中，就是要定义一个个的工厂类。显然，相比简单工厂模式，工厂方法模式需要更多的类定义。</p>
<p>（3）抽象工厂模式</p>
<p>**举例：**这家公司的技术不断进步，不仅可以生产单核处理器，也能生产多核处理器。现在简单工厂模式和工厂方法模式都鞭长莫及。抽象工厂模式登场了。它的定义为提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。具体这样应用，这家公司还是开设两个工厂，一个专门用来生产A型号的单核多核处理器，而另一个工厂专门用来生产B型号的单核多核处理器，下面给出实现的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序实例（抽象工厂模式）</span></span><br><span class="line"><span class="comment">//单核</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCore</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreA</span> :</span> <span class="keyword">public</span> SingleCore &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Single Core A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCoreB</span> :</span> <span class="keyword">public</span> SingleCore &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Single Core B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//多核</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiCore</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiCoreA</span> :</span> <span class="keyword">public</span> MultiCore &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Multi Core A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiCoreB</span> :</span> <span class="keyword">public</span> MultiCore &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Multi Core B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoreFactory</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工厂A，专门用来生产A型号的处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> :</span> <span class="keyword">public</span> CoreFactory &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreA</span>(); &#125;</span><br><span class="line">  <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MultiCoreA</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工厂B，专门用来生产B型号的处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> :</span> <span class="keyword">public</span> CoreFactory &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">SingleCore* <span class="title">CreateSingleCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreB</span>(); &#125;</span><br><span class="line">  <span class="function">MultiCore* <span class="title">CreateMultiCore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MultiCoreB</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong> 工厂抽象类创建了多个类型的产品，当有需求时，可以创建相关产品子类和子工厂类来获取。</p>
<p><strong>缺点：</strong> 扩展新种类产品时困难。抽象工厂模式需要我们在工厂抽象类中提前确定了可能需要的产品种类，以满足不同型号的多种产品的需求。但是如果我们需要的产品种类并没有在工厂抽象类中提前确定，那我们就需要去修改工厂抽象类了，而一旦修改了工厂抽象类，那么所有的工厂子类也需要修改，这样显然扩展不方便。</p>
</li>
</ol>
<p><strong>答案解析</strong></p>
<p>三种工厂模式的UML图如下：</p>
<ol>
<li>
<p>简单工厂模式UML</p>
<p><img src="https://static.nowcoder.com/images/activity/2021jxy/c/assert/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.png" alt="简单工厂"></p>
</li>
<li>
<p>工厂方法的UML图</p>
<p><img src="https://static.nowcoder.com/images/activity/2021jxy/c/assert/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.png" alt="工厂方法"></p>
</li>
<li>
<p>抽象工厂模式的UML图</p>
<p><img src="https://static.nowcoder.com/images/activity/2021jxy/c/assert/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="抽象工厂模式"></p>
</li>
</ol>
<h4 id="请说说装饰器计模式，以及它的优缺点">请说说装饰器计模式，以及它的优缺点</h4>
<ol>
<li>
<p>装饰器计模式的定义</p>
<p>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
</li>
<li>
<p>优点</p>
<p>（1）装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用；</p>
<p>（2）通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果；</p>
<p>（3）装饰器模式完全遵守开闭原则。</p>
</li>
<li>
<p>缺点</p>
<p>装饰模式会增加许多子类，过度使用会增加程序得复杂性。</p>
</li>
<li>
<p>装饰模式的结构与实现</p>
<p>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。下面来分析其基本结构和实现方法。</p>
<p>装饰模式主要包含以下角色：</p>
<p>（1）抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</p>
<p>（2）具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</p>
<p>（3）抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</p>
<p>（4）具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</p>
</li>
</ol>
<p>装饰模式的结构图如下图所示：</p>
<p><img src="https://static.nowcoder.com/images/activity/2021jxy/c/assert/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="装饰器模式"></p>
<p>装饰模式结构图</p>
<p>装饰模式的实现代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基础组件接口定义了可以被装饰器修改的操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Component</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">Operation</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体组件提供了操作的默认实现。这些类在程序中可能会有几个变体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> :</span> <span class="keyword">public</span> Component &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::string <span class="title">Operation</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;ConcreteComponent&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//装饰器基类和其他组件遵循相同的接口。这个类的主要目的是为所有的具体装饰器定义封装接口。</span></span><br><span class="line"><span class="comment">//封装的默认实现代码中可能会包含一个保存被封装组件的成员变量，并且负责对齐进行初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> :</span> <span class="keyword">public</span> Component &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  Component* component_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Decorator</span>(Component* component) : <span class="built_in">component_</span>(component) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//装饰器会将所有的工作分派给被封装的组件</span></span><br><span class="line">  <span class="function">std::string <span class="title">Operation</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;component_-&gt;<span class="built_in">Operation</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体装饰器必须在被封装对象上调用方法，不过也可以自行在结果中添加一些内容。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> :</span> <span class="keyword">public</span> Decorator &#123;</span><br><span class="line">  <span class="comment">//装饰器可以调用父类的是实现，来替代直接调用组件方法。</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ConcreteDecoratorA</span>(Component* component) : <span class="built_in">Decorator</span>(component) &#123;&#125;</span><br><span class="line">  <span class="function">std::string <span class="title">Operation</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ConcreteDecoratorA(&quot;</span> + Decorator::<span class="built_in">Operation</span>() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//装饰器可以在调用封装的组件对象的方法前后执行自己的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorB</span> :</span> <span class="keyword">public</span> Decorator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ConcreteDecoratorB</span>(Component* component) : <span class="built_in">Decorator</span>(component) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::string <span class="title">Operation</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ConcreteDecoratorB(&quot;</span> + Decorator::<span class="built_in">Operation</span>() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端代码可以使用组件接口来操作所有的具体对象。这种方式可以使客户端和具体的实现类脱耦</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClientCode</span><span class="params">(Component* component)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;RESULT: &quot;</span> &lt;&lt; component-&gt;<span class="built_in">Operation</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Component* simple = <span class="keyword">new</span> ConcreteComponent;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Client: I&#x27;ve got a simple component:\n&quot;</span>;</span><br><span class="line">  <span class="built_in">ClientCode</span>(simple);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  Component* decorator1 = <span class="keyword">new</span> <span class="built_in">ConcreteDecoratorA</span>(simple);</span><br><span class="line">  Component* decorator2 = <span class="keyword">new</span> <span class="built_in">ConcreteDecoratorB</span>(decorator1);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Client: Now I&#x27;ve got a decorated component:\n&quot;</span>;</span><br><span class="line">  <span class="built_in">ClientCode</span>(decorator2);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> simple;</span><br><span class="line">  <span class="keyword">delete</span> decorator1;</span><br><span class="line">  <span class="keyword">delete</span> decorator2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="请说说观察者设计模式，如何实现">请说说观察者设计模式，如何实现</h4>
<ol>
<li>
<p>观察者设计模式的定义</p>
<p>指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</p>
</li>
<li>
<p>优点</p>
<p>（1）降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。</p>
<p>（2）目标与观察者之间建立了一套触发机制。</p>
</li>
<li>
<p>缺点</p>
<p>（1）目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</p>
<p>（2）当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</p>
</li>
<li>
<p>观察者设计模式的结构与实现</p>
<p>观察者模式的主要角色如下：</p>
<p>（1）抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</p>
<p>（2）具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</p>
<p>（3）抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</p>
<p>（4）具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</p>
</li>
</ol>
<p>可以举个博客订阅的例子，当博主发表新文章的时候，即博主状态发生了改变，那些订阅的读者就会收到通知，然后进行相应的动作，比如去看文章，或者收藏起来。博主与读者之间存在种一对多的依赖关系。下面给出相应的UML图设计:</p>
<p><img src="https://static.nowcoder.com/images/activity/2021jxy/c/assert/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="观察者模式"><br>
观察者模式的结构图</p>
<p>可以看到博客类中有一个观察者链表（即订阅者），当博客的状态发生变化时，通过Notify成员函数通知所有的观察者，告诉他们博客的状态更新了。而观察者通过Update成员函数获取博客的状态信息。代码实现不难，下面给出C++的一种实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Observer</span>() &#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//博客</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Blog</span>() &#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Blog</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(Observer *observer)</span> </span>&#123;</span><br><span class="line">    m_observers.<span class="built_in">push_back</span>(observer);</span><br><span class="line">  &#125;  <span class="comment">//添加观察者</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Remove</span><span class="params">(Observer *observer)</span> </span>&#123;</span><br><span class="line">    m_observers.<span class="built_in">remove</span>(observer);</span><br><span class="line">  &#125;              <span class="comment">//移除观察者</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span>  <span class="comment">//通知观察者</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    list&lt;Observer *&gt;::iterator iter = m_observers.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (; iter != m_observers.<span class="built_in">end</span>(); iter++) (*iter)-&gt;<span class="built_in">Update</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetStatus</span><span class="params">(string s)</span> </span>&#123; m_status = s; &#125;  <span class="comment">//设置状态</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> string <span class="title">GetStatus</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_status; &#125;     <span class="comment">//获得状态</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  list&lt;Observer *&gt; m_observers;  <span class="comment">//观察者链表</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  string m_status;  <span class="comment">//状态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上是观察者和博客的基类，定义了通用接口。博客类主要完成观察者的添加、移除、通知操作，设置和获得状态仅仅是一个默认实现。下面给出它们相应的子类实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体博客类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogCSDN</span> :</span> <span class="keyword">public</span> Blog &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  string m_name;  <span class="comment">//博主名称</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BlogCSDN</span>(string name) : <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">BlogCSDN</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetStatus</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    m_status = <span class="string">&quot;CSDN通知 : &quot;</span> + m_name + s;</span><br><span class="line">  &#125;  <span class="comment">//具体设置状态信息</span></span><br><span class="line">  <span class="function">string <span class="title">GetStatus</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_status; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObserverBlog</span> :</span> <span class="keyword">public</span> Observer &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  string m_name;  <span class="comment">//观察者名称</span></span><br><span class="line">  Blog *m_blog;  <span class="comment">//观察的博客，当然以链表形式更好，就可以观察多个博客</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ObserverBlog</span>(string name, Blog *blog) : <span class="built_in">m_name</span>(name), <span class="built_in">m_blog</span>(blog) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">ObserverBlog</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span>  <span class="comment">//获得更新状态</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    string status = m_blog-&gt;<span class="built_in">GetStatus</span>();</span><br><span class="line">    cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;-------&quot;</span> &lt;&lt; status &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试案例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Blog *blog = <span class="keyword">new</span> <span class="built_in">BlogCSDN</span>(<span class="string">&quot;wuzhekai1985&quot;</span>);</span><br><span class="line">  Observer *observer1 = <span class="keyword">new</span> <span class="built_in">ObserverBlog</span>(<span class="string">&quot;tutupig&quot;</span>, blog);</span><br><span class="line">  blog-&gt;<span class="built_in">Attach</span>(observer1);</span><br><span class="line">  blog-&gt;<span class="built_in">SetStatus</span>(<span class="string">&quot;发表设计模式C++实现（15）——观察者模式&quot;</span>);</span><br><span class="line">  blog-&gt;<span class="built_in">Notify</span>();</span><br><span class="line">  <span class="keyword">delete</span> blog;</span><br><span class="line">  <span class="keyword">delete</span> observer1;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">SEUGarfield</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.zgzheng.top/posts/45007/">https://blog.zgzheng.top/posts/45007/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.zgzheng.top" target="_blank">笑枕晚风の小站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202112281103528.jpg" data-sites="facebook,twitter,wechat,weibo,qq,qzone,douban"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/28622/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203122041145.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++ 虚函数表</div></div></a></div><div class="next-post pull-right"><a href="/posts/59570/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202111041917080.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Typora 破解教程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/38754/" title="C++ typedef typename 用法"><img class="cover" src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202112281104982.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-14</div><div class="title">C++ typedef typename 用法</div></div></a></div><div><a href="/posts/40197/" title="C++ 自定义比较器"><img class="cover" src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202112031934444.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-13</div><div class="title">C++ 自定义比较器</div></div></a></div><div><a href="/posts/45995/" title="CPP Primer知识点笔记"><img class="cover" src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031713662.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-03</div><div class="title">CPP Primer知识点笔记</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202110251550056.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">SEUGarfield</div><div class="author-info__description">欢迎乘坐猫巴士</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">93</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zgzhengSEU"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zgzhengSEU" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:DedSec@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">决定转码啦，建个博客记录学习过程，持续更新ing<div class="twopeople"><div class="container" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width:200px; max-height:200px; touch-action:none;width:640px;height:640px;"></canvas></div><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js"></script><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js"></script><script id="rendered-js" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center;}canvas {display:block;margin:0 auto;cursor:move;}</style></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Top-K"><span class="toc-text">Top K</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">1、智能指针的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E7%95%A5"><span class="toc-text">简略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86"><span class="toc-text">详细</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81new-%E4%B8%8E-malloc-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2、new 与 malloc 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3、虚函数与纯虚函数的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81STL-%E4%B8%AD-vector-%E4%B8%8E-list-%E5%85%B7%E4%BD%93%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">4、STL 中 vector 与 list 具体是怎么实现的？常见操作的时间复杂度是多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81vector-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">5、vector 的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81C-11-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">6、C++11 新特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">7、智能指针和指针的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-text">8、右值引用与移动语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E5%A4%9A%E6%80%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-text">9、多态是怎么实现的</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81%EF%BC%9F%E5%A4%9A%E6%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">什么是多态？多态如何实现？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81%EF%BC%9F%E9%99%A4%E4%BA%86%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%EF%BC%9F"><span class="toc-text">什么是多态？除了虚函数，还有什么方式能实现多态？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%A4%9A%E6%80%81%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">编译时多态和运行时多态的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81const-static-%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E8%83%BD%E5%90%A6%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8"><span class="toc-text">10、const, static 关键字有什么区别，能否同时使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#static"><span class="toc-text">static</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#const"><span class="toc-text">const</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">static关键字的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#const%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">const关键字的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#const-%E5%92%8C-static-%E4%B8%8D%E8%83%BD%E5%90%8C%E6%97%B6%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">const 和 static 不能同时修饰成员函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81C-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-text">11、C++ 内存对齐</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%9F%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%8E%9F%E5%88%99%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-text">什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">12、指针和引用的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">13、类模板和模板类的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81C-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-text">14、C++ 内联函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#inline-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-%E4%BD%9C%E7%94%A8%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">inline 内联函数 作用及使用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#inline-%E5%87%BD%E6%95%B0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">inline 函数工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">内联函数和宏函数的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82"><span class="toc-text">内联函数和函数的区别，内联函数的作用。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E3%80%81C-%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">15、C++ 编译、链接的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16%E3%80%81C-%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">16、C++ 中哪些函数不能被声明为虚函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17%E3%80%81C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">17、C++ 内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18%E3%80%81C-%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%EF%BC%9F"><span class="toc-text">18、C++ 的重载和重写？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-text">C++ 的重载和重写是如何实现的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E9%9A%90%E8%97%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">重载、重写、隐藏的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19%E3%80%81%E5%86%85%E5%AD%98%E4%B8%AD%E5%A0%86%E4%B8%8E%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">19、内存中堆与栈的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20%E3%80%81STL-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-text">20、STL 中的内存分配器原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="toc-text">21、构造函数和析构函数可以被声明为虚函数吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E3%80%81%E7%B1%BB%E9%BB%98%E8%AE%A4%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">22、类默认的构造函数是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E3%80%81lambda-%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%8C%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-text">23、lambda 函数的特点，和普通函数相比有什么优点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24%E3%80%81%E7%88%B6%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB%E6%98%AF%E4%B8%8D%E6%98%AF%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-text">24、父类和子类是不是在同一个虚函数表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25%E3%80%81STL-%E4%B8%AD%E7%9A%84-map-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">25、STL 中的 map 的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9B%B8%E5%85%B3"><span class="toc-text">26、红黑树相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27%E3%80%81C-%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="toc-text">27、C++ 的内存分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28%E3%80%81vector-%E5%92%8C-list-%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%88%A0%E9%99%A4%E6%9C%AB%E5%B0%BE%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E5%85%B6%E6%8C%87%E9%92%88%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%EF%BC%9F%E8%8B%A5%E5%88%A0%E9%99%A4%E7%9A%84%E6%98%AF%E4%B8%AD%E9%97%B4%E7%9A%84%E5%85%83%E7%B4%A0%E5%91%A2%EF%BC%9F"><span class="toc-text">28、vector 和 list 中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29%E3%80%81%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="toc-text">29、菱形继承问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-text">30、内存泄漏，怎么确定内存泄漏？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E3%80%81%E5%8F%AA%E5%AE%9A%E4%B9%89%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BC%9A%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%93%AA%E4%BA%9B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">31、只定义析构函数，会自动生成哪些构造函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E3%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">32、变量的声明和定义区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E3%80%81C-%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">33、C++ 从代码到可执行二进制文件的过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="toc-text">语言基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%8B-C-%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">简述下 C++ 语言的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E5%92%8C-C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">C 语言和 C++ 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%B8%AD-struct-%E5%92%8C-class-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">C++ 中 struct 和 class 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#include-%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%BB%A5%E5%8F%8A%E5%8F%8C%E5%BC%95%E5%8F%B7-%E2%80%9C%E2%80%9D-%E5%92%8C%E5%B0%96%E6%8B%AC%E5%8F%B7-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">include 头文件的顺序以及双引号 “” 和尖括号 &lt;&gt; 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C-C-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">C++ 结构体和 C 结构体的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5-C-%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8CC-%E7%BC%96%E8%AF%91%E6%97%B6%E5%92%8C-C-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">导入 C 函数的关键字是什么，C++ 编译时和 C 有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">C++ 从代码到可执行二进制文件的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">static 关键字的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">数组和指针的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">什么是函数指针，如何定义函数指针，有什么使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F"><span class="toc-text">静态变量什么时候初始化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nullptr-%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">nullptr 调用成员函数可以吗？为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8E%E6%8C%87%E9%92%88%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-text">什么是野指针，怎么产生的，如何避免？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">静态局部变量，全局变量，局部变量的特点，以及使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB-2"><span class="toc-text">内联函数和宏函数的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6-i-%E5%92%8C-i-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">运算符 i++ 和 ++i 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-%E5%92%8C-malloc-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%90%84%E8%87%AA%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E3%80%82"><span class="toc-text">new 和 malloc 的区别，各自底层实现原理。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-%E5%92%8C-define-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-text">const 和 define 的区别。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%B8%AD%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-text">C++中函数指针和指针函数的区别。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-int-a-int-const-a-const-int-a-int-const-a-const-int-const-a%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%E3%80%82"><span class="toc-text">const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">使用指针需要注意什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82-2"><span class="toc-text">内联函数和函数的区别，内联函数的作用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%9C%89%E5%87%A0%E7%A7%8D%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">C++有几种传值方式，之间的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const%EF%BC%88%E6%98%9F%E5%8F%B7%EF%BC%89%E5%92%8C%EF%BC%88%E6%98%9F%E5%8F%B7%EF%BC%89const%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">const（星号）和（星号）const的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%86%85%E5%AD%98"><span class="toc-text">C++内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-text">C++ 程序编译过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">全局变量、局部变量、静态全局变量、静态局部变量的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">全局变量定义在头文件中有什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">简述一下堆和栈的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">C++的内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%88%86%E9%85%8D%E5%9C%A8%E5%A0%86%E8%BF%98%E6%98%AF%E6%A0%88%EF%BC%9F"><span class="toc-text">malloc和局部变量分配在堆还是栈？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%99%90%E5%88%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%88%9B%E5%BB%BA%EF%BC%9F%E5%A6%82%E4%BD%95%E9%99%90%E5%88%B6%E5%AF%B9%E8%B1%A1%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%88%9B%E5%BB%BA%EF%BC%9F"><span class="toc-text">如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%9C%89%E5%93%AA%E4%BA%9Bsection%EF%BC%8C%E5%88%86%E5%88%AB%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E5%88%86%E9%85%8D%E5%9C%A8%E6%A0%88%E4%B8%8A%E8%BF%98%E6%98%AF%E5%A0%86%E4%B8%8A%EF%BC%9F"><span class="toc-text">程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BA-0-%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%9C%A8-bss-%E8%BF%98%E6%98%AF-data"><span class="toc-text">初始化为 0 的全局变量在 bss 还是 data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%8C%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%80%8E%E4%B9%88%E6%A3%80%E6%B5%8B%EF%BC%9F"><span class="toc-text">什么是内存泄露，内存泄露怎么检测？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B-atomoic-%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F%E3%80%82"><span class="toc-text">请简述一下 atomoic 内存顺序。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0C-%E4%B8%AD%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">简述C++中内存对齐的使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%9F%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%8E%9F%E5%88%99%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F-2"><span class="toc-text">什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc-%E5%92%8C-new-%E5%8C%BA%E5%88%AB"><span class="toc-text">malloc 和 new 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E4%BA%86-malloc-free-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81-new-delete"><span class="toc-text">有了 malloc&#x2F;free 为什么还要 new&#x2F;delete?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-text">类大小的计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">什么是内存泄露</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">什么是面向对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-text">面向对象的三大特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">重载和重写，以及它们的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E9%9A%90%E8%97%8F%E7%9A%84%E5%8C%BA%E5%88%AB-2"><span class="toc-text">重载、重写、隐藏的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84-2"><span class="toc-text">C++ 的重载和重写是如何实现的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-C-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-text">C 语言如何实现 C++ 语言中的重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%8C%E5%88%86%E5%88%AB%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-text">构造函数有几种，分别什么作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E5%AE%9A%E4%B9%89%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BC%9A%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%93%AA%E4%BA%9B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">只定义析构函数，会自动生成哪些构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%B1%BB%E9%BB%98%E8%AE%A4%E4%BC%9A%E7%94%9F%E6%88%90%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="toc-text">一个类默认会生成哪些函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%EF%BC%8C%E6%9C%89%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-text">C++ 类对象的初始化顺序，有多重继承情况下的顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-text">向上转型和向下转型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">深拷贝和浅拷贝，如何实现深拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-text">C++ 中的多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%99%9A%E6%9E%90%E6%9E%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%99%9A%E6%9E%84%E9%80%A0"><span class="toc-text">为什么要虚析构，为什么不能虚构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%98%AF%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-text">模板类是在什么时候实现的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%BB%A7%E6%89%BF%E6%97%B6%EF%BC%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E4%B8%8D%E5%90%8C%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%9F%BA%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-text">类继承时，派生类对不同关键字修饰的基类方法的访问权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BB%80%E4%B9%88%E5%BA%93%E7%94%A8%E5%88%B0%E4%BA%86%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">移动构造函数，什么库用到了这个函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%B1%BB%E5%86%85%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%90%97%EF%BC%9F"><span class="toc-text">C++ 类内可以定义引用数据成员吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">构造函数为什么不能被声明为虚函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%B8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-text">什么是常函数，有什么作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E7%BB%A7%E6%89%BF%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">什么是虚继承，解决什么问题，如何实现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">简述一下虚函数和纯虚函数，以及实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E8%83%BD%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%90%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E6%B4%BE%E7%94%9F%E7%B1%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%90%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%B8%AD%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">C++中虚函数与纯虚函数的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-text">C++ 中什么是菱形继承问题，如何解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%83%BD%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-text">构造函数中能不能调用虚方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%EF%BC%88%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%89%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-text">拷贝构造函数的参数是什么传递方式（引用传递），为什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9D%83%E9%99%90%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="toc-text">类方法和数据的权限有哪几种</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%9F"><span class="toc-text">如何理解抽象类？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81%EF%BC%9F%E5%A4%9A%E6%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F-2"><span class="toc-text">什么是多态？多态如何实现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81%EF%BC%9F%E9%99%A4%E4%BA%86%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%EF%BC%9F-2"><span class="toc-text">什么是多态？除了虚函数，还有什么方式能实现多态？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-text">虚析构函数，什么作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E5%9F%BA%E7%B1%BB%EF%BC%8C%E5%8F%AF%E5%90%A6%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%9F"><span class="toc-text">什么是虚基类，可否被实例化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%EF%BC%9F"><span class="toc-text">拷贝赋值和移动赋值？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-text">仿函数&#x2F;函数对象？有什么作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">C++ 中哪些函数不能被声明为虚函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%B8%AD%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">C++ 中类模板和模板类的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E9%87%8C%E5%AD%98%E6%94%BE%E7%9A%84%E5%86%85%E5%AE%B9%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%86%99%E8%BF%9B%E5%8E%BB%E7%9A%84%EF%BC%9F"><span class="toc-text">虚函数表里存放的内容是什么时候写进去的？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9B%B8%E5%85%B3"><span class="toc-text">类相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">什么是虚函数？什么是纯虚函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">虚函数和纯虚函数的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">虚函数的实现机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-text">单继承和多继承的虚函数表结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">如何禁止构造函数的使用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%AE%9A%E4%B9%89%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">构造函数、析构函数是否需要定义成虚函数？为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-text">如何避免拷贝？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BC%80%E9%94%80%EF%BC%9F"><span class="toc-text">如何减少构造函数开销？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E6%97%B6%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E7%8A%B6%E5%86%B5%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">多重继承时会出现什么状况？如何解决？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E7%B1%BB%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%EF%BC%9FC-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%9A%E7%BB%99%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%B1%BB%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">空类占多少字节？C++ 编译器会给一个空类自动生成哪些函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E4%B8%BA%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-text">为什么拷贝构造函数必须为引用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-text">C++ 类对象的初始化顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%B1%BB%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">如何禁止一个类被实例化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%BC%9A%E5%BF%AB%E4%B8%80%E4%BA%9B%EF%BC%9F"><span class="toc-text">为什么用成员初始化列表会快一些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%9C%80%E8%A6%81%E5%93%AA%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-text">实例化一个对象需要哪几个阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">友元函数的作用及使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-text">静态绑定和动态绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">深拷贝和浅拷贝的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%A4%9A%E6%80%81%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81%E7%9A%84%E5%8C%BA%E5%88%AB-2"><span class="toc-text">编译时多态和运行时多态的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%8C%E8%A6%81%E6%B1%82%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BF%AE%E6%94%B9%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-text">实现一个类成员函数，要求不允许修改类的成员变量？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E7%B1%BB%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF-final-%EF%BC%9F"><span class="toc-text">如何让类不能被继承(final)？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-%E7%9B%B8%E5%85%B3"><span class="toc-text">STL 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#STL-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-text">STL 的基本组成部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STL-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%8C%E5%B9%B6%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">STL 中常见的容器，并介绍一下实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STL-%E4%B8%AD-map-hashtable-deque-list-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">STL 中 map hashtable deque list 的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STL-%E7%9A%84%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%EF%BC%88allocator%EF%BC%89"><span class="toc-text">STL 的空间配置器（allocator）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STL-%E5%AE%B9%E5%99%A8%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%EF%BC%8C%E6%9F%A5%E6%89%BE%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">STL 容器用过哪些，查找的时间复杂度是多少，为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-text">迭代器？什么时候会失效？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STL%E4%B8%AD%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E6%9C%89%E6%8C%87%E9%92%88%E4%B8%BA%E4%BD%95%E8%BF%98%E8%A6%81%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9F"><span class="toc-text">STL中迭代器的作用，有指针为何还要迭代器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STL-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84"><span class="toc-text">STL 迭代器是怎么删除元素的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STL-%E4%B8%AD-resize-%E5%92%8C-reserve-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">STL 中 resize 和 reserve 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STL-%E5%AE%B9%E5%99%A8%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">STL 容器动态链接可能产生的问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-%E5%92%8C-unordered-map-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">map 和 unordered_map 的区别？底层实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector-%E5%92%8C-list-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%88%86%E5%88%AB%E9%80%82%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">vector 和 list 的区别，分别适用于什么场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">vector 的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STL-%E4%B8%AD%E7%9A%84-map-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">STL 中的 map 的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%9A%84-vector-%E5%92%8C-list%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%88%A0%E9%99%A4%E6%9C%AB%E5%B0%BE%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E5%85%B6%E6%8C%87%E9%92%88%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%EF%BC%9F%E8%8B%A5%E5%88%A0%E9%99%A4%E7%9A%84%E6%98%AF%E4%B8%AD%E9%97%B4%E7%9A%84%E5%85%83%E7%B4%A0%E5%91%A2%EF%BC%9F"><span class="toc-text">C++ 的 vector 和 list中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-%E5%92%8C-set-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%88%86%E5%88%AB%E5%8F%88%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">map 和 set 有什么区别，分别又是怎么实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#push-back-%E5%92%8C-emplace-back-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">push_back 和 emplace_back 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STL-%E4%B8%AD-vector-%E4%B8%8E-list-%E5%85%B7%E4%BD%93%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">STL 中 vector 与 list 具体是怎么实现的？常见操作的时间复杂度是多少？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">C++ 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-11-%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">C++11 的新特性有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">统一的初始化方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">成员变量默认初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#auto%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">auto关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#decltype-%E6%B1%82%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">decltype 求表达式的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-shared-ptr"><span class="toc-text">智能指针 shared_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88-nullptr%EF%BC%88%E5%8E%9F%E6%9D%A5NULL%EF%BC%89"><span class="toc-text">空指针 nullptr（原来NULL）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="toc-text">基于范围的for循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8Cmove%E8%AF%AD%E4%B9%89"><span class="toc-text">右值引用和move语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E8%BD%AC%E7%A7%BB%E8%AF%AD%E4%B9%89"><span class="toc-text">C++ 右值引用与转移语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89"><span class="toc-text">无序容器（哈希表）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">Lambda匿名函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%B8%AD%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">C++ 中智能指针和指针的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%88%86%E5%88%AB%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">C++中的智能指针有哪些？分别解决的问题以及区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0-C-%E4%B8%AD%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">简述 C++ 中智能指针的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#weak-ptr-%E8%83%BD%E4%B8%8D%E8%83%BD%E7%9F%A5%E9%81%93%E5%AF%B9%E8%B1%A1%E8%AE%A1%E6%95%B0%E4%B8%BA-0%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">weak_ptr 能不能知道对象计数为 0，为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#weak-ptr-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-shared-ptr-%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">weak_ptr 如何解决 shared_ptr 的循环引用问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#share-ptr-%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E8%B7%9F%E5%AE%83%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%87%E9%92%88%E9%87%8A%E6%94%BE%E4%BA%86"><span class="toc-text">share_ptr 怎么知道跟它共享对象的指针释放了</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shared-ptr-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%8C%E5%8E%9F%E7%90%86"><span class="toc-text">shared_ptr 线程安全性，原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA-unique-ptr-%E6%80%8E%E4%B9%88%E8%B5%8B%E5%80%BC%E7%BB%99%E5%8F%A6%E4%B8%80%E4%B8%AA-unique-ptr-%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">一个 unique_ptr 怎么赋值给另一个 unique_ptr 对象？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%9C%89%E6%B2%A1%E6%9C%89%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">智能指针有没有内存泄露的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9Aweak-ptr"><span class="toc-text">循环引用的解决方法：weak_ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B-C-11-%E4%B8%AD%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">简述一下 C++11 中四种类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-11-%E4%B8%AD-auto-%E7%9A%84%E5%85%B7%E4%BD%93%E7%94%A8%E6%B3%95"><span class="toc-text">C++ 11 中 auto 的具体用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-11-%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">C++11 中的可变参数模板新特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-text">C++ 关键字、库函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sizeof-%E5%92%8C-strlen-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">sizeof 和 strlen 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%89%E7%9A%84%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">lambda 表达式（匿名函数）的具体应用和使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#explicit-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%88%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BC%96%E8%AF%91%E5%99%A8%E8%BF%9B%E8%A1%8C%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-text">explicit 的作用（如何避免编译器进行隐式类型转换）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%92%8C-C-static-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">C 和 C++ static 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">static 的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static-%E5%9C%A8%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%88%E5%AE%9A%E4%B9%89%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-text">static 在类中使用的注意事项（定义、初始化和使用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E6%99%AE%E9%80%9A%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">static 全局变量和普通全局变量的异同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-%E4%BD%9C%E7%94%A8%E5%8F%8A%E7%94%A8%E6%B3%95"><span class="toc-text">const 作用及用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#define-%E5%92%8C-const-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">define 和 const 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#define-%E5%92%8C-typedef-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">define 和 typedef 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E5%AE%8F%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-text">用宏实现比较大小，以及两个数中的最小值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#inline-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-%E4%BD%9C%E7%94%A8%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-text">inline 内联函数 作用及使用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#inline-%E5%87%BD%E6%95%B0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-2"><span class="toc-text">inline 函数工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89%EF%BC%88define%EF%BC%89%E5%92%8C%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%EF%BC%88inline%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">宏定义（define）和内联函数（inline）的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-%E5%92%8C-malloc"><span class="toc-text">new 和 malloc</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#new-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">new 的作用？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#new-%E5%92%8C-malloc-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E7%94%B3%E8%AF%B7%E5%88%B0%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-text">new 和 malloc 如何判断是否申请到内存？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#delete-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9Fdelete-%E5%92%8C-delete-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">delete 实现原理？delete 和 delete[] 的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-%E5%92%8C-malloc-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8Cdelete-%E5%92%8C-free-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">new 和 malloc 的区别，delete 和 free 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9Fmalloc-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">malloc 的原理？malloc 的底层实现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%92%8C-C-struct-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">C 和 C++ struct 的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%86-class-%E8%BF%98%E4%BF%9D%E7%95%99-struct%EF%BC%9F"><span class="toc-text">为什么有了 class 还保留 struct？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-%E5%92%8C-union-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">struct 和 union 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class-%E5%92%8C-struct-%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">class 和 struct 的异同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%E6%98%AF%E5%90%A6%E5%85%B7%E6%9C%89%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E5%AF%B9%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-text">volatile 的作用？是否具有原子性，对编译器有什么影响？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8-volatile%EF%BC%8C-%E8%83%BD%E5%90%A6%E5%92%8C-const-%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">什么情况下一定要用 volatile， 能否和 const 一起使用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0%E4%B8%AD%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%9C%B0%E5%9D%80%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">返回函数中静态变量的地址会发生什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#extern-C-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">extern C 的作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sizeof-1-1-%E5%9C%A8-C-%E5%92%8C-C-%E4%B8%AD%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E7%BB%93%E6%9E%9C%EF%BC%9F"><span class="toc-text">sizeof(1 &#x3D;&#x3D; 1) 在 C 和 C++ 中分别是什么结果？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#memmove-%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">memmove 函数的底层原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#memmove-%E5%92%8C-memcopy-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">memmove 和 memcopy 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strcpy-%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7%EF%BC%9F"><span class="toc-text">strcpy 函数有什么缺陷？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#auto-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">auto 类型推导的原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3"><span class="toc-text">语言特性相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%A6%82%E4%BD%95%E5%B0%86%E5%B7%A6%E5%80%BC%E8%BD%AC%E6%8D%A2%E6%88%90%E5%8F%B3%E5%80%BC%EF%BC%9F"><span class="toc-text">左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-move-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">std::move() 函数的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88%EF%BC%9F%E6%8C%87%E9%92%88%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%8F%8A%E7%94%A8%E6%B3%95%EF%BC%9F"><span class="toc-text">什么是指针？指针的大小及用法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88%EF%BC%9F"><span class="toc-text">什么是野指针和悬空指针？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-11-nullptr-%E6%AF%94-NULL-%E4%BC%98%E5%8A%BF"><span class="toc-text">C++ 11 nullptr 比 NULL 优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">指针和引用的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">常量指针和指针常量的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">函数指针和指针函数的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-text">强制类型转换有哪几种？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%EF%BC%9F%E8%83%BD%E5%90%A6%E7%94%A8-memcmp-%E5%87%BD%E6%95%B0%E5%88%A4%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="toc-text">如何判断结构体是否相等？能否用 memcmp 函数判断结构体相等？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%97%B6%EF%BC%8C%E5%80%BC%E4%BC%A0%E9%80%92%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E3%80%81%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">参数传递时，值传递、引用传递、指针传递的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E6%9D%BF%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">什么是模板？如何实现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">函数模板和类模板的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%EF%BC%9F"><span class="toc-text">什么是可变参数模板？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%89%B9%E5%8C%96%EF%BC%9F"><span class="toc-text">什么是模板特化？为什么特化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#include-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">include &quot; &quot; 和 &lt;&gt; 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch-%E7%9A%84-case-%E9%87%8C%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E7%BB%86%E8%8A%82"><span class="toc-text">switch 的 case 里定义变量细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">迭代器的作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">泛型编程如何实现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96%EF%BC%9F"><span class="toc-text">什么是类型萃取？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">C++ 设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">什么是单例模式？如何实现？应用场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">什么是工厂模式？如何实现？应用场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">什么是观察者模式？如何实现？应用场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">什么是单例设计模式，如何实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">请说说工厂设计模式，如何实现，以及它的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">请说说装饰器计模式，以及它的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">请说说观察者设计模式，如何实现</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/45995/" title="CPP Primer知识点笔记"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202204031713662.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP Primer知识点笔记"/></a><div class="content"><a class="title" href="/posts/45995/" title="CPP Primer知识点笔记">CPP Primer知识点笔记</a><time datetime="2022-04-03T06:20:46.000Z" title="发表于 2022-04-03 14:20:46">2022-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/43615/" title="C++11 新特性相关知识"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203122040654.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++11 新特性相关知识"/></a><div class="content"><a class="title" href="/posts/43615/" title="C++11 新特性相关知识">C++11 新特性相关知识</a><time datetime="2022-03-12T11:56:44.000Z" title="发表于 2022-03-12 19:56:44">2022-03-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/28622/" title="C++ 虚函数表"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202203122041145.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ 虚函数表"/></a><div class="content"><a class="title" href="/posts/28622/" title="C++ 虚函数表">C++ 虚函数表</a><time datetime="2022-02-22T05:12:09.000Z" title="发表于 2022-02-22 13:12:09">2022-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/45007/" title="C++知识点笔记"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202112281103528.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++知识点笔记"/></a><div class="content"><a class="title" href="/posts/45007/" title="C++知识点笔记">C++知识点笔记</a><time datetime="2022-02-20T02:23:38.000Z" title="发表于 2022-02-20 10:23:38">2022-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/59570/" title="Typora 破解教程"><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202111041917080.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Typora 破解教程"/></a><div class="content"><a class="title" href="/posts/59570/" title="Typora 破解教程">Typora 破解教程</a><time datetime="2022-02-16T08:04:53.000Z" title="发表于 2022-02-16 16:04:53">2022-02-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By SEUGarfield</div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadWaline () {
  function initWaline () {
    const waline = new Waline(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-api-one.vercel.app/',
      avatar: 'monsterid',
      avatarCDN: 'https://sdn.geekzu.org/avatar/',
      path: location.pathname,
      visitor: false,
      dark: 'html[data-theme="dark"]'
    }, null))
  }

  if (typeof Waline === 'function') initWaline() 
  else getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js').then(initWaline)
}

if ('Waline' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/f3334bcb.js","daovoice")
</script><script>var isChatBtn = true
daovoice('init', {
  app_id: 'f3334bcb',},{
  launcher: { 
     disableLauncherIcon: isChatBtn // 悬浮 ICON 是否显示
  },
});
daovoice('update');

if (isChatBtn) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      daovoice('show')
    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: true // 悬浮 ICON 是否显示
        },
      });
    }
    function chatBtnShow () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: false // 悬浮 ICON 是否显示
        },
      });
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>